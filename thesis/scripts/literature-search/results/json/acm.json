[
    {
        "title": "PIACERE integrated development environment",
        "abstract": "This article presents a model-driven engineering (MDE) integrated development environment (IDE) to assist the DevSecOps (Development Security and Operations) process. This tool has been developed within the PIACERE H2020 project, which proposes a framework composed of a set of tools developed to support all phases of the DevSecOps life cycle including modeling, test/validation, build/generate, deployment, operate and modeling. PIACERE IDE is an Eclipse based tool, that acts as the front-end for this framework, and plays a key role in integrating other PIACERE tools. The IDE allows developers to access the different tools in a simple and unified way.",
        "keywords": "IaC (Infrastructure as Code); IDE (integrated development environment); Eclipse; DevSecOps",
        "released": 2023,
        "link": "https://doi.org/10.1145/3624486.3624507"
    },
    {
        "title": "Providing students with standardized, cloud-based programming environments at term’s start (for free)",
        "abstract": "For CS50 at Harvard, we have long provided students with a standardized programming environment, to avoid start-of-term technical difficulties that might otherwise arise if students had to install and configure compilers, interpreters, and debuggers on their own Macs and PCs. (For many students, \"hello, world\" is challenge enough on day 0, without also encountering \"command not found\" at the same time!) We originally provided students with shell accounts on a university-managed cluster of systems. We then transitioned to a cloud-based equivalent so as to manage the systems ourselves, root access and all. We transitioned thereafter to client-side virtual machines, to scale to more students and enable GUI-based assignments. We have since transitioned to web-based environments, complete with code tabs, terminal windows, and file explorers, initially implemented atop AWS Cloud9 and now, most recently, GitHub Codespaces, an implementation of Visual Studio (VS) Code in the cloud, free for teachers and students alike. In this workshop, we’ll discuss the pedagogical and technological advantages and disadvantages of every approach and focus most of our time, hands-on, on using and configuring GitHub Codespaces itself for teaching and learning. Along the way, attendees will learn how to create their own Docker images and \"devcontainers\" for their own classes and any languages they teach. Attendees will learn what is possible educationally by writing their own VS Code extensions as well. And how, at term’s end, to \"offboard\" students to VS Code itself on their own Macs and PCs, so as to continue programming independent of Codespaces.",
        "keywords": "cli; code; code editor; command-line interface; container; docker; editor; graphical user interface; gui; ide; integrated development environment; programming; terminal window; text editor; web app; web application",
        "released": 2024,
        "link": "https://doi.org/10.1145/3626253.3633427"
    },
    {
        "title": "Providing students with standardized, cloud-based programming environments at term’s start (for free)",
        "abstract": "CS50.dev is a cloud-based programming environment offered to students taking CS50 and other CS courses at Harvard University, both on-campus or online. Built atop GitHub Codespaces, CS50.dev simplifies the initial challenges commonly faced by students and instructors because of the complexities involved in setting up programming environments at term’s start. This demo offers an in-depth exploration of CS50.dev’s architecture and presents a detailed guide on customizing Docker images and development container (devcontainers) to meet the specific needs of courses within GitHub Codespaces. The demo will also provide general guidance on how to help students transition from CS50.dev to using VS Code independently on their local machines at the term’s end.",
        "keywords": "code; containers; ide; integrated development environment; programming; text editor",
        "released": 2024,
        "link": "https://doi.org/10.1145/3626253.3635429"
    },
    {
        "title": "Re-imagining computer laboratories for teaching introductory programming concepts using web-based integrated development environments: Opportunities and challenges",
        "abstract": "This study reported on students’ views and experience during the transition from a traditional computer laboratory into a web-based integrated development environment in an introductory programming concepts course. The aim of this study is twofold. First, to review and evaluate selected web-based integrated development environments (Web IDEs) that can be used to support teaching and learning of programming concepts. Second, to get insight into students’ views and experience towards the web-based integrated development environments compared to computer laboratory. Students’ understanding of basic programming concepts is part of any computer science and information technology academic program. However, research shows that it is not always easy for students to learn about these concepts, and that is reflected in the high drop rate among students in these subjects. Computer laboratory is an integral part for introductory courses on programming concepts to help students practice what they have learnt. The study is descriptive and exploratory in its nature, and was conducted in two stages. First, a review of some selected web integrated development environments was performed using a rubric for evaluating e-learning tools. Second, the study explored students’ views and experience with the web-based integrated development environment using a questionnaire and a focus group. The study demonstrated that students had positive views and experience towards the web-based integrated development environments implying that these tools have the potential to overcome the limitations inherited in computer laboratory. The study suggested some improvements to the web-based integrated development environments to be more educationally effective.",
        "keywords": "e-learning; Web-based integrated development environments; Virtual labs; Programming education",
        "released": 2022,
        "link": "https://doi.org/10.1145/3568364.3568375"
    },
    {
        "title": "Providing students with standardized, cloud-based programming environments at term’s start (for free)",
        "abstract": "For CS50 at Harvard, we have long provided students with a standardized programming environment, to avoid start-of-term technical difficulties that might otherwise arise if students had to install and configure compilers, interpreters, and debuggers on their own Macs and PCs. (For many students, \"hello, world\" is challenge enough on day 0, without also encountering \"command not found\" at the same time!) We originally provided students with shell accounts on a university-managed cluster of systems. We then transitioned to a cloud-based equivalent so as to manage the systems ourselves, root access and all. We transitioned thereafter to client-side virtual machines, to scale to more students and enable GUI-based assignments. We have since transitioned to web-based environments, complete with code tabs, terminal windows, and file explorers, initially implemented atop AWS Cloud9 and now, most recently, GitHub Codespaces, an implementation of Visual Studio (VS) Code in the cloud, free for teachers and students alike. In this workshop, we’ll discuss the pedagogical and technological advantages and disadvantages of every approach and focus most of our time, hands-on, on using and configuring GitHub Codespaces itself for teaching and learning. Along the way, attendees will learn how to create their own Docker images and \"devcontainers\" for their own classes and any languages they teach. Attendees will learn what is possible educationally by writing their own VS Code extensions as well. And how, at term’s end, to \"offboard\" students to VS Code itself on their own Macs and PCs, so as to continue programming independent of Codespaces.",
        "keywords": "cli; code; code editor; command-line interface; container; docker; editor; graphical user interface; gui; ide; integrated development environment; programming; terminal window; text editor; web app; web application",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545947.3569611"
    },
    {
        "title": "Virtual programming environments: Programming the cloud (keynote)",
        "abstract": "Cloud-based applications are ubiquitous and essential. We expect them to be simultaneously scalable and available and simple to build and deploy. Virtual Programming Environments are what make these applications possible. Virtual Programming Environments are themselves complex distributed systems, built using the entire spectrum of System and Runtime Virtualization technology that is the subject of VEE. In the first part of the talk, I will focus on the purest form of Serverless Computing: Functions as a Service (FaaS) as embodied in Virtual Programming Environments such as AWS Lambda or Apache OpenWhisk. I will describe the programming abstractions they provide to the developer and how these abstractions are realized using virtualization technology. In the second part of the talk, I will outline the research challenges in moving beyond FaaS to build Virtual Programming Environments that can productively support building complex stateful applications on the cloud.",
        "keywords": "Serverless Computing; Functions as a Service; Fault Tolerance; Distributed Systems",
        "released": 2022,
        "link": "https://doi.org/10.1145/3516807.3519421"
    },
    {
        "title": "Design and evaluation of a web-based distributed pair programming tool for novice programmers",
        "abstract": "Research on pair programming (PP) in education have shown a number of positive outcomes for learners, and especially novice programmers, such as enhanced learning, greater confidence in work quality, higher problem solving skills or enhanced interaction skills, and promotes collaborative learning. Due to these diverse advantages, pair programming in education currently follows a growing curve. Also, blended learning approaches are becoming more and more popular in education, including when learners have to learn programming. As a consequence, distributed pair programming (DPP) can be considered as a good solution to support pair programming in hybrid learning scenarios. A large number of tools from both the research community and the major integrated development environment (IDE) editors tried to study and implement DPP in their tools. However, our review of literature shows that none of them meet the requirements for delivering effective pair programming activities to novice programmers in blended learning scenarios. Based on these findings, the paper introduces a new DPP application especially designed for novice programmers. It integrates, based on some requirements identified from previous research, several features dedicated to DPP as well as other capabilities supporting extensive data collection and learning analytics. The tool has been experimented in authentic learning settings in higher education with 82 students, both in PP and DPP conditions. The experiment showed no evidence of a difference between PP and DPP on the students’ perceived usability of the application, as well as on the quality of their productions.",
        "keywords": "computer science education; distributed pair programming; novice programmers; tool design and evaluation",
        "released": 2024,
        "link": "https://doi.org/10.1145/3649217.3653571"
    },
    {
        "title": "Student adoption and perceptions of a web integrated development environment: An experience report",
        "abstract": "Students often spend a considerable amount of time and effort installing and configuring programming tools and environments. This can frustrate, and distract them from more important learning objectives, particularly in introductory programming courses. A web-based integrated development environment can serve as a low-threshold, ready-to-use programming environment, and reduce the time and effort needed to start practicing programming.In this paper, we report our experience of developing and deploying a web-based integrated development environment (web IDE) as an optional tool at a large public university that has been in use for over several years in various programming courses.We conducted a survey to understand students’ perceptions toward the web IDE and usage of its features. Using the data from the survey, we explored potential correlations between student demographic and behavioral traits in adoption of the web IDE. The results of the survey suggest that around half of the students use the IDE often or very often. We also discovered that the likelihood of adoption of the IDE decreases as students to move to upper classes. In this paper, we also describe broader lessons for educators and researchers.",
        "keywords": "web-based integrated development envioronment; tool adoption; student perceptions",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3366949"
    },
    {
        "title": "Prototyping products using web-based AI tools: Designing a tangible programming environment with children",
        "abstract": "A wide variety of children’s products such as mobile apps, toys, and assistant systems now have integrated smart features. Designing such AI-powered products with children, the users, is essential. Using high-fidelity prototypes can be a means to reveal children’s needs and behaviors with AI-powered systems. Yet, a prototype that can show unpredictable features similar to the final AI-powered product can be expensive. A more manageable and inexpensive solution is using web-based AI prototyping tools such as Teachable Machine. In this work, we developed a Teachable Machine-powered game-development environment to inform our tangible programming environment’s design decisions. Using this kind of an AI-powered high-fidelity prototype in the research process allowed us to observe children in a very similar setting to our final AI-powered product and extract design considerations. This paper reports our experience of prototyping AI-powered solutions with children and shares our design considerations for children’s self-made tangible representations.",
        "keywords": "tangible programming; co-design with children; co-creation with AI; child-AI interaction",
        "released": 2022,
        "link": "https://doi.org/10.1145/3535227.3535239"
    },
    {
        "title": "Standardizing students’ programming environments with docker containers: Using visual studio code in the cloud with GitHub codespaces",
        "abstract": "",
        "keywords": "text editor; programming; integrated development environment; ide; editor; docker; containerization; container; code editor; code",
        "released": 2022,
        "link": "https://doi.org/10.1145/3502717.3532164"
    },
    {
        "title": "Informing housing policy through web automation: Lessons for designing programming tools for domain experts",
        "abstract": "Housing costs have risen dramatically in the past decade, surpassing their pre-Recession levels, but the data that housing researchers and policymakers rely on to understand these dynamics remain subject to important limitations in their spatiotemporal granularity or methodological transparency. While these aspects of existing public and private data sources present barriers to understanding the geography of cost and availability in markets across the United States, web data about housing opportunities provide an important alternative—albeit one that demands technical skills that would-be data users may lack. This case study documents the experiences of a collaboration between social and computer scientists focused on using a novel programming-by-demonstration tool for web automation, Helena, to inform rental housing policy and inequalities in the United States. While this project was initially focused on collecting housing ads from a single site within the Seattle area, the capacity to scale our project to new sources and locations afforded by Helena’s human-centered design allowed a team of social scientists to progress to scraping data across the country and multiple platforms. Using this project as a case study, we discuss a.) important programming and research challenges that were encountered and b.) how Helena’s design helped us overcome these barriers to using scraped web data in basic research and policy analysis.",
        "keywords": "web automation; housing policy; applied sociology",
        "released": 2022,
        "link": "https://doi.org/10.1145/3491101.3503575"
    },
    {
        "title": "GLIDE (git-learning IDE; integrated development environment): In-class collaboration in web engineering curriculum for youths (abstract only)",
        "abstract": "Despite software engineering’s inherently collaborative nature, collaboration with others hasn’t been the primary way for students to learn how to program. Although various collaboration frameworks, such as Git, are widely used in software engineering, they’ve been treated as separate skills to acquire in addition to learning programming languages, rather than ways of learning, working, and thinking while learning to program. One collaborative software development task that students often want to engage in is building websites. However, the complexity of web syntax and architecture has been a hurdle in teaching and learning web design and development, especially for beginners without sufficient technical background. Specifically, syntactic barriers in several different languages for a webpage, inherent coupling of content and design in HTML, difficulty in understanding server-client model, and need for hosting resources for deployment contribute to a steep learning curve in building websites \"from scratch\". This work aims to address these issues by developing GLIDE (Git-Learning Integrated Development Environment) - a set of tools and curriculum that support in-class collaborative development in web engineering courses. GLIDE structures the website development process as a teacher-guided Git workflow for a team of students collaborating in groups in a Git repository. The application also provides a web programming model that separates content, from design, from implementation, allowing students to take on different roles and responsibilities during the development process. This demo presents a tutorial on how a group of students can build websites collaboratively with teacher’s assistance based on the GLIDE software platform and curriculum.",
        "keywords": "web engineering curriculum; k-12 cs education; collaborative software engineering",
        "released": 2018,
        "link": "https://doi.org/10.1145/3159450.3162203"
    },
    {
        "title": "Cloud-based development environment: A case study of teaching a cross-platform mobile app course",
        "abstract": "This workshop aims to share the experiences of using a cloud-based development environment for teaching a cross-platform mobile app requiring full-stack technologies. This approach brings several benefits to instructors and students: 1) Instructors can be free from trouble shootings in their students’ local desktop-based development environments. 2) Students can focus on the main concepts and skills of the course rather than the environment. Cloud-based development environments can be accessed from any device with an internet connection. It provides flexibility and convenience for the student. 3) Instructors can save their grading time by accessing the cloud-based development environment of each student. Furthermore, 4) students are exposed to the power of cloud computing with built-in version control systems.",
        "keywords": "React Native; Mobile Apps; Cross-Platform; Cloud-based Development Environment",
        "released": 2023,
        "link": "https://doi.org/10.1145/3585059.3611429"
    },
    {
        "title": "Building keyword-indexed virtual libraries in a logic programming environment",
        "abstract": "KW-GPS is a system to assist users intent on enjoying Web resources related to a domain-restricted collection of stories. In this system, each story is referenced in a virtual library in terms of the following data: (1) the URLs of resources associated with the story, which include but are not limited to plot-summaries, narrative texts, and videos; and (2) keywords of different classes, which serve as a multi-aspect index mechanism. Library items also include story templates, representing narrative motifs. Furthermore, a reduced version of the tool runs the basic rank-and-show process on mobile devices.",
        "keywords": "web resources; virtual libraries; story templates; logic programming; digital entertainment; detective stories",
        "released": 2014,
        "link": "https://doi.org/10.1145/2664551.2664553"
    },
    {
        "title": "WeScheme: The browser is your programming environment",
        "abstract": "We present a programming environment called WeScheme that runs in the Web browser and supports interactive development. WeScheme programmers can save programs directly on the Web, making them accessible from everywhere. As a result, sharing of programs is a central focus that WeScheme supports seamlessly. The environment also leverages the existing presentation media and program run-time support found in Web browsers, thus making these easily accessible to students and leveraging their rapid engineering improvements. WeScheme is being used successfully by students, and is especially valuable in schools that have prohibitions on installing new software or lack the computational demands of more intensive programming environments.",
        "keywords": "web; programming environments",
        "released": 2011,
        "link": "https://doi.org/10.1145/1999747.1999795"
    },
    {
        "title": "Integrating multimedia data processing parts in cloud into folder programming environment",
        "abstract": "There are a variety of media processing parts such as Image-Magick, FFmpeg, and OpenCV. A mechanism is necessary that allows PC users to access easily these parts in a cloud. We propose Polder, a programming environment based on a simple processing principle that provides novices with an easy programming and execution environment. Data input is achieved through dragging and dropping data objects onto a folder. The input data object is processed by a program bound to the folder name and the resulting data object is stored in the same folder. Establishing a hierarchical folder structure chains the processes of the folders. Combined with a WebDAV network folder, Polder becomes a mashup environment for end users. In this paper, we evaluate and discuss Polder based on a user questionnaire administered after students test Polder to process images, videos, and voice files. Moreover, we discuss Polder based on the application development experience using Polder.",
        "keywords": "multimedia processing; mashup; end user programming",
        "released": 2011,
        "link": "https://doi.org/10.1145/2095536.2095560"
    },
    {
        "title": "CodeKey - an online code editor to study code patterns and enhance student performance in CS courses",
        "abstract": "In the past several years, there has been an increase in web-based compilers that allow students to learn how to code using a browser. Many Universities use online code editors for their large Computer Science (CS) courses. For example, the CS200 course at UC Berkeley uses Jupyter Notebooks to teach Python for data science to 800+ students. All the students in the course must write and submit their code assignments in the web-browser. These online code editors for large CS courses presents several benefits. One benefit is that it becomes easier to monitor the steps that a student takes to solve a coding problem since keystrokes can be tracked using Javascript. Another benefit is that the code written by students can be stored in one central database, creating less barriers for code analysis. The CodeKey project aims to take advantage of analyzing code patterns of students in a CS course in order to find key insights. CodeKey aims to find these insights by monitoring the interactions (i.e. clicks and keystrokes) of students as each student attempts to solve a coding problem. The goal is to study the code patterns of students in a CS course in order to understand similarities and differences between students who perform well on a problem and students who do not. We also aim to study how revealing these coding patterns to a student can increase his understanding of how to solve a difficult coding problem by showing common mistakes, and by showing simple steps that lead to the correct solution.",
        "keywords": "web-compilers; intelligent tutor systems; computer science education",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3372680"
    },
    {
        "title": "Software development environments on the web: A research agenda",
        "abstract": "Software is rapidly moving from the desktop to the Web. The Web provides a generic user interface that allows ubiquitous access, instant collaboration, integration with other online services, and avoids installation and configuration on desktop computers. For software development, the Web presents a shift away from developer workstations as a silo, and has the promise of closer collaboration and improved feedback through innovations in Web-based interactive development environments (IDEs). Moving IDEs to the Web is not just a matter of porting desktop IDEs; a fundamental reconsideration of the IDE architecture is necessary in order to realize the full potential that the combination of modern IDEs and the Web can offer. This paper discusses research challenges and opportunities in this area, guided by a pilot study of a web IDE implementation.",
        "keywords": "web; spoofax; online; interactive development environment; integrated development environment; ide; collaboration; cloud9; cloud",
        "released": 2012,
        "link": "https://doi.org/10.1145/2384592.2384603"
    },
    {
        "title": "xOOHDM: Integrated development environment for creating and executing models in web applications design",
        "abstract": "Web applications have several characteristics that differentiate them from conventional applications. However, they are often developed without considering such characteristics, even though there are specific methods for the design of these applications. This work proposes the combined use of the OOHDM method and executable models in an integrated environment for the model-driven development of Web applications. This environment provides a DSML for navigation modeling using the notations of the OOHDM and automatically generates the corresponding executable model, which permits simulating and testing this navigation without the need of code generation. It allows developers addressing specific aspects of web applications, such as hypertext, and identifying and fixing design problems beforehand via model execution.",
        "keywords": "Papyrus; OOHDM; Executable UML; Executable Model; DSML",
        "released": 2019,
        "link": "https://doi.org/10.1145/3350768.3352732"
    },
    {
        "title": "A programming environment for web services",
        "abstract": "PEWS is a programming language for the definition of web service interfaces. PEWS programs can be used for the description of both simple and composite web services. Simple web services can be built from scratch, by the combination of (WSDL) operations. Each operation must be implemented as a Java method. Composite web services are constructed from the combination of existing web services, accessed by using their WSDL descriptions. PEWS combinators help to define the order in which web services and operations will be performed. PEWS has a human-readable syntax as well as a XML version, called XPEWS. The human-readable language is intended to help in the design of web services and in the formal reasoning about programs. XPEWS is used as an interface language between the front-end and back-end of the PEWS language processor.This paper presents the development of a computational environment for PEWS. The front-end of the environment is an Eclipse plug-in. The use of the front-end can help reducing the time for development of the compositions, by the verification of codification errors and the generation XPEWS documents. The back-end of PEWS is responsible for the implementation of the web services described in a XPEWS document. The back-end produces Java™ code (skeletons) to call the web service operations and performs them in the order defined by the XPEWS document.",
        "keywords": "front-end; back-end; PEWS",
        "released": 2008,
        "link": "https://doi.org/10.1145/1363686.1364249"
    },
    {
        "title": "Beyond open source: The TouchDevelop cloud-based integrated development environment",
        "abstract": "Software engineering tools and environments are migrating to the cloud, enabling more people to participate in programming from many more devices. To study this phenomenon in detail, we designed, implemented and deployed TouchDevelop (www.touchdevelop.com), a cloud-based integrated development environment (CIDE), which has been online for the past three years.TouchDevelop combines a cross-platform browser-based IDE for the creation of mobile+cloud apps, an online programmer/user community, and an app store. A central feature of TouchDevelop is to track all program edits, versions, runtime information, bugs, as well user comments, questions and feedback in a single cloud-based repository that is available publicly via Web APIs.In this paper, we examine a key feature of TouchDevelop that should be relevant to others creating CIDEs, namely the seamless integration of replicated workspaces, simplified version control and app publishing. An analysis of the TouchDevelop repository shows that this combination of capabilities allows users to easily create new versions of apps from existing apps, make changes to other users’ apps, and share their results from a variety of devices, including smartphones, tablets and traditional PCs.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2825041.2825057"
    },
    {
        "title": "Design of integrated courseware development environment for computer education based on online evaluation system",
        "abstract": "Distance education based on computer has become the main part of modern education in our country, which has contributed to the popularization of higher education and the improvement of teaching quality. However, at the same time, there are still many deficiencies in the opening of the existing computer education system courseware. Therefore, this paper puts forward a research on the design of integrated courseware development environment for computer education based on online evaluation system. This paper makes a detailed analysis of the classification and selection of computer education courseware, and points out the main problems existing in the existing courseware mode. In view of these shortcomings, according to the characteristics of computer education courseware, this paper puts forward the optimization design of online evaluation system. In this paper, the development ideas and objectives of the integrated courseware system are further studied. SCORM content aggregation model is used to effectively manage the micro teaching units in the courseware. Especially after the establishment of the classroom management module, the computer distance education becomes more flexible. In the application of courseware, it can be combined according to the needs, which greatly expands the computer education department the practicability of the system. The analysis shows that the computer integrated courseware management scheme based on online evaluation system not only improves the courseware editing and demonstration ability of the computer education system, but also greatly improves the comprehensive performance of the system. The teaching effect can be evaluated in real time, so that the students’ learning efficiency is higher.",
        "keywords": "Online Evaluation System; Distance Education; Computer Networks; Computer Courseware",
        "released": 2021,
        "link": "https://doi.org/10.1145/3456887.3457496"
    },
    {
        "title": "Containerizing CS50: Standardizing students’ programming environments",
        "abstract": "We argue in favor of Docker containers as alternatives to clusters of servers or virtual machines for students in introductory programming courses. We present our experience with the same since 2015 in CS50 at Harvard University as well as the pedagogical and operational motivations therefor. We present, too, the evolution of our environments for students over the years, from an on-campus cluster, to an off-campus cloud, to client-side virtual machines, to Docker containers, discussing the trade-offs of each. Not only do containers provide students with a standardized environment, reducing technical difficulties and frequently asked questions at term’s start, they also provide instructors with full control over the software in use and versions thereof, additionally allowing instructors to deploy updates mid-semester. Particularly for large courses with hundreds or even thousands of students, containers allow staff to focus more of their time on teaching than on technical support. And, coupled with text editors that support extensions or plugins, containers allow instructors to optimize students’ environment for learning, while still acquainting students with industry-standard tools. Most recently implemented atop GitHub Codespaces, a cloud-based version of Visual Studio Code, our own container-based solutions have since been used by more than 700,000 students and teachers, both on campus and off, and are also freely available to any teacher or student outside of our own university.",
        "keywords": "GUI; IDE; code; code editor; container; containerization; docker; editor; graphical user interface; integrated development environment; kubernetes; programming; text editor; web app; web application",
        "released": 2024,
        "link": "https://doi.org/10.1145/3649217.3653567"
    },
    {
        "title": "PyodideU: Unlocking python entirely in a browser for CS1",
        "abstract": "In this paper, we present an education-focused Python IDE and runtime library which can run entirely in desktop, laptop, tablet, and mobile device web browsers. Our solution provides features useful for an engaging CS1 course, and eliminates the need for a server-based runtime. We describe a new, open source, methodology for running interactive Python entirely in the browser by solving the \"WebAssembly blocking problem,\" a core technical challenge to a web-based Python solution.Because our method enables Python entirely in the browser, it unlocks many new features. For example, students can share their code with others, without incurring extra costs to the instructors or institutions. Other features include line by line code highlighting as a program executes, highly intuitive interactive graphics, mouse and touch integration, and use of a wide selection of Python modules such as Numpy and Pandas. Currently, our IDE has been used in 5 classes, covering more than 10,000 students and teachers, with over 350,000 projects created. We found that students and instructors appreciated the variety of tools and abilities the IDE made possible. We benchmark the performance of running code with our method against other online Python solutions and we discuss the benefits and additional possibilities that our method allows, such as mobile device and/or offline code execution. We provide full free public access to our IDE and open source the core libraries which enable the conversion of student written Python to WebAssembly.",
        "keywords": "cs1; ide; integrated development environment; mobile; python; web browser; webassembly",
        "released": 2024,
        "link": "https://doi.org/10.1145/3626252.3630913"
    },
    {
        "title": "End-user web development tool for tilting interactions",
        "abstract": "Tilting gestures allow end-users to use motion gestures to interact with their mobile devices. While there exist solutions for integrating motion gestures into web applications, they require programming skills to set up the gesture configuration. To allow end-users to easily introduce tilting interactions into their websites, we developed WP-TAT, a WordPress plugin that allows tilt-and-touch gestures to be easily integrated into WordPress websites without any programming. We present WP-TAT and show its potential by describing various demonstrator applications and reporting on a preliminary user study. Moreover, we also discuss how web applications could be adapted to cater for motion gestures.",
        "keywords": "web interaction framework; motion sensors; end-user development",
        "released": 2017,
        "link": "https://doi.org/10.1145/3102113.3102117"
    },
    {
        "title": "A web-based programming environment for LEGO mindstorms robots",
        "abstract": "In this paper, we present briefly an approach that provides simple, inexpensive access to a mobile telerobot in order to facilitate team-based problem solving for introductory programming students.",
        "keywords": "telerobotics; problem solving",
        "released": 2005,
        "link": "https://doi.org/10.1145/1167253.1167333"
    },
    {
        "title": "Towards an integrated, web-executable parallel programming tool environment",
        "abstract": "We present a new parallel programming tool environment that is (1) accessible and executable “anytime, anywhere,” through standard Web browsers and (2) integrated in that it provides tools which adhere to a common underlying methodology for parallel programming and performance tuning. The environment is based on a new network computing infrastructure developed at Purdue University. We evaluate our environment qualitatively by comparing our tool access method with conventional schemes of software download and installation. We also quantitatively evaluate the efficiency of interactive tool access in our environment. We do this by measuring the response times of various functions of the Ursa Minor tool and compare them with those of a Java Applet-based \"anytime, anywhere\" tool access method. We found that our environment offers significant advantages in terms of tool accessibility, integration, and efficiency.",
        "keywords": "",
        "released": 2000,
        "link": "https://dl.acm.org/doi/10.5555/370049.370067"
    },
    {
        "title": "Plagiarism networks: Finding instances of copied answers in an online introductory programming environment",
        "abstract": "We followed the submissions of automatically evaluated weekly programming assignments on an introductory programming course and searched for identical solutions submitted by students. Our dataset covers three iterations of the course, from 2014 to 2016. From this systematic longitudinal sampling, we were able to scan for plagiarism patterns and build social networks of shared answers. As a result, we present the social networking graphs of identical student-submitted answers over the past three years in which the course has been arranged.",
        "keywords": "plagiarism; online exercises; computer science education; CS1",
        "released": 2017,
        "link": "https://doi.org/10.1145/3141880.3141906"
    },
    {
        "title": "Addressing misconceptions in introductory programming: Automated feedback in integrated development environments",
        "abstract": "In recent years, numerous approaches to automated feedback have been presented in the field of programming education. Often, these methods deliver feedback through standalone web-based environments or educational programming environments. However, only few works have explored how such feedback can be provided within Integrated Development Environments (IDEs). We propose MINDFIX, an approach for integrating alternative feedback mechanisms for addressing programming language misconceptions about Java into the Eclipse IDE. These mechanisms include textual hints, code examples, and a personalized pedagogical agent. A laboratory experiment was conducted to investigate their impact on novice programmers in higher education. The results show that MINDFIX addresses missing feedback mechanisms and features. Additionally, there are initial insights that our feedback addresses programming language misconceptions while being perceived as useful and comprehensible. Our findings also suggest that novice programmers with low self-efficacy expectations perceive pedagogical agents as more motivating, useful, and less disruptive compared to their peers.",
        "keywords": "affective computing; example-based feedback; intelligent tutoring system; pedagogical agent; programming environment",
        "released": 2024,
        "link": "https://doi.org/10.1145/3629296.3629297"
    },
    {
        "title": "LearnCS! A new, browser-based c programming environment for CS1",
        "abstract": "LearnCS! is a learning environment specifically written for use by first-year computer science students. It provides students with a browser-based programming and execution environment which contains a depiction of the notional machine for the C language, and contains a built-in debugger. Many error messages are customized to assist the beginning student of computer science. These features have seemingly yielded good results in improving students’ comprehension of CS1 concepts.",
        "keywords": "",
        "released": 2014,
        "link": "https://dl.acm.org/doi/10.5555/2602724.2602752"
    },
    {
        "title": "Data collection for the learn-OCaml programming platform: Modelling how students develop typed functional programs",
        "abstract": "Online programming platforms provide unique opportunities to collect and analyze a wealth of information on how students develop programs. In this work, we give an overview of the data collection infrastructure for the Learn-OCaml programming environment which allows students to write, typecheck and run OCaml code directly in their browser. We collect data for three different events: compile reads student’s code and type-checks it; eval compiles and evaluates the code; grade runs the auto-grader on the student’s well-typed program and provides feedback on the input-output correctness and code style. The data which we aim to gather across semesters serves as a basis for a wide variety of future studies on understanding how students develop programs in the context of typed functional programming.",
        "keywords": "online programming environments; functional programming",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3439579"
    },
    {
        "title": "Lively wiki a development environment for creating and sharing active web content",
        "abstract": "Wikis are Web-based collaborative systems designed to help people share information. Wikis have become popular due to their openness which gives users complete control over the organization and the content of wiki pages. Unfortunately existing wiki engines restrict users to enter only passive content, such as text, graphics, and videos and do not allow users to customize wiki pages. Thus, wikis cannot be used to host or author rich dynamic and interactive content. In this paper we present Lively Wiki, a development and collaboration environment based on the Lively Kernel which enables users to create rich and interactive Web pages and applications - without leaving the Web. Lively Wiki combines the wiki metaphor with a direct-manipulation user interface and adds a concept for Web programming as well as programming tool support to create an easy to use, scalable, and extendable Web authoring tool. Moreover, Lively Wiki is self-supporting, i.e. the development tools were used for creating its own implementation thereby giving users the freedom to customize every aspect of the system.",
        "keywords": "web application; user innovation; morphic; end-user programming; development environment; application Wikis; Wikis",
        "released": 2009,
        "link": "https://doi.org/10.1145/1641309.1641324"
    },
    {
        "title": "Fostering collaboration with asymmetric roles in accessible programming environments for children with mixed-visual-abilities",
        "abstract": "Introduction of computational thinking training in early childhood potentiates cognitive development and better prepares children to live and prosper in a future heavily computational society. Programming environments are now widely adopted in classrooms to teach programming concepts. However, these tools are often reliant on visual interaction, making them inaccessible to children with visual impairments. Also, programming environments in general are usually designed to promote individual experiences, wasting the potential benefits of group collaborative activities. We propose the design of a programming environment that leverages asymmetric roles to foster collaborative computational thinking activities for children with visual impairments, in particular mixed-visual-ability classes. The multimodal system comprises the use of tangible blocks and auditory feedback, while children have to collaborate to program a robot. We conducted a remote online study, collecting valuable feedback on the limitations and opportunities for future work, aiming to potentiate education and social inclusion.",
        "keywords": "accessible; children; collaboration; robot; tangible; visually impaired",
        "released": 2021,
        "link": "https://doi.org/10.1145/3441852.3476553"
    },
    {
        "title": "Jupyter in the classroom: An experience report",
        "abstract": "Jupyter is an interactive web-based programming environment commonly used by Python programmers and data scientists. It can be used in the classroom either by itself or in addition to a traditional programming environment. This paper documents our experience using Jupyter in multiple computer science courses in a public four-year university using different programming languages (Java, C++, and Python). It describes our motivations for using Jupyter in these courses and how it is made available to students. It also describes the different roles it plays in our pedagogical approaches and the challenges it poses to both instructors and students. A report is presented on the preliminary experimentation conducted to evaluate its effectiveness in improving student performance. While our tests are limited by small sample sizes and did not show that using Jupyter produces a statistically significant improvement in student performance, qualitative analysis of student responses showed the usefulness of this tool in revitalizing teaching and keeping students engaged.",
        "keywords": "web-based interactive coding; jupyter; development environment",
        "released": 2022,
        "link": "https://doi.org/10.1145/3478431.3499379"
    },
    {
        "title": "Towards an adaptable curriculum-driven block-based learning environment",
        "abstract": "In this poster, we present the design of a browser-based Arduino programming tool, CASMM, to support computational thinking and making in science classrooms. This tool allows for unique integration of research tools, lesson planning, and scaffolding for learning computational thinking concepts and block-based programming. This poster will describe four key features of a block-based LMS: (1) reduced-scoped programming toolbox, (2) block locking, (3) lesson plans and starter code templates; and (4) low-tech code replay for researchers. Through discussion of this tool, we aim to catalyze conversations about integrating new scaffolding techniques into block-based programming environments to better support classroom use and research.",
        "keywords": "science integration; scaffolding; programming; learning mangement system (lms); k-12; computing education; computational thinking; block-based programming environment; arduino",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545947.3576357"
    },
    {
        "title": "Reliable cloud software development architectures and business models case study: RIDEaaS and GAE launcher",
        "abstract": "Development of cloud applications directly on the cloud infrastructure has become a common approach. Reliability concerns have also become more of a challenge during the last years. Our goal is to assert the potentials deriving from an integrated development environment, adopting software reliability concepts and fault tolerant techniques, as part of the cloud core services. As a methodology, we propose the implementation of a new cloud service Reliable Integrated Development Environment as a Service to become part of the existing core services. Our objectives are to 1) fulfill the need of having a development environment independent from personal desktop environments; 2) code development environment should be offered directly from the cloud service providers. With fault tolerant technique integration, we also suggest that the reliability of the cloud system should be handled from the cloud developers at software level when cloud quality assurance services fail to do so at their different levels. We also propose potential business models to become part of this core service for the major cloud providers. We introduce a new High Availability Coding model providing a roadmap for the future.",
        "keywords": "reliable integrated development environment; cloud software development; cloud SDK; Cloud systems",
        "released": 2019,
        "link": "https://doi.org/10.1145/3351556.3351586"
    },
    {
        "title": "Elements for a cloud-based development environment: Online collaboration, revision control, and continuous integration",
        "abstract": "In almost any other field than software development, the World Wide Web, or simply the Web has revolutionized collaboration by providing a platform for cooperative applications and services. In contrast, so far revision control, also referred to as version management, has been the key technology for enabling collaborative software development. However, even today it is feasible to build a cooperative development environment that runs in a cloud, following the spirit of Google Docs, where developers can cooperate in real time. In this paper, we take a step beyond from the design of the technical artifact that allows collaborative coding, and consider the consequences of such an approach to software development in a more general sense, in particular from the perspective of version management. The goal is to integrate collaborative development with traditional facilities commonly associated with software engineering. This in turn will lead to a development approach where new opportunities complement tools that are known to work and provide a lot of added value in software development.",
        "keywords": "version management; revision control; collaboration",
        "released": 2012,
        "link": "https://doi.org/10.1145/2361999.2362003"
    },
    {
        "title": "Utilizing web server middleware for development environments and student projects",
        "abstract": "Teaching and learning web development is challenging today because of multiple factors including complexity, scale and security. As these challenges have grown through the years of the web, educators have been required to keep up with them in order to provide web-development education that has fidelity with practice. At Southern Polytechnic, we have been trying to keep abreast with a convenient development environment that is suitable for student use. This poster identifies and analyzes the major factors involved in deciding on a platform and recommends some freely available middleware suitable for web development environments and student projects.",
        "keywords": "web; student development platform; nontraditional students; laboratory experience; instructional technologies; education; distance learning",
        "released": 2011,
        "link": "https://doi.org/10.1145/2016039.2016141"
    },
    {
        "title": "Coding tutorials for any programming language or interactive tutorials for c and arduino: (Abstract only)",
        "abstract": "Any CS educator has to explain sooner or later a portion of code or a structured text to learners. The Codecast tool http://www.codecast.info has been specially designed by CS educators and developed initially for MOOCs to replace non-interactive screencasts. This workshop is a hands-on lab to Codecast: an open-source innovative tool to create in-browser interactive coding tutorials. Codecast supports syntax highlighting for over 110 languages and as of 2017 can compile/interpret and execute a subset of the C and Arduino languages. In this workshop, participants will explore how, using our Codecast tool, a CS educator can explain the creation of a computer program while their audio as well as their interactions with the code editor and interpreter are being recorded for interactive playback. Workshop participants will furthermore experience how different aspects of the coding process like testing, running, debugging and optimizing can be illustrated with the help of several data, memory and algorithm visualization modules. Participants will create recordings and experience (like learners) how they can be played back interactively by taking control over and modify the coding process at any time. Codecast enables the learner to interact directly with the code and experiment with different ideas while listening to the instructor’s explanation. The learner can make changes to the code, test it with different inputs, run the code step-by-step to better understand its behavior and visualize other parts of the algorithm or the data. Workshop participants will also integrate their creations in their online curricula.",
        "keywords": "programming editor; online courses; mooc; interactive tutorials; integrated development environment; computer science education; coding tutorials; code editor; c programming language",
        "released": 2018,
        "link": "https://doi.org/10.1145/3159450.3162381"
    },
    {
        "title": "A scrum-based approach to CMMI maturity level 2 in web development environments",
        "abstract": "Scrum has become one of the most popular agile methodologies, either alone or combined with other agile practices. Besides, CMMI (Capability Maturity Model Integration) is accepted as a suitable model to measure the maturity of the organizations when developing or acquiring software. Although these two approaches are often considered antagonist, the use of an agile approach to reach certain CMMI maturity levels may result beneficial to organizations that develop Web systems, since they would take the advantages of both approaches. In Web community, this union may be very interesting, because agile approaches fits with the special needs of Web development, and they could be a useful tool for companies getting a certain grade of maturity. This work analyzes the goals of CMMI maturity level 2 and the feasibility of achieving them using the practices proposed by Scrum, trying to assess whether the use of this methodology is suitable for meeting the CMMI generic and specific goals or not. Finally, and based on this analysis, this paper raises a possible extension of Scrum, based on agile techniques, to accommodate the CMMI maturity level 2.",
        "keywords": "web engineering; agile methodologies; Scrum; CMMI (capability maturity model integration)",
        "released": 2012,
        "link": "https://doi.org/10.1145/2428736.2428782"
    },
    {
        "title": "Interactive programming environments for teachers and students",
        "abstract": "This workshop offers hands-on experience with a suite of interactive programming environments for teachers and students, each of them cloud-based and free. The first tool is CS50 Sandbox, via which teachers create temporary programming environments quickly and share copies of those sandboxes with students. The second tool is CS50 Lab, via which teachers can create step-by-step programming lessons, providing incremental feedback at each step, enabling students to progress from an empty file (or starter code) to working code, with hints and feedback along the way. And the third tool is CS50 IDE, via which teachers can provide students with their own cloud-based Linux environment. Each of these environments offers students a built-in file browser and code editor, along with a terminal window with shell access to their very own container. The IDE additionally provides an interactive, graphical debugger. Each tool enables students to write programs in any language for which a compiler or interpreter can be installed in the underlying container, including Java and Python. Not only will we demonstrate each tool, we’ll discuss lessons learned from having deployed these tools in CS50 at Harvard to hundreds of students on campus and thousands of students online. We’ll compare and contrast with commercial and open-source tools. And we’ll discuss challenges encountered and best practices adopted.",
        "keywords": "sandbox; programming environment; linux; lab; ide",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3432501"
    },
    {
        "title": "DS.js: Turn any webpage into an example-centric live programming environment for learning data science",
        "abstract": "Data science courses and tutorials have grown popular in recent years, yet they are still taught using production-grade programming tools (e.g., R, MATLAB, and Python IDEs) within desktop computing environments. Although powerful, these tools present high barriers to entry for novices, forcing them to grapple with the extrinsic complexities of software installation and configuration, data file management, data parsing, and Unix-like command-line interfaces. To lower the barrier for novices to get started with learning data science, we created DS.js, a bookmarklet that embeds a data science programming environment directly into any existing webpage. By transforming any webpage into an example-centric IDE, DS.js eliminates the aforementioned complexities of desktop-based environments and turns the entire web into a rich substrate for learning data science. DS.js automatically parses HTML tables and CSV/TSV data sets on the target webpage, attaches code editors to each data set, provides a data table manipulation and visualization API designed for novices, and gives instructional scaffolding in the form of bidirectional previews of how the user’s code and data relate.",
        "keywords": "novice programmers; live programming; data science",
        "released": 2017,
        "link": "https://doi.org/10.1145/3126594.3126663"
    },
    {
        "title": "Supporting the cooperation of end-user programmers through social development environments",
        "abstract": "Many programs are being created by end-users without formal training in programming. Spreadsheets are the most popular environment for this, but mashups which combine public services into new, albeit small applications are also becoming more and more popular. Research shows that end-user programmers make potentially costly mistakes. Yet initiatives that aim at bringing software engineering principles to end-users are still rudimentary. In particular, we see much unused potential in approaches that foster and support the cooperation among end-user programmers. Whereas the application of mechanisms from social software to software engineering problems is gaining traction, this has not yet been investigated sufficiently for end-user software engineering.This paper discusses how insights from Communities of Practice research may be implemented using mechanisms from recent developments in social software. From the implementation of the presented social mechanisms, we expect an improvement in cooperation and mutual help in communities of end-user programmers. We plan to combine this approach with lightweight variations of software engineering methods targeted at end-user programmers. This should lead to higher quality in the programs developed by these end-users, as good practices are more likely to spread.",
        "keywords": "social software; services; mashups; end-user development; community of practice",
        "released": 2011,
        "link": "https://doi.org/10.1145/1984701.1984704"
    },
    {
        "title": "What it takes to create with domain-appropriate tools: Reflections on implementing the “id” system",
        "abstract": "There is a One-Size-Fits-All quality to languages, APIs and even programming itself. Whether you’re making a mobile game or a scientific simulation, you will be using a text-based language with similar devices for structuring your code. This is a source of artificial difficulty in creating, understanding, and modifying software systems. No matter the domain, the author’s design needs encoding into a form that does not resemble it. This paper describes a vision where software can be built in a programming environment that is closer to the domain of the software itself. By doing so, users of the system can use familiar abstractions and tools for adapting it. A step towards this vision is presented: a Web version of a minimal OOP system, developed as an executable version of the diagrams of its design, in a substrate meant to facilitate this. The experience of creating such a substrate is analysed, and I suggest deficiencies in programming environments that stand in the way of making this practice commonplace, as well as ways to fill in these gaps.",
        "keywords": "visual programming; object-oriented; meta-circular; context-specific; adaptation",
        "released": 2020,
        "link": "https://doi.org/10.1145/3397537.3397549"
    },
    {
        "title": "The design of a programming environment to support greater social awareness and participation in early computing courses",
        "abstract": "Given the growing and widespread use of online social networking tools, coupled with social learning theory’s emphasis on learning through social participation in a community, we believe there is good reason to pursue the development of educational programming environments that support increased social interaction among learners. To that end, we have been exploring the design of a \"social programming environment\" to support students as they work on individual programming assignments, which are common in early computing courses. We present the design of OSBIDE, an Integrated Development Environment (IDE) plug-in that supports many common features of social networking environments, including an activity feed and a social recommender system that identifies learners who have encountered similar programming issues. We describe the iterative refinement of OSBIDE through its multi-semester deployment in CS 1 and CS 2 courses. Preliminary results indicate that students are generally enthusiastic about the environment’s ability to make programming more social. OSBIDE lays a strong foundation for future research into the relationships between learners’ programming and social activities, and their learning outcomes. It also has the potential to provide instructors with powerful resources for identifying and assisting struggling students.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2831373.2831399"
    },
    {
        "title": "Characterizing developer behavior in cloud based IDEs",
        "abstract": "Background: Cloud based integrated development environments (IDEs) are rapidly gaining popularity for its native support and potential to accelerate DevOps. However, there is little research of how developers behave when interacting with these environments.Aims: To develop empirical knowledge about how developers behave when interacting with cloud based IDEs to deal with programming tasks at various difficulty levels.Method: We conducted a user study using a cloud based IDE, JazzHub. We collected and coded session trace data, self-reported effort and frustration levels, and screen recordings.Results: We built a Markov activity transition model that describes the transitions among common development activities such as coding, debugging, and searching for information. It also captures extended interactions with remote resources. We correlated activity transition with different code growth trajectories. Conclusion: The findings are an early step toward realizing the potential for enhanced interactions in cloud based IDEs. Our study provides empirical evidence that may inspire the future evolution of cloud based IDE designs and features.",
        "keywords": "developer behavior; code growth trajectory; cloud based IDE; activity transition",
        "released": 2017,
        "link": "https://doi.org/10.1109/ESEM.2017.27"
    },
    {
        "title": "Conceptual framework for services creation/development environment in telecom domain",
        "abstract": "The telecom service providers (fixed and mobile) understand that they must bring in new smart services in order to attract new customers, retain existing ones and increase revenue. The challenges and goals for doing so are as follows: determining which services are needed; introducing more services in a faster manner and at lower costs; delivering innovative services in a way that allows existing users to migrate smoothly to new ones. These goals could not be achieved with traditional closed and proprietary network infrastructure, as the vendor lock-in involved in that infrastructure results in limited scope of services, and dependency on old business models. New services require a much greater degree of system flexibility, performance and scalability, as well as open standards. Next Generation Network (NGN) provide the means for enabling agile service creation capabilities that facilitate better user experiences by integrating both new and legacy services across any access. However, NGNs involve complex structures even for simple services as they consist of a large number of building blocks and necessitate hierarchical models with a lot of parallel subsystems. Thus, particular attention has to be paid to understanding and modelling the performance of these systems. The rationale of this paper lies in developing a design and engineering methodology (based on a mathematical foundation) that addresses the service creation aspects for those fields in which traditional approaches will not work for NGNs.",
        "keywords": "service delivery platform (SDP); service creation environment (SCE); queuing theory; parallel queues; next generation network (NGN); hierarchical modeling",
        "released": 2008,
        "link": "https://doi.org/10.1145/1497308.1497368"
    },
    {
        "title": "Cocode: Co-learner screen sharing for social translucence in online programming courses",
        "abstract": "Online courses are popular among learners of programming, but many learners have trouble completing the courses. A common approach to increase learner engagement is to provide co-learner presence via chat and forums. In this work, we present Cocode, an online learning system where learners can share their presence without any explicit action; their normal learning activities would signal co-learner presence. Cocode is a web application for online programming courses that shows other learners’ code editors and running screens in the programming environment to the learners while working on exercises. Results from our between-subject studies show that learners with Cocode are more engaged and work on more programming exercises compared to the learners using the system without social features.",
        "keywords": "education; online course; programming course; social translucence",
        "released": 2020,
        "link": "https://doi.org/10.1145/3334480.3383154"
    },
    {
        "title": "Teaching programming at a distance",
        "abstract": "Novice programmers face significant barriers when they cannot learn face-to-face with a teacher or with peer support in a physical computer laboratory. Online collaborative programming environments (virtual computing laboratories) enable an overview of multiple students programming at the same time, with tutors able to interact with and support individual students or groups in real-time.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1145/3555009.3555035"
    },
    {
        "title": "Cocode: Providing social presence with co-learner screen sharing in online programming classes",
        "abstract": "Social presence is known to be important for distance education, and a common approach in online classes is to provide chat boxes and forums to provide the social presence. In such a class, however, learners must explicitly act beyond their normal learning activities, so often there is no social presence in the class even when there are several learners working on the same course material. In this paper, we develop an approach where learners can share the social presence without any explicit action; their normal learning activities would be used to provide visual cues for social presence. We present Cocode, a system designed for an online programming class that shows other learners’ code editors and running output in the programming environment with minimum privacy issues. For evaluation, we ran two user studies with groups of participants who took an offline class and an online programming class from the university; results from the studies showed that learners felt less social presence in Cocode than in offline classes, but they felt significantly more social presence in Cocode than in online classes with live video lectures, forums, and chat sessions.",
        "keywords": "distance learning; education; programming education; social presence",
        "released": 2021,
        "link": "https://doi.org/10.1145/3476041"
    },
    {
        "title": "Using a virtual computing lab to teach programming at a distance",
        "abstract": "This paper discusses a pilot research project, which investigated the use of online collaborative IDEs (Integrated development environments) during a first-year computing degree course. The IDEs used can be described as virtual computing labs because they replicate some of the actions possible in physical computing labs. Students were supported by a tutor with real-time help and feedback provided, whilst they were programming, without being collocated. The use of two different platforms is considered with the benefits and drawbacks discussed. Students and tutors indicated that they would like to use a virtual computing lab approach in the future.",
        "keywords": "virtual computing laboratory; novice programmers; collaborative programming",
        "released": 2023,
        "link": "https://doi.org/10.1145/3573260.3573262"
    },
    {
        "title": "Adinda: A knowledgeable, browser-based IDE",
        "abstract": "In practice, many people have to work together to develop and maintain a software system. However, the programmer’s key tool, the Integrated Development Environment (IDE), is a solo-tool, serving to help individual programmers understand and modify the system. Such an IDE does not leverage the knowledge other team members may have of the design and implementation of the system. We propose to resolve this problem by exploring, experimentally, new ways of inferring knowledge from past IDE-interactions, and of maximizing collaboration among developers. Our approach, called Adinda, revolves around transforming the IDE into a set of integrated services, accessible via a web browser, and enriched with Web 2.0 technologies. Such services will not only help developers perform traditional IDE tasks, but also facilitate the required informal communication and collaboration needs of software development projects. In this paper, we report on our vision, approach and challenges for building Adinda, and initial results.",
        "keywords": "programming environments; interaction mining; collaboration; Web 2.0; IDE",
        "released": 2010,
        "link": "https://doi.org/10.1145/1810295.1810330"
    },
    {
        "title": "YTCoder - towards turning YouTube into a development environment",
        "abstract": "YouTube is one of the most popular video sharing platforms that hosts many video tutorials which aim to teach concepts of various programming languages. Most of these tutorials include code snippets in the videos. However, it is important that the learners have hands-on experience while learning various programming concepts. Providing a code editor along with the video tutorial could help learners get a better learning experience, as they have a scope to learn by practice. Existing solutions of accompanying video tutorials with code editors are either pre-programmed or require a separate web portal. We are not aware of any solutions in the current literature that aim to support Youtube video tutorials. Hence, we present YTCoder in this paper that aims to improve the learning experience by integrating videos related to various programming languages with the development environments of the respective programming languages. Demonstration of YTCoder can be found here - https://youtu.be/iONtO7cuQwo.",
        "keywords": "youtube; video tutorials; programming languages; code editors",
        "released": 2020,
        "link": "https://doi.org/10.1145/3406865.3418566"
    },
    {
        "title": "Seamless embedding of programming IDEs into computer-based testing software",
        "abstract": "Interest in computer-based assessment has increased in recent years, most certainly due to a shift to online learning due to the COVID pandemic. Instructors are creating questiongenerators for Computer Science classes on PrairieLearn (PL), an open-source platform developed at the University of Illinois at Urbana-Champaign PrairieLearn. The software generates differentvariants of each question to students through randomization. The challenge up to now has been that automatically graded coding problems in RISC-V or Snap!, some of the significant languages used in undergraduate Computer Science courses at our university, weren’t possible to do within the software. Thequestion could be displayed, but then the student would have to load their favorite integrated development environment (IDE), code it up, and thenreturn to PL to upload their solution. This poster discusses our approach to embedding interactive development environments for Venus (RISC-V) and Snap! directly into PrairieLearn, so students never have to leave the browser tab!",
        "keywords": "mastery learning; computer-based testing",
        "released": 2022,
        "link": "https://doi.org/10.1145/3478432.3499122"
    },
    {
        "title": "Modular-things: Plug-and-play with virtualized hardware",
        "abstract": "We present a collection of tools for building plug-and-play modular physical computing systems that we call Modular-Things. Our tools consist of a set of single purpose embedded devices, a link layer agnostic message passing system for communication between devices, and a web-based programming environment. The devices are dynamically discovered and virtualized into software objects that can be programmed in the web IDE. We tested Modular-Things in a classroom setting where groups of novice machine builders constructed custom machines that integrated embedded systems modules with high-level responsive interfaces built with web and computer vision technologies. Users also extended our system by constructing new customized devices.",
        "keywords": "composability; modular physical systems; prototyping frameworks; virtualization",
        "released": 2023,
        "link": "https://doi.org/10.1145/3544549.3585642"
    },
    {
        "title": "Tool support for architectural pattern selection and application in cloud-centric service-oriented IDEs",
        "abstract": "Architectural patterns are high-level design guidelines and principles for designing the architecture of software systems. They play a crucial role laying the foundations to the organization and structure of software systems and have high impact on their quality and success both in terms of engineering and business aspects. Deciding for a concrete software architecture design requires careful analysis of several factors regarding the software system including system characteristics, constraints, required quality attributes and any trade-offs made along with the design decision; and hence is often not trivial. This paper presents a framework for architectural pattern selection and application that (i) supports the decision-making process of choosing an appropriate architectural pattern as well as (ii) the organization of the software structure based on the chosen pattern in an automated fashion when integrated within IDEs. In particular, the paper presents how this framework is implemented and integrated within an innovative open source cloud-native integration development environment.",
        "keywords": "Software architecture decision support; IDE integration; Architectural patterns",
        "released": 2023,
        "link": "https://doi.org/10.1145/3624486.3624494"
    },
    {
        "title": "SuperNOVA: Design strategies and opportunities for interactive visualization in computational notebooks",
        "abstract": "Computational notebooks, such as Jupyter Notebook, have become data scientists’ de facto programming environments. Many visualization researchers and practitioners have developed interactive visualization tools that support notebooks, yet little is known about the appropriate design of these tools. To address this critical research gap, we investigate the design strategies in this space by analyzing 163 notebook visualization tools. Our analysis encompasses 64 systems from academic papers and 105 systems sourced from a pool of 55k notebooks containing interactive visualizations that we obtain via scraping 8.6 million notebooks on GitHub. Through this study, we identify key design implications and trade-offs, such as leveraging multimodal data in notebooks as well as balancing the degree of visualization-notebook integration. Furthermore, we provide empirical evidence that tools compatible with more notebook platforms have a greater impact. Finally, we develop SuperNOVA, an open-source interactive browser to help researchers explore existing notebook visualization tools. SuperNOVA is publicly accessible at: https://poloclub.github.io/supernova/.",
        "keywords": "Computational Notebook; Cross-Platform Visualization; Data Science; Design; Interactive Visualization; Systematic Review",
        "released": 2024,
        "link": "https://doi.org/10.1145/3613905.3650848"
    },
    {
        "title": "Iconic framework for cooperative coding",
        "abstract": "The description of an innovative framework built on top of Web-based visual programming environment is the primary aim of this contribution. In the last decade, many frameworks oriented to visual languages have been introduced in literature to improve the skill on programming languages, but at the best of our knowledge, no framework has been specially designed to support collaborative work on heterogeneous distributed environments. Therefore, SIRENE introduces a new framework in which beginners and experts can cooperate to develop algorithms by using a visual and iconic paradigm. Students, in the classroom or connected from everywhere, can be involved into the definition of the algorithm, can asynchronously modify the common working space, show a visual function to expert, thus the server hosts a shared space in which the algorithms can be visualised and modified by all of the SIRENE clients. SIRENE is primarily a visual framework oriented to collaborative approaches in which each user can visualise the evolution or implementation of some algorithms and modify it during its development by other users.",
        "keywords": "Web-based Iconic Interface; Visual Programming Environments; Interactive learning control; Collaborative Coding; Application Programming Interfaces",
        "released": 2018,
        "link": "https://doi.org/10.1145/3274005.3274016"
    },
    {
        "title": "Bringing real-time collaboration to visual programming (abstract only)",
        "abstract": "Visual programming environments have been effective educational resources but are typically limited to a single user at a time. Given the amount of collaboration in modern software development and the value of group projects for beginner programmers, providing collaboration capabilities could be invaluable for students using a block-based programming environment. Online collaboration support would not only allow students to more actively work together on projects but would also facilitate other educational activities such as tutoring and interactive demos. Moreover, providing robust collaboration utilities allows the programming environment to more closely reflect the team-based nature of large scale, real-world programming projects. Note that collaborative editing offers a number of additional benefits under the hood: the same underlying software code can easily provide detailed logging of student actions and the capability to replay them. That is, researchers will be able to study how students solve problems and not just the end result. To this end, we have extended the Snap! visual programming environment to support real-time collaboration similar to Google Docs. In our model of collaboration, sprites and scripts can be edited by multiple users simultaneously, but the execution of the programs on the stage remains local. But is this the best collaboration model for students? If not, what alternative model would be better? Should the entire programming environment be synchronized across collaborators? Would simple screen sharing be more effective? Finally, how can we leverage a real-time collaborative environment to promote teamwork on programming projects?",
        "keywords": "visual programming; computer science education; Snap!",
        "released": 2017,
        "link": "https://doi.org/10.1145/3017680.3022387"
    },
    {
        "title": "Node-read: A visually accessible low-code software development extension",
        "abstract": "Low-code software development environments are reliant on spatial and graphical user interfaces. As a result, many of these tools are in some way inaccessible to the visually impaired, and very few of these tools are built with visual accessibility in mind. In this paper, we evaluate the accessibility of existing low-code Integrated Development Environments (IDEs), for persons with partial or distorted vision. The aim of this study is to motivate making citizen/end-user software development accessible for users who are reliant on screen readers. We conducted a preliminary review of several low-code development environments which were open source and had a large existing user base, and identified that browser-based low-code IDEs did not integrate well with screen reader software. An extension of an open-source software, Node-RED, was created, as it was found to be suitable to our selection criteria. The extension, referred to as \"Node-Read\", focuses on improving compatibility with JAWS and NVDA screen readers. Node-Read’s keyboard shortcuts, along with their inclusion in critical user documentation, were reported by study participants to be helpful in the basic operation of the software.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1145/3550356.3561591"
    },
    {
        "title": "Exploring coordination models for ad hoc programming teams",
        "abstract": "Software development is a complex task with inherently interdependent sub-components. Prior work on crowdsourcing software engineering has addressed this problem by performing an a priori decomposition of the task into well-defined microtasks that individual crowd workers can complete independently. Alternatively, ad hoc teams of experts recruited from online crowds can remotely collaborate, avoiding the up-front cost to end users of task decomposition. However, these temporary ad hoc teams can lead to high coordination costs during the session itself. In this paper, we explore the types and causes of these coordination costs for transient software teams in existing collaborative programming tools: a version control system and a real-time shared editor. Based on our findings, we suggest design elements of shared programming environments that help teams effectively self-coordinate on their task.",
        "keywords": "software development tools; crowdsourcing; ad hoc teams",
        "released": 2017,
        "link": "https://doi.org/10.1145/3027063.3053268"
    },
    {
        "title": "AI assisted programming",
        "abstract": "We present a vision for a futuristic programming environment, where ML models and logical rules co-exist and evolve over time. We substantiate our vision using three case studies: (1) safe code generation using large language models, (2) heterogeneous data extraction, and (2) regulatory compliance for online advertising. Using these case studies, we hypothesize how such a futuristic programming system can balance productivity with safety, security and reliability, present new research results, and point to directions for future work.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1145/3561833.3568496"
    },
    {
        "title": "Evolution of the WebDSL runtime: Reliability engineering of the WebDSL web programming language",
        "abstract": "Web applications are ideal for implementing information systems; they can organize and persist the data in a database, do not require installation on client machines, and can be instantly updated everywhere. However, web programming is complex due to its heterogeneous nature, causing web frameworks to suffer from insufficient or leaky abstraction, weak static consistency checking, and security features that are not enforced. We developed the WebDSL web programming language, which supports direct expression of intent, strong static consistency checking, linguistic abstractions for web programming concerns, and automatically enforces security features for web applications. We have used WebDSL for over 10 years to create information systems for academic workflows with thousands of users. Based on our experiences with these applications, we improved the WebDSL compiler and runtime to increase robustness, performance, and security of applications. In this experience report, we reflect on the lessons learned and improvements made to the language runtime.",
        "keywords": "web security; web programming; web applications; integrated development environments; experience report; domain-specific languages; compilers",
        "released": 2020,
        "link": "https://doi.org/10.1145/3397537.3397553"
    },
    {
        "title": "Designing a live development experience for web-components",
        "abstract": "Explorative and live development environments flourish when they can impose restrictions. Forcing a specific programming language or framework, the environment can better enhance the experience of editing code with immediate feedback or direct manipulation. Lively Kernel’s user interface (UI) framework Morphic provides such a development experience when working with graphical objects in direct way giving immediate feedback during development. Our new development environment Lively4 achieves a similar development experience, but targeting general HTML elements. Web Components as a new Web standard provide a very powerful abstraction mechanism. Plain HTML elements provide direct building blocks for tools and applications. Unfortunately, Web Components miss proper capabilities to support run-time development. To address this issue, we use object migration to provide immediate feedback when editing UI code. The approach is evaluated by discussing known problems, resulting best practices and future work.",
        "keywords": "Web-based Programming Environment; Web Components; Live Programming; JavaScript",
        "released": 2017,
        "link": "https://doi.org/10.1145/3167109"
    },
    {
        "title": "Online learning 101: Part i: Authoring and course development tools",
        "abstract": "The first part of this three-part series focuses on authoring and course development tools and techniques for integrating e-learning. In Part II, Susan Landay explores games and interactivity solutions for e-learning. Part III looks at tools used for web conferencing, as well as learning-management systems.",
        "keywords": "",
        "released": 2010,
        "link": "https://doi.org/10.1145/1821982.1821984"
    },
    {
        "title": "Interactive programming environments for teachers and students",
        "abstract": "We present in this hands-on workshop a suite of interactive programming environments for teachers and students, each of them cloud-based and free. The first is CS50 Sandbox, a web app at sandbox.cs50.io that enables teachers and students to create temporary programming environments quickly and share copies of those sandboxes with others. With this app can a teacher start programs in class that students can then finish, distribute starter code for problems, and post interactive solutions. The second tool is CS50 Lab, a web app at lab.cs50.io that enables teachers to create step-by-step programming lessons, providing incremental feedback at each step, and enables students to progress from an empty file (or starter code) to working code, with hints and feedback along the way. Via this app can teachers author their own Codecademy-style lessons using just a GitHub repository of their own. And third in the suite is CS50 IDE, a web app at ide.cs50.io built atop Cloud9 that provides students with their own cloud-based Linux environment. Each of these environments offers a built-in file browser and code editor and, most importantly, an interactive terminal window with shell access to their very own container. And each enables students to write programs in any language. Throughout this workshop will we discuss lessons learned from having deployed these tools in CS50 at Harvard to hundreds of students on campus and thousands of students online. And we’ll discuss challenges encountered and best practices adopted.",
        "keywords": "sandbox; programming; ide",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287554"
    },
    {
        "title": "IntelliCode compose: Code generation using transformer",
        "abstract": "In software development through integrated development environments (IDEs), code completion is one of the most widely used features. Nevertheless, majority of integrated development environments only support completion of methods and APIs, or arguments. In this paper, we introduce IntelliCode Compose – a general-purpose multilingual code completion tool which is capable of predicting sequences of code tokens of arbitrary types, generating up to entire lines of syntactically correct code. It leverages state-of-the-art generative transformer model trained on 1.2 billion lines of source code in Python, C#, JavaScript and TypeScript programming languages. IntelliCode Compose is deployed as a cloud-based web service. It makes use of client-side tree-based caching, efficient parallel implementation of the beam search decoder, and compute graph optimizations to meet edit-time completion suggestion requirements in the Visual Studio Code IDE and Azure Notebook. Our best model yields an average edit similarity of 86.7",
        "keywords": "neural networks; naturalness of software; Code completion",
        "released": 2020,
        "link": "https://doi.org/10.1145/3368089.3417058"
    },
    {
        "title": "XML in a web-based grammar development environment",
        "abstract": "Example-based Development of Grammars (EDG) is a natural language parsing and grammatical knowledge representation system, implemented in Common Lisp, that uses XML to display its output. The system parses sentences and allows querying and editing of its linguistic knowledge base. The system’s response to user input is in XML, which is then transformed by an XSLT processor to form HTML, which is then displayed by the user’s browser. The XML dialect used by the system to represent linguistic structure is described, together with details of how the XSLT stylesheet transforms it into HTML. Further information about the system, including an interactive demonstration of the system, may be found on the Web at http://edg.sf.net",
        "keywords": "",
        "released": 2002,
        "link": "https://doi.org/10.3115/1118808.1118817"
    },
    {
        "title": "ToMaTo: A trustworthy code mashup development tool",
        "abstract": "Recent years have seen the emergence of a new programming paradigm for Web applications that emphasizes the reuse of external content, the mashup. Although the mashup paradigm enables the creation of innovative Web applications with emergent features, its openness introduces trust problems. These trust issues are particularly prominent in JavaScript code mashup – a type of mashup that integrated external Javascript libraries to achieve function and software reuse. With JavaScript code mashup, external libraries are usually given full privileges to manipulate data of the mashup application and executing arbitrary code. This imposes considerable risk on the mashup developers and the end users.One major causes for these trust problems is that the mashup developers tend to focus on the functional aspects of the application and implicitly trust the external code libraries to satisfy security, privacy and other non-functional requirements. In this paper, we present ToMaTo, a development tool that combines a novel trust policy language and a static code analysis engine to examine whether the external libraries satisfy the non-functional requirements. ToMaTo gives the mashup developers three essential capabilities for building trustworthy JavaScript code mashup: (1) to specify trust policy, (2) to assess policy adherence, and (3) to handle policy violation. The contributions of the paper are: (1) a description of JavaScript code mashup and its trust issues, and (2) a development tool (ToMaTo) for building trustworthy JavaScript code mashup.",
        "keywords": "trust; mashup; code analysis; JavaScript",
        "released": 2011,
        "link": "https://doi.org/10.1145/2076006.2076012"
    },
    {
        "title": "Enabling untrained users to shape real-world robot behavior using an intuitive visual programming tool in human-robot interaction scenarios",
        "abstract": "For untrained users, programming a robot that interacts with humans in a real-world scenario is challenging to impossible. However, in order to make interactive robots available in a wide range of domains and connect them with other smart devices, it must be possible to change their behavior in a simple and intuitive way. We present a visual programming tool that builds on top of the open-source Node-RED software and enables users to quickly and easily connect robots with Internet of Things (IoT) devices in order to build scenarios that include human interaction. The tool, called Node-(RED)² (Node-RED-based Robotics Empowerment Designer) is available online and currently supports the humanoid robot Pepper, but is extendable to other robots with very little effort. We demonstrate two real-world use cases of our tool that include Pepper and IoT devices and evaluate the utility of Node-(RED)² via a user study.",
        "keywords": "Human-Robot Interaction; Real-World Robotics; Robot Behavior Planning; Visual Programming",
        "released": 2024,
        "link": "https://doi.org/10.1145/3648536.3648541"
    },
    {
        "title": "ChainForge: An open-source visual programming environment for prompt engineering",
        "abstract": "Prompt engineering for large language models (LLMs) is a critical to effectively leverage their capabilities. However, due to the inherent stochastic and opaque nature of LLMs, prompt engineering is far from an exact science. Crafting prompts that elicit the desired responses still requires a lot of trial and error to gain a nuanced understanding of a model’s strengths and limitations for one’s specific task context and target application. To support users in sensemaking around the outputs of LLMs, we create ChainForge, an open-source visual programming environment for prompt engineering. ChainForge is publicly available, both on the web (https://chainforge.ai) and as a locally installable Python package hosted on PyPI. We detail some features of ChainForge and how we iterated the design in response to internal and external feedback.",
        "keywords": "language models; prompt engineering; visual programming",
        "released": 2023,
        "link": "https://doi.org/10.1145/3586182.3616660"
    },
    {
        "title": "JavaScript applications for CS0/CS1: Getting hands-on with code.org’s app lab (abstract only)",
        "abstract": "App Lab (https://code.org/applab) is Code.org’s rapid-prototyping environment for creating HTML, CSS, and JavaScript-powered web applications. It was created as part of a rich set of instructional resources designed for teachers of the new AP Computer Science Principles (CSP) course. Yet, App Lab far exceeds the needs of CSP, and would be an appropriate learning environment for students in any CS0/CS1 class, even at the university level. App Lab gives novice programmers access to capabilities previously reserved for courses that require sophisticated tech setup and knowledge of both front and backend web development, server-side scripting, databases, etc.Rather than focusing on curriculum, this workshop will focus on how App Lab works as a programming tool in its own right, and how it was designed to aid and motivate student learning. Participants will get hands-on time with some of App Lab’s more advanced features guided by a Code.org product manager, while working with the education team to help understand the educational philosophy that went into its development. Participants will come away with exemplars that highlight App Lab’s possibilities, practice with some of its richer features, and do a hackathon to create something to share with each other (and the world)! Finally, we will end with a discussion about how best to integrate App Lab into existing courses.App Lab was developed as part of collaboration between Code.org and David Bau (Google), creator of PencilCode.net.A laptop is required for this session. All other materials will be provided.",
        "keywords": "web development; programming environment; javascript; cs1; cs0; code.org; app lab",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2844692"
    },
    {
        "title": "Design of online course management system based on python",
        "abstract": "With the continuous progress and development of Internet technology, computer information management technology is also developing continuously, and all walks of life have developed their own management systems. The course management system uses educational technology and network technology to realize the online release of course resources, which is convenient for students to learn and assist teachers in teaching. The development of the visual programming environment based on Python language in this paper has gone through three stages: system requirements analysis, structure and coding design, detailed design and implementation of each module, and realized a complete and standardized course management system based on project teaching.",
        "keywords": "management system; information management technology; course resources; Python; Internet",
        "released": 2023,
        "link": "https://doi.org/10.1145/3584748.3584783"
    },
    {
        "title": "Educational computer programming tools",
        "abstract": "Learn programming is a challenging task for many students. Based on this complex challenge educators face problems with unmotivated students and high level drop-out. Technological and pedagogical strategies are recommended to overcome these issues. Technological strategies for instance use educational tools to support teach and learn computer programming topics.Based on these issues were defined the followings objectives for this work: 1) educational computer programming tools identification; 2) tools categorization 3) Programming concepts tools identification; 4) Related the low and high level comprehension computer programming topics with educational tools.To achieve the objectives was performed an extensive online search by educational computer programming tools.The aim of this work in progress is the identification of the main tools and his characterization.",
        "keywords": "online educational tools; novice programming environments; computer programming",
        "released": 2012,
        "link": "https://doi.org/10.1145/2316936.2316947"
    },
    {
        "title": "Design and development of platform system for english assisted instruction based on ASP",
        "abstract": "The platform is designed to solve the problem that teachers and students cannot work and communicate in a unified digital learning platform. The purpose of teaching assistant platform system is to establish a unified and convenient digital platform for teachers and students. The online English teaching system is a B/S structure of the system, its release needs the support of WEB server, and database system to facilitate the storage of system, data query, modify, delete, update the information system, also needs a simple, convenient programming tools that can interact with the database. In view of the above requirements, this system chooses IIS as development environment 5.0SQL Server2000 and ASP. The paper presents design and development of platform system for English assisted instruction based on ASP.",
        "keywords": "WEB server; SQL Server2000; English assisted; ASP",
        "released": 2020,
        "link": "https://doi.org/10.1145/3419635.3419731"
    },
    {
        "title": "OSBLE+: A next-generation learning management and analytics environment for computing education",
        "abstract": "In order best to support learning analytics in computing education, learning management systems (LMS) should be interfaced with computer programming environments, in which computing students spend much of their time. To this end, we have developed OSBLE+, an outgrowth of the OSBLE (Online Studio- Based Learning Environment) LMS we have been developing over the past eight years. OSBLE+ supports two innovations that make it particularly well-suited to supporting learning analytics in computing education. First, it connects to the Microsoft Visual Studio computer programming environment via a plugin that gives it access to all programming process data within Visual Studio, including edits, compilation attempts, compilation errors, debugging attempts, and run-time exceptions. This enables OSBLE+ to provide students and instructors with a visual analytics environment in which they can explore, compare, and contrast the programming activities of students in the class. Second, the plugin turns Visual Studio into a social programming environment by injecting into it a social media-style activity stream, which enables students (a) to pose and answer programming questions, and (b) to see and explore the programming activities of their peers. Students’ social activities within the activity stream are sent to OSBLE+, and are subsequently included as data in the visual analytics environment. OSBLE+ is open source and freely hosted at http://plus.osble.org. While OSBLE+ presently interfaces only with Visual Studio, a plug-in for the Eclipse programming environment is under active development.",
        "keywords": "social programming; social process data; programming; learning management systems; learning analytics; CS ed",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2850509"
    },
    {
        "title": "Good-bye localhost: A cloud-based web IDE for teaching java EE web development to non-computer science majors",
        "abstract": "While cloud- and web-based Integrated Development Environments (IDE) are used in practice and education for some time, these are mainly intended for classical web development. Support for enterprise platforms such as Java Enterprise Edition (EE) is typically lacking. However, in higher education, web-based cloud IDE are particularly useful in software development courses for non-computer science major students, since they could help to overcome the participants’ limited IT skills. Thus, a respective easy-to-use web IDE is required. Therefore, in this paper a software platform for a web-based cloud IDE for educational purposes is proposed and evaluated, which in particular supports Java EE and is suitable for non-computer science majors. The platform was evaluated in a classroom experiment. The results indicate that it is useful and beneficial for the students, allowing the lecturer and the students to focus more on the actual learning objectives.",
        "keywords": "web development education; non-computer science majors; higher education; cloud computing; Java EE",
        "released": 2019,
        "link": "https://doi.org/10.1109/ICSE-Companion.2019.00108"
    },
    {
        "title": "Online model-driven IDE to design GUIs for cross-platform mobile applications",
        "abstract": "The wide variation in features and capabilities of mobile devices lead to difficulties in the development of the same application on different platforms. Therefore we propose an online model-driven integrated development environment to provide developers with a platform-independent GUI design for mobile applications. Our proposed system transforms an abstract platform-independent GUI into a platform-dependent GUI on a target platform. The generated project is entirely in the form with which an experienced developer on the platform is already familiar. Furthermore, as the generated application is not a web-based one, it can access naturally native features of a platform. The proposed flexible architecture enable the capability to handle and update different abstract UI and non-UI controls needed to design GUIs for mobile applications. Experimental results with volunteers show that our proposed solution can save up to 25–51",
        "keywords": "software development tool; online IDE; mobile HCI; GUI design",
        "released": 2013,
        "link": "https://doi.org/10.1145/2542050.2542083"
    },
    {
        "title": "JooMDD: A model-driven development environment for web content management system extensions",
        "abstract": "Developing software extensions for Web Content Management Systems (WCMSs) like Joomla, WordPress, or Drupal can be a difficult and time consuming process. In this demo we present JooMDD, an environment for model-driven development of software extensions for the WCMS Joomla. JooMDD allows the rapid development of standardised software extensions requiring reduced technological knowledge of Joomla. This implies that even inexperienced developers are able to create their own functional WCMS extensions. This demonstrates that a model-driven approach is suitable for the domain of WCMSs.A supporting video illustrating the main features and a demonstration of JooMDD can be found at: https://youtu.be/Uy_WBIjPldI.",
        "keywords": "web content management systems; model-driven development; Joomla",
        "released": 2016,
        "link": "https://doi.org/10.1145/2889160.2889176"
    },
    {
        "title": "WebLinux: A scalable in-browser and client-side linux and IDE",
        "abstract": "\"WebLinux\" is a web app tool providing a standard Linux OS and an IDE in the browser, including a terminal, a code editor and a file browser. It provides a client-side and offline Linux OS environment based on a Javascript emulated processor. By avoiding the use of a Virtual Machine or any Linux server, Weblinux enables learners to directly start experimenting with the Linux OS without installing any software. The tool is entirely client-side which makes it extremely scalable and easy to deploy within a large community of online learners.",
        "keywords": "scalability; openrisc; linux; javascript; in-browser IDE; emulator; education; browser; MOOC; CLI",
        "released": 2018,
        "link": "https://doi.org/10.1145/3231644.3231703"
    },
    {
        "title": "Java WIDE - java wiki integrated development environment: Nifty tools and assignments",
        "abstract": "Over the past decade applications have been moving from the desktop into the cloud. After extensive searching, the only integrated development environments has emerged in cloud computing. The Java Wiki Integrated Development Environment (JavaWIDE) is the new online IDEs, and it is designed to be simple enough for novice programmers to use.",
        "keywords": "",
        "released": 2011,
        "link": "https://dl.acm.org/doi/10.5555/2037151.2037170"
    },
    {
        "title": "TAPA-CS: Enabling scalable accelerator design on distributed HBM-FPGAs",
        "abstract": "Despite the increasing adoption of FPGAs in compute clouds, there remains a significant gap in programming tools and abstractions which can leverage network-connected, cloud-scale, multi-die FPGAs to generate accelerators with high frequency and throughput. We propose TAPA-CS, a task-parallel dataflow programming framework which automatically partitions and compiles a large design across a cluster of FPGAs while achieving high frequency and throughput. TAPA-CS has three main contributions. First, it is an open-source framework which allows users to leverage virtually \"unlimited\" accelerator fabric, high-bandwidth memory (HBM), and on-chip memory. Second, given as input a large design, TAPA-CS automatically partitions the design to map to multiple FPGAs, while ensuring congestion control, resource balancing, and overlapping of communication and computation. Third, TAPA-CS couples coarse-grained floor-planning with interconnect pipelining at the inter- and intra-FPGA levels to ensure high frequency. FPGAs in our multi-FPGA testbed communicate through a high-speed 100Gbps Ethernet infrastructure. We have evaluated the performance of TAPA-CS on designs, including systolic-array based CNNs, graph processing workloads such as page rank, stencil applications, and KNN. On average, the 2-, 3-, and 4-FPGA designs are 2.1, 3.2, and 4.4 faster than the single FPGA baselines generated through Vitis HLS. TAPA-CS also achieves a frequency improvement between 11",
        "keywords": "",
        "released": 2024,
        "link": "https://doi.org/10.1145/3620666.3651347"
    },
    {
        "title": "Pythonpad: Server-free python hands-on exercise for online programming classes",
        "abstract": "We propose Pythonpad, an open-source JavaScript library that supports web-based Python programming exercises. Unlike other standalone web-based programming tools, Pythonpad can be easily integrated into other websites. Although it runs learners’ Python code in client-side web browsers, Pythonpad supports a file system, building and importing external modules, and many essential built-in Python libraries to teach basic programming concepts in CS1 classes.",
        "keywords": "scalable education; programming education; interactive learning",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3439572"
    },
    {
        "title": "FRED: A hosted data flow platform for the IoT",
        "abstract": "IoT developers need to integrate a variety of protocols, backend components and services; they often need to pre and post-process data as well as react to changes in the real world. Data flow programming tools have been introduced in a number of related domains to provide a flexible, but easy to use visual programming environment for rapid development. The open source Node-RED system provides such a tool for IoT applications, but is limited to executing a single flow file in a single thread. In this paper we describe the design of our system called the Front-End for Node-RED (FRED) that manages multiple instances of Node-RED for logged in users, allowing Node-RED to be used as a cloud-hosted data flow mashup tool for the IoT. We present some examples of how some of our 1800+ users are using FRED for IoT mashups, and some of the challenged we faced in implementing the FRED system.",
        "keywords": "Node-RED; IoT Mashups; Internet of Things; Data Flow Programming",
        "released": 2016,
        "link": "https://doi.org/10.1145/3007203.3007214"
    },
    {
        "title": "JavaWIDE (wiki integrated development environment: Redesigning CS1 distance education labs",
        "abstract": "Over the past decade, applications have been moving from the desktop into the cloud. After extensive searching, only one integrated development environments (IDE) has emerged that works in cloud computing. The Java Wiki Integrated Development Environment (JavaWIDE) is the new online IDEs, and it is designed to be simple enough for novice programmers to use. The emergence of this tool was the key design element into redesigning CS1 Labs for a distance education course without losing the necessary functionality of a face-to-face instructor.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2379703.2379730"
    },
    {
        "title": "A web-based IDE for teaching with any language (abstract only)",
        "abstract": "This workshop introduces participants to CS50 IDE (cs50.io), a web-based integrated development environment based on Amazon’s Cloud9 (c9.io). Not only does the IDE enable students to work on programming projects within a browser, without need for local downloads or installations, it also provides students with an integrated terminal window and full sudo privileges. Underneath the hood is a Docker \"container\" that allows students to experiment with the underlying Ubuntu Linux OS, installing and configuring software at will, adapting it to their particular projects’ needs. The IDE supports any compiler, interpreter, or other software that can be installed via a Linux command-line, while the IDE itself provides a fully-featured text editor for text files and source code that reside on the underlying instance. The Cloud9 GUI is fully extensible through a plugin system and is leveraged by CS50 IDE to provide additional functionality for students. Among the additional features implemented through this mechanism are a GUI-based file submission system, an optional \"less comfortable\" mode that simplifies the GUI to provide a scaffolded experience for students new to programming, and a GUI front end for the GNU Project Debugger, a CLI debugger for many languages, including C. This workshop will highlight useful features of the IDE in the context of classrooms (including the collaborative nature of a workspace to allow pair programming or provide alternative one-on-one instruction), provide tips for writing or adapting assignments based on its architecture, and introduce developing plugins for full customization.",
        "keywords": "linux; docker; debugger; cloud9; cloud-based IDE; IDE; GDB; CS50",
        "released": 2017,
        "link": "https://doi.org/10.1145/3017680.3017839"
    },
    {
        "title": "Towards web collaborative modelling for the user requirements notation using eclipse che and theia IDE",
        "abstract": "Collaborative modelling has become a necessity when developing a complex system or in a team of modellers with a diverse set of expertise. Textual notations have a long history in software engineering because of their fast editing style, simple usage, and scalability. Therefore, we propose a novel collaborative modelling framework for the graphical User Requirements Notation (URN) which we call tColab. It uses the text-based TGRL (Textual Goal-oriented Requirement Language) to build URN goal models and then automatically generates corresponding graphical models. This framework is based on the architecture of Eclipse Che and Theia. On one side, Theia provides support for LSP (Language Server Protocol) so that textual models can be built and their corresponding graphical models can be generated in a browser IDE (Integrated Development Environment). On the other hand, Eclipse Che adds support for collaboration where multiple modellers can contribute to building the textual models in an online collaborative manner. This initiative aims to replace the jUCMNAV tool, which is the most comprehensive URN modelling tool to date but only supports a single user.",
        "keywords": "user requirements notation; theia; sprotty; jUCMNav; eclipse che; URN; TURN; TGRL; LSP; ELK",
        "released": 2019,
        "link": "https://doi.org/10.1109/MiSE.2019.00010"
    },
    {
        "title": "Example-centric programming: Integrating web search into the development environment",
        "abstract": "The ready availability of online source-code examples has fundamentally changed programming practices. However, current search tools are not designed to assist with programming tasks and are wholly separate from editing tools. This paper proposes that embedding a task-specific search engine in the development environment can significantly reduce the cost of finding information and thus enable programmers to write better code more easily. This paper describes the design, implementation, and evaluation of Blueprint, a Web search interface integrated into the Adobe Flex Builder development environment that helps users locate example code. Blueprint automatically augments queries with code context, presents a code-centric view of search results, embeds the search experience into the editor, and retains a link between copied code and its source. A comparative laboratory study found that Blueprint enables participants to write significantly better code and find example code significantly faster than with a standard Web browser. Analysis of three months of usage logs with 2,024 users suggests that task-specific search interfaces can significantly change how and when people search the Web.",
        "keywords": "example-centric development",
        "released": 2010,
        "link": "https://doi.org/10.1145/1753326.1753402"
    },
    {
        "title": "Isabelle/cloud: Delivering isabelle/HOL as a cloud IDE for theorem proving",
        "abstract": "As online coding technology advances, various related products are emerging, but we observe that there are not many examples of introducing online coding into the field of theorem proving. We introduce Isabelle/Cloud, an online coding platform and user environment for the Isabelle theorem proving assistant. The primary objective of Isabelle/Cloud is to cloudify Isabelle using online coding technology, thereby addressing the issue of loading large projects. Leveraging the understanding of the Isabelle architecture, we have modified, replaced, and added some modules, encapsulated the Isabelle environment using containers, and developed the front-end and back-end. As a cloud platform, Isabelle/Cloud enables users to create a complete Isabelle environment with different versions that are isolated from each other, while providing basic cloud coding and theorem proving services. The current version integrates most of the popular Isabelle libraries with excellent tutorials and cases, enabling users to directly create projects from the tutorial code for practical exercises. Evaluation of the platform shows that Isabelle/Cloud performs better when dealing with large projects. The new platform opens up new possibilities for interaction and presentation, and it is currently in use.",
        "keywords": "cloud applications; Isabelle; Cloud-based IDEs",
        "released": 2023,
        "link": "https://doi.org/10.1145/3609437.3609460"
    },
    {
        "title": "IDE support for cloud-based static analyses",
        "abstract": "Integrating static analyses into continuous integration (CI) or continuous delivery (CD) has become the best practice for assuring code quality and security. Static Application Security Testing (SAST) tools fit well into CI/CD, because CI/CD allows time for deep static analyses on large code bases and prevents vulnerabilities in the early stages of the development lifecycle. In CI/CD, the SAST tools usually run in the cloud and provide findings via a web interface. Recent studies show that developers prefer seeing the findings of these tools directly in their IDEs. Most tools with IDE integration run lightweight static analyses and can give feedback at coding time, but SAST tools used in CI/CD take longer to run and usually are not able to do so. Can developers interact directly with a cloud-based SAST tool that is typically used in CI/CD through their IDE? We investigated if such a mechanism can integrate cloud-based SAST tools better into a developers’ workflow than web-based solutions. We interviewed developers to understand their expectations from an IDE solution. Guided by these interviews, we implemented an IDE prototype for an existing cloud-based SAST tool. With a usability test using this prototype, we found that the IDE solution promoted more frequent tool interactions. In particular, developers performed code scans three times more often. This indicates better integration of the cloud-based SAST tool into developers’ workflow. Furthermore, while our study did not show statistically significant improvement on developers’ code-fixing performance, it did show a promising reduction in time for fixing vulnerable code.",
        "keywords": "static analysis; security testing; cloud service; SAST tools; IDE integration",
        "released": 2021,
        "link": "https://doi.org/10.1145/3468264.3468535"
    },
    {
        "title": "Introduction to alexa programming",
        "abstract": "In this one-hour tutorial, the participants will be introduced to the Alexa programming environment, and learn how to create an Alexa skill. Specifically, this tutorial is designed for the participants who have never programmed any Alexa skills before. The outline of the tutorial is as follows:(0) Prior to coming to the tutorial, the participants are encouraged to sign up for an account in Amazon Developer Services [1], and another account in Amazon Web Services [2] so that the tutorial is primarily designated for learning the actual content.(1) General introduction to Alexa programming environment.(2) General introduction to Alexa related devices.(3) Demonstration of Alexa skills.(4) Build an Alexa skill.(5) Demonstration of additional Alexa skills.(6) Discussion on Alexa programming resources, experience sharing, and Q&amp;A.",
        "keywords": "",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3417608.3417620"
    },
    {
        "title": "JavaWIDE: Innovation in an online IDE",
        "abstract": "Over the past decade applications have been moving from the desktop into the cloud. Only relatively recently have integrated development environments begun emerging in cloud computing. The Java Wiki Integrated Development Environment (JavaWIDE) is one of these new online IDEs, and it is designed to be simple enough for novice programmers to use. JavaWIDE is free and provides anyone the capability to create, edit and run programs anytime, anywhere, all from within a web browser – no specialized software required. JavaWIDE promotes collaboration, integrates well with social networking sites, and includes novel features such as concurrent editing support, a common code base for all users, revision history explorer, automatic posting of programs as applets, annotated and hyperlinked source code, an integrated Java API and many others.",
        "keywords": "",
        "released": 2010,
        "link": "https://dl.acm.org/doi/10.5555/1734797.1734799"
    },
    {
        "title": "JavaWIDE: Innovation in an online IDE: Tutorial presentation",
        "abstract": "Over the past decade applications have been moving from the desktop into the cloud. Only relatively recently have integrated development environments begun emerging in cloud computing. The Java Wiki Integrated Development Environment (JavaWIDE) is one of these new online IDEs, and it is designed to be simple enough for novice programmers to use. JavaWIDE is free and provides anyone the capability to create, edit and run programs anytime, anywhere, all from within a web browser – no specialized software required. JavaWIDE promotes collaboration, integrates well with social networking sites, and includes novel features such as concurrent editing support (multiple people can edit the same code at the same time), a common code base for all users, revision history explorer, automatic posting of programs as applets, hyperlinked source, an integrated Java API and many others.",
        "keywords": "",
        "released": 2010,
        "link": "https://dl.acm.org/doi/10.5555/1858583.1858622"
    },
    {
        "title": "Block-based programming for two-armed robots: A comparative study",
        "abstract": "Programming industrial robots is difficult and expensive. Although recent work has made substantial progress in making it accessible to a wider range of users, it is often limited to simple programs and its usability remains untested in practice. In this article, we introduce Duplo, a block-based programming environment that allows end-users to program two-armed robots and solve tasks that require coordination. Duplo positions the program for each arm side-by-side, using the spatial relationship between blocks from each program to represent parallelism in a way that end-users can easily understand. This design was proposed by previous work, but not implemented or evaluated in a realistic programming setting. We performed a randomized experiment with 52 participants that evaluated Duplo on a complex programming task that contained several sub-tasks. We compared Duplo with RobotStudio Online YuMi, a commercial solution, and found that Duplo allowed participants to solve the same task faster and with greater success. By analyzing the information collected during our user study, we further identified factors that explain this performance difference, as well as remaining barriers, such as debugging issues and difficulties in interacting with the robot. This work represents another step towards allowing a wider audience of non-professionals to program, which might enable the broader deployment of robotics.",
        "keywords": "two-armed; robots; end-users; block-based; programming",
        "released": 2024,
        "link": "https://doi.org/10.1145/3597503.3623329"
    },
    {
        "title": "NxtUnit: Automated unit test generation for go",
        "abstract": "Automated test generation has been extensively studied for dynamically compiled or typed programming languages like Java and Python. However, Go, a popular statically compiled and typed programming language for server application development, has received limited support from existing tools. To address this gap, we present NxtUnit, an automatic unit test generation tool for Go that uses random testing and is well-suited for microservice architecture. NxtUnit employs a random approach to generate unit tests quickly, making it ideal for smoke testing and providing quick quality feedback. It comes with three types of interfaces: an integrated development environment (IDE) plugin, a command-line interface (CLI), and a browser-based platform. The plugin and CLI tool allow engineers to write unit tests more efficiently, while the platform provides unit test visualization and asynchronous unit test generation. We evaluated NxtUnit by generating unit tests for 13 open-source repositories and 500 ByteDance in-house repositories, resulting in a code coverage of 20.74",
        "keywords": "Go; Automated Test Generation",
        "released": 2023,
        "link": "https://doi.org/10.1145/3593434.3593443"
    },
    {
        "title": "Design and development of bit arrow: A web-based programming learning environment",
        "abstract": "In Japan, all high school students will study programming in next teaching guidelines. It is important to use suitable environment or tool for programming education. Some current textbooks show programs written in JavaScript and instruct students to use text editor and browser as development environment. But such environment has some problems; it requires students to manage multiple applications, to find errors with little information and to type long statements. We developed \"Bit Arrow\", an online programming environment. The environment helps students to find errors. Also the environment provides API to write statements shortly. In this report, we describe design and evaluation of Bit Arrow from students’ log data.",
        "keywords": "web-based environment; programming education; education support; Javascript",
        "released": 2018,
        "link": "https://doi.org/10.1145/3290511.3290525"
    },
    {
        "title": "FQN inference in partial code by prompt-tuned language model of code",
        "abstract": "Partial code usually involves non-fully-qualified type names (non-FQNs) and undeclared receiving objects. Resolving the FQNs of these non-FQN types and undeclared receiving objects (referred to as type inference) is the prerequisite to effective search and reuse of partial code. Existing dictionary-lookup based methods build a symbolic knowledge base of API names and code contexts, which involve significant compilation overhead and are sensitive to unseen API names and code context variations. In this article, we propose using a prompt-tuned code masked language model (MLM) as a neural knowledge base for type inference, called POME, which is lightweight and has minimal requirements on code compilation. Unlike the existing symbol name and context matching for type inference, POME infers the FQNs syntax and usage knowledge encapsulated in prompt-tuned code MLM through a colze-style fill-in-blank strategy. POME is integrated as a plug-in into web and integrated development environments (IDE) to assist developers in inferring FQNs in the real world. We systematically evaluate POME on a large amount of source code from GitHub and Stack Overflow, and explore its generalization and hybrid capability. The results validate the effectiveness of the POME design and its applicability for partial code type inference, and they can be easily extended to different programming languages (PL). POME can also be used to generate a PL-hybrid type inference model for providing a one-for-all solution. As the first of its kind, our neural type inference method opens the door to many innovative ways of using partial code.",
        "keywords": "neural knowledge base; code masked language model; fully qualified names; Type inference",
        "released": 2023,
        "link": "https://doi.org/10.1145/3617174"
    },
    {
        "title": "ScratchLog: Live learning analytics for scratch",
        "abstract": "Scratch is a hugely popular block-based programming environment that is often used in educational settings, and has therefore recently also become a focus for research on programming education. Scratch provides dedicated teacher accounts that make it easy and convenient to handle lessons with school classes. However, once learners join a Scratch classroom, it is challenging to keep track of what they are doing: Both teachers and researchers may be interested in learning analytics to help them monitor students or evaluate teaching material. Researchers may also be interested in understanding how programs are created and how learners use Scratch. Neither use case is supported by Scratch itself currently. In this paper, we introduce ScratchLog, a tool that collects data from learners using Scratch. ScratchLog provides custom user management and makes it easy to set up courses and assignments. Starting from a task description and a starter project, learners transparently use Scratch while ScratchLog collects usage data, such as the history of code edits, or statistics about how the Scratch user interface was used. This data can be viewed on the ScratchLog web interface, or exported for further analysis, for example to inspect the functionality of programs using automated tests.",
        "keywords": "block-based programming; learning analytics; scratch",
        "released": 2023,
        "link": "https://doi.org/10.1145/3587102.3588836"
    },
    {
        "title": "New opportunities for extracting insights from cloud based IDEs",
        "abstract": "Traditional integrated development environments (IDEs) provide developers with robust environments for writing, testing, debugging, and deploying code. As the world becomes increasingly networked and more services are delivered via the cloud, it is only natural that the functionality of IDEs be delivered via the cloud. In addition to simplifying the provisioning and deployment of new IDE features, and making it easier to integrate with other web native tools, cloud based IDEs provide some fundamental advantages when it comes to understanding the behavior of a wide community of software developers. One of these advantages for the IDE provider is the ability to transparently monitor and analyze the real-time fine-grained actions of a large number of developers. In this paper, we explore how to leverage these transparent monitoring capabilities of cloud based IDEs to develop advanced analytics to understand developers’ behavior and infer their characteristics. We demonstrate the feasibility of this research direction with a preliminary study focusing on the way that source code files grow for different developers, development tasks, and skill levels. We then analyze the trends of source code file growth and find growth is more similar within subjects than within tasks.",
        "keywords": "fine-grained data; analytics; JazzHub; Cloud based IDE",
        "released": 2014,
        "link": "https://doi.org/10.1145/2591062.2591105"
    },
    {
        "title": "AvaFlow: Learning to design intelligent virtual agents through flow-based programming",
        "abstract": "Modern Intelligent Virtual Agents (IVAs) are gradually progressing from just voice control tools to interactive, rich, humanlike social systems. However, creating these social humanlike IVAs is usually a daunting task and may present challenges for novice programmers, given the high technical complexity of practical implementation. In this work, we present AvaFlow, a web-based educational flow-based programming tool designed to assist novice programmers with creating and deploying IVA prototypes. We also aim to expand the use of the tool beyond IVAs to teach additional CS concepts related to data-driven applications.",
        "keywords": "multimodal applications; intelligent virtual agents; flow-based programming; data-driven applications",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3439620"
    },
    {
        "title": "Programming with the cloud: Conference tutorial",
        "abstract": "While there’s a lot to learn about cloud computing, the cloud can also be used in classes as fundamental as programming courses with little change to the material being taught. The cloud can provide a uniform programming environment for students regardless of the computers they use to access it remotely. It can provide computing resources beyond what some students may have on their own computers. And there are even some cloud services that can be used to make even the simplest programming assignments more interesting.",
        "keywords": "",
        "released": 2021,
        "link": "https://dl.acm.org/doi/10.5555/3469581.3469594"
    },
    {
        "title": "A web-based IDE for teaching with any language (abstract only)",
        "abstract": "This workshop introduces participants to CS50 IDE (cs50.io), a web-based integrated development environment based on Cloud9 (c9.io). Not only does the IDE enable students to work on programming projects within a browser, without need for local downloads or installations, it also provides students with an integrated terminal window and full sudo privileges. Underneath the hood is a Docker \"container\" that allows students to experiment with the underlying Ubuntu Linux OS, installing and configuring software at will, adapting it to their particular projects’ needs. The IDE supports any compiler, interpreter, or other software that can be installed via a Linux command-line, while the IDE itself provides a fully-featured text editor for text files and source code that reside on the underlying instance. The Cloud9 GUI is fully extensible through a plugin system and is leveraged by CS50 IDE to provide additional functionality for students. Among the additional features implemented through this mechanism are a GUI-based file submission system, an optional \"less comfortable\" mode that simplifies the GUI to provide a scaffolded experience for students new to programming, and a GUI front end for the GNU Project Debugger, a CLI debugger for many languages, including C. This workshop will highlight useful features of the IDE in the context of classrooms (including the collaborative nature of a workspace to allow pair programming or provide alternative one-on-one instruction), provide tips for writing or adapting assignments based on its architecture, and introduce developing plugins for full customization.",
        "keywords": "linux; ide; gdb; docker; debugger; cs50; cloud9; cloud-based ide",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2844712"
    },
    {
        "title": "Modular and distributed IDE",
        "abstract": "Integrated Development Environments (IDEs) are indispensable companions to programming languages. They are increasingly turning towards Web-based infrastructure. The rise of a protocol such as the Language Server Protocol (LSP) that standardizes the separation between a language-agnostic IDE, and a language server that provides all language services (e.g., auto completion, compiler...) has allowed the emergence of high quality generic Web components to build the IDE part that runs in the browser. However, all language services require different computing capacities and response times to guarantee a user-friendly experience within the IDE. The monolithic distribution of all language services prevents to leverage on the available execution platforms (e.g., local platform, application server, cloud). In contrast with the current approaches that provide IDEs in the form of a monolithic client-server architecture, we explore in this paper the modularization of all language services to support their individual deployment and dynamic adaptation within an IDE. We evaluate the performance impact of the distribution of the language services across the available execution platforms on four EMF-based languages, and demonstrate the benefit of a custom distribution.",
        "keywords": "Microservice; IDE; Generative approach",
        "released": 2020,
        "link": "https://doi.org/10.1145/3426425.3426947"
    },
    {
        "title": "An online gamified learning platform for teaching cybersecurity and more",
        "abstract": "We present an online gamified learning platform for computer science and cybersecurity education. Exercises within the platform revolve around a custom game wherein students can demonstrate learned skills regarding password security, web security, traffic analysis, reverse engineering, cryptanalysis, and much more. We describe some key features that together make our platform novel, including its distributed infrastructure, game engine, integrated development environment, automated feedback system, and support for individualization. We demonstrate how these features assist in the learning process — both in theory and in practice — and report on the use of the platform in a cybersecurity course.",
        "keywords": "learning platform; gamification; distance learning; cybersecurity",
        "released": 2021,
        "link": "https://doi.org/10.1145/3450329.3476859"
    },
    {
        "title": "Supporting web-based API searches in the IDE using signatures",
        "abstract": "Developers frequently use the web to locate API examples that help them solve their programming tasks. While sites like Stack Overflow (SO) contain API examples embedded within their textual descriptions, developers cannot access this API knowledge directly. Instead they need to search for and browse results to select relevant SO posts and then read through individual posts to figure out which answers contain information about the APIs that are relevant to their task. This paper introduces an approach, called Scout, that automatically analyzes search results to extract API signature information. These signatures are used to group and rank examples and allow for a unique API-based presentation that reduces the amount of information the developer needs to consider when looking for API information on the web. This succinct representation enables Scout to be integrated fully within an IDE panel so that developers can search and view API examples without losing context on their development task. Scout also uses this integration to automatically augment queries with contextual information that tailors the developer’s queries, and ranks the results according to the developer’s needs. In an experiment with 40 developers, we found that Scout reduces the number of queries developers need to perform by 19",
        "keywords": "API signatures; code search; controlled experiment",
        "released": 2024,
        "link": "https://doi.org/10.1145/3597503.3639089"
    },
    {
        "title": "Recording and analyzing in-browser programming sessions",
        "abstract": "In this paper, we report on the analysis of a novel type of automatically recorded detailed programming session data collected on a university-level web programming course. We present a method and an implementation of collecting rich data on how students learning to program edit and execute code and explore its use in examining learners’ behavior. The data collection instrument is an in-browser Python programming environment that integrates an editor, an execution environment, and an interactive Python console and is used to deliver programming assignments with automatic feedback. Most importantly, the environment records learners’ interaction within it. We have implemented tools for viewing these traces and demonstrate their potential in learning about the programming processes of learners and of benefiting computing education research and the teaching of programming.",
        "keywords": "web based programming environment; programming session; programming assignment; computing education research; computer science education; Python",
        "released": 2013,
        "link": "https://doi.org/10.1145/2526968.2526970"
    },
    {
        "title": "An analysis of HTML and CSS syntax errors in a web development course",
        "abstract": "Many people are first exposed to code through web development, yet little is known about the barriers beginners face in these formative experiences. In this article, we describe a study of undergraduate students enrolled in an introductory web development course taken by both computing majors and general education students. Using data collected during the initial weeks of the course, we investigate the nature of the syntax errors they make when learning HTML and CSS, and how they resolve them. This is accomplished through the deployment of openHTML, a lightweight web-based code editor that logs user activity. Our analysis reveals that nearly all students made syntax errors that remained unresolved in their assessments, and that these errors continued weeks into the course. Approximately 20",
        "keywords": "computational literacy; code editors; Web development",
        "released": 2015,
        "link": "https://doi.org/10.1145/2700514"
    },
    {
        "title": "Symbolic quantum programming for supporting applications of quantum computing technologies",
        "abstract": "The goal of this paper is to deliver the overview of the current state of the art, provide experience report on developing quantum software tools, and outline the perspective for developing quantum programming tools supporting symbolic programming for the needs of quantum computing technologies. The main focus of this paper is on quantum computing technologies, as they can in the most direct way benefit from developing tools enabling the symbolic manipulation of quantum circuits and providing software tools for creating, optimizing, and testing quantum programs. We deliver a short survey of the most popular approaches in the field of quantum software development, pointing their strengths and weaknesses. This helps to formulate a list of desirable characteristics which should be included in quantum computing frameworks. Next, we describe a software architecture and its preliminary implementation supporting the development of quantum programs using symbolic approach, encouraging the functional programming paradigm, and, at the same, time enabling the integration with high-performance and cloud computing. The described software consists of several packages developed to address different needs, but nevertheless sharing common design concepts. We also outline how the presented approach could be used in tasks in quantum software engineering: quantum software testing and quantum circuit construction.",
        "keywords": "symbolic manipulation; quantum technologies; quantum computing; functional programming; computer algebra",
        "released": 2023,
        "link": "https://doi.org/10.1145/3594671.3594688"
    },
    {
        "title": "Comparison of three programming error measures for explaining variability in CS1 grades",
        "abstract": "Programming courses can be challenging for first year university students, especially for those without prior coding experience. Students initially struggle with code syntax, but as more advanced topics are introduced across a semester, the difficulty in learning to program shifts to learning computational thinking (e.g., debugging strategies). This study examined the relationships between students’ rate of programming errors and their grades on two exams. Using an online integrated development environment, data were collected from 280 students in a Java programming course. The course had two parts. The first focused on introductory procedural programming and culminated with exam 1, while the second part covered more complex topics and object-oriented programming and ended with exam 2. To measure students’ programming abilities, 51095 code snapshots were collected from students while they completed assignments that were autograded based on unit tests. Compiler and runtime errors were extracted from the snapshots, and three measures - Error Count, Error Quotient and Repeated Error Density - were explored to identify the best measure explaining variability in exam grades. Models utilizing Error Quotient outperformed the models using the other two measures, in terms of the explained variability in grades and Bayesian Information Criterion. Compiler errors were significant predictors of exam 1 grades but not exam 2 grades; only runtime errors significantly predicted exam 2 grades. The findings indicate that leveraging Error Quotient with multiple error types (compiler and runtime) may be a better measure of students’ introductory programming abilities, though still not explaining most of the observed variability.",
        "keywords": "computer science education; introduction to programming; introductory programming; novice programming; programming education",
        "released": 2024,
        "link": "https://doi.org/10.1145/3649217.3653563"
    },
    {
        "title": "ViennaTalk and assertch: Building lightweight formal methods environments on pharo 4",
        "abstract": "It is possible to make Integrated Development Environments supporting formal methods that can be as flexible as the support for dynamic programming languages. This paper contributes with a demonstration employing different support environments for the Vienna Development Method Specification Language (VDM-SL) and design by contract for visual programming language. This includes ViennaTalk developed on top of Pharo 4 providing Smalltalk-styled LIVE browsers, VDM-SL interpreters, Smalltalk code generators, UI prototyping environments and a prototype Web API server to enable rigorous and flexible modeling during exploratory phases of software development. ViennaTalk uses the Slot mechanism in Pharo to test invariant assertions on instance variables in Smalltalk objects generated from VDM-SL specifications. In addition, we present a plugin named Assertch for Phratch, a scratch-clone visual programming environment on top of Pharo 4, that provides assertion blocks for designing and debugging a series of blocks.Both ViennaTalk and Assertch combine flexible live modeling or coding while still supporting rigorous checking. ViennaTalk has been evaluated by experienced professional engineers of VDM-SL while Assertch has been evaluated by undergraduate students of computer science. ViennaTalk and Assertch both demonstrate that Pharo and its contemporary features support rigorous modeling in formal specification languages as well as flexible prototyping in Smalltalk.",
        "keywords": "Validation; Specification animation; Live environment; Lightweight formal methods",
        "released": 2016,
        "link": "https://doi.org/10.1145/2991041.2991045"
    },
    {
        "title": "Programming with the cloud",
        "abstract": "While there’s a lot to learn about cloud computing, the cloud can also be used in classes as fundamental as programming courses with little change to the material being taught. The cloud can provide a uniform programming environment for students regardless of the computers they use to access it remotely. It can provide computing resources beyond what some students may have on their own computers. And there are even some cloud services that can be used to make even the simplest programming assignments more interesting.",
        "keywords": "",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3447080.3447082"
    },
    {
        "title": "JavaWIDE: Innovation in an online IDE: Tutorial presentation",
        "abstract": "Over the past decade applications have been moving from the desktop into the cloud. Only relatively recently have integrated development environments begun emerging in cloud computing. The Java Wiki Integrated Development Environment (JavaWIDE) is one of these new online IDEs, and it is designed to be simple enough for novice programmers to use. JavaWIDE is free and provides anyone the capability to create, edit and run programs anytime, anywhere, all from within a web browser – no specialized software required. JavaWIDE promotes collaboration, integrates well with social networking sites, and includes novel features such as concurrent editing support, a common code base for all users, revision history explorer, automatic posting of programs as applets, annotated and hyperlinked source code, an integrated Java API and many others. This workshop is presented by the developer of JavaWIDE Jam Jenkins, by Evelyn Brannock who has used JavaWIDE in the classroom, and by Sonal Dekhane who has surveyed students about their perceptions of using JavaWIDE.",
        "keywords": "",
        "released": 2010,
        "link": "https://dl.acm.org/doi/10.5555/1747137.1747155"
    },
    {
        "title": "Embedding executable code in slides for introductory programming: The case of interactive code playgrounds",
        "abstract": "Setting up development environments may be a complex hurdle for students who approach coding for the first time, and standardising environments among students may be an even greater challenge for teachers. Researchers and teachers tried to mitigate this issue with several solutions, all with different trade-offs, which may exclude students with limited internet access, low-powered devices, or lower computer proficiency. In this demo, we propose Interactive Code Playgrounds (ICPs), web pages displayed as slides that include a front-end component enabling code execution and code output display. This architecture simplifies the installation procedure, as students need only a web browser, and gives ICPs the chance to be a more long-lasting technology, as they have minimal external dependencies. As web pages, ICPs can be distributed as links or shared as single files, re-creating the user experience of PDF slide decks. Additional benefits of ICPs include a uniform development environment improved accessibility compared to PDFs due to HTML’s underlying tree structure, the inclusion of semantic tags, and text captions.",
        "keywords": "accessibility; front-end web technologies; introductory programming; slideshows",
        "released": 2024,
        "link": "https://doi.org/10.1145/3626253.3635426"
    },
    {
        "title": "Small-step live programming by example",
        "abstract": "Live programming is a paradigm in which the programming environment continually displays runtime values. Program synthesis is a technique that can generate programs or program snippets from examples. deltextThis paper presents a new programming paradigm called Synthesis-Aided Live Programming that combines these two prior ideas in a synergistic way. When using Synthesis-Aided Live Programming, programmers can change the runtime values displayed by the live addtextPrevious works that combine the two have taken a holistic approach to the way examples describe the behavior of functions and programs. This paper presents a new programming paradigm called Small-Step Live Programming by Example that lets the user apply Programming by Example locally. When using Small-Step Live Programming by Example, programmers can change the runtime values displayed by the live visualization to generate local program snippets.",
        "keywords": "program synthesis; live programming",
        "released": 2020,
        "link": "https://doi.org/10.1145/3379337.3415869"
    },
    {
        "title": "Novel data and processing approaches for the development of hyper-distributed applications",
        "abstract": "Although data is mostly collected in IoT devices, 80",
        "keywords": "",
        "released": 2023,
        "link": "https://doi.org/10.1145/3587135.3594557"
    },
    {
        "title": "Nteract: A desktop-based tool for notebooks",
        "abstract": "Writing source code for programs with lightweight text editors or fully featured integrated development environments is considered the main method of programming. Notebooks, however, are an extremely practical tool. In contrast to IDEs, projects are set up more easily and they allow for running programs in a read-eval-print loop (REPL) environment. The Jupyter Notebooks Quick Start Guide [1] describes notebook documents as \"… both human-readable documents containing the analysis description and the results (figures, tables, etc..) as well as executable documents which can be run to perform data analysis.\" Basically, markdown text can be mixed with program source code in a sequence of sections, each dedicated to either programming or description and documentation. Source code sections can be executed and the output is appended to the section, even formatted in the form of graphs, diagrams, or tables.REPL and notebook based environments have proven to be useful in many scenarios including when exploring new libraries and frameworks, to prototype code, or as an educational tool to create interactive lecture material. A prominent example is Jupyter, which is the highly successful project behind Jupyter Notebooks and the recent JupyterLab, i.e. web-based systems to run and share notebooks that contain code, equations, data visualizations, and data exploration and narrative text.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1145/3548562.3548569"
    },
    {
        "title": "The software heritage filesystem (SwhFS): Integrating source code archival with development",
        "abstract": "We introduce the Software Heritage filesystem (SwhFS), a user-space filesystem that integrates large-scale open source software archival with development workflows. SwhFS provides a POSIX filesystem view of Software Heritage, the largest public archive of software source code and version control system (VCS) development history.Using SwhFS, developers can quickly \"checkout\" any of the 2 billion commits archived by Software Heritage, even after they disappear from their previous known location and without incurring the performance cost of repository cloning. SwhFS works across unrelated repositories and different VCS technologies. Other source code artifacts archived by Software Heritage—individual source code files and trees, releases, and branches—can also be accessed using common programming tools and custom scripts, as if they were locally available.A screencast of SwhFS is available online at dx.doi.org/10.5281/zenodo.4531411.",
        "keywords": "version control system; source code; open source; filesystem; digital preservation; digital libraries; FUSE",
        "released": 2021,
        "link": "https://doi.org/10.1109/ICSE-Companion52605.2021.00032"
    },
    {
        "title": "Anvil - system architecture and experiences from deployment and early user operations",
        "abstract": "Anvil is a new XSEDE advanced capacity computational resource funded by NSF. Designed with a systematic strategy to meet the ever increasing and diversifying research needs for advanced computational capacity, Anvil integrates a large capacity high-performance computing (HPC) system with a comprehensive ecosystem of software, access interfaces, programming environments, and composable services in a seamless environment to support a broad range of current and future science and engineering applications of the nation’s research community. Anchored by a 1000-node CPU cluster featuring the latest AMD EPYC 3rd generation (Milan) processors, along with a set of 1TB large memory and NVIDIA A100 GPU nodes, Anvil integrates a multi-tier storage system, a Kubernetes composable subsystem, and a pathway to Azure commercial cloud to support a variety of workflows and storage needs. Anvil was successfully deployed and integrated with XSEDE during the world-wide COVID-19 pandemic. Entering production operation in February 2022, Anvil will serve the nation’s science and engineering research community for five years. This paper describes the Anvil system and services, including its various components and subsystems, user facing features, and shares the Anvil team’s experience through its early user access program from November 2021 through January 2022.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1145/3491418.3530766"
    },
    {
        "title": "Community-driven course and tool development for CS1",
        "abstract": "In 2012, the authors took responsibility for a CS1 course with 45 students. This experience report reviews the subsequent 10-year learning process of engaging undergraduate students to facilitate small-group teaching and to design and develop an online learning environment to conduct what became our university’s flagship CS1 course, currently enrolling 749 students. The course inherited an emphasis on small-group learning from its role model, MIT’s 6.001. The size of the learning groups is limited to eight students per group, which currently requires a team of 105 student facilitators. The resulting need for student engagement and scaling motivated the development of a new web-based programming environment and assessment management system custom-made for the course. The system was conceived, designed, and implemented by students of the course, which provided the glue for building a sustainable and scalable community of learners, educators, and student software developers. This experience report describes the pedagogic approach, the course structure, and software system to accommodate the needs of this community. A qualitative and quantitative analysis of the impact of the course over the last four years provides evidence for its efficacy. We hope that this report serves as inspiration for similar large-scale pedagogic efforts that bring learners, educators, and student developers together to form sustainable and scalable learning communities.",
        "keywords": "introductory programming; learning management system for programming; structure and interpretation of computer programs",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545945.3569740"
    },
    {
        "title": "Runbox: Serverless interactive computing platform",
        "abstract": "Serverless computing revolutionizes cloud software by eliminating the need to manage the underlying infrastructure, while providing efficient scaling, performance and security isolation as well as usage metering.The goal of Runboxes is to bring the benefits of serverless computing to Interactive Computing, involving ad-hoc, stateful, resource-intensive tasks, whose resource demand is directly affected by the observed user behavior. We evaluate Runboxes in the context of cost-efficient hosting of sandbox programming environments for Computer Science students.",
        "keywords": "serverless; runbox; kubernetes; interactive computing",
        "released": 2019,
        "link": "https://doi.org/10.1145/3319647.3325852"
    },
    {
        "title": "PWCT: Visual language for IoT and cloud computing applications and systems",
        "abstract": "Developing IoT, Data Computing and Cloud Computing software requires different programming skills and different programming languages. This cause a problem for many companies and researchers that need to hires many programmers to develop a complete solution. The problem is related directly to the financial cost and the development time which are very important factors to many research projects. In this paper we present and propose the PWCT visual programming tool for developing IoT, Data Computing and Cloud Computing Applications and Systems without writing textual code directly. Using PWCT increase productivity and provide researchers with one visual programming tool to develop different solutions.",
        "keywords": "visual programming; knowledge representation and reasoning; internet of things; data computing; cloud computing",
        "released": 2017,
        "link": "https://doi.org/10.1145/3018896.3056782"
    },
    {
        "title": "Wiki development environments",
        "abstract": "The doctoral thesis Wiki Development Environments analyzes contribution barriers to Free, Libre and Open Source Software (FLOSS) projects. Contribution barriers exist between particular subgroups within the community around a FLOSS project. Contribution barriers include social and technical factors. The hurdles that constitute the contribution barrier to become a co-developer receives special emphasis.The doctoral thesis also describes a pattern language for maintainers of FLOSS projects. The patterns in this pattern language describe practices that lower the contribution barriers in FLOSS projects that employ the patterns. The doctoral thesis includes a novel approach that minimizes contribution barriers. This approach comprises the combination of a wiki system and an Integrated Development Environment (IDE) into a Wiki Development Environment (WikiDE). A WikiDE is a web-based code editor that allows anonymous users to edit source code and contribute it to a FLOSS project. From the pattern language perspective, a WikiDE helps to realize some of the patterns described earlier and amplifies their effect.Editing source code of software differs from editing text in a natural language. WikiDE realizations must take these differences into account. This imposes challenges for WikiDEs realization that exceed the requirements of IDEs and wiki systems for natural language text.",
        "keywords": "software engineering; software development environment; open source; contribution barrier; Wikis; WikiDE; IDE; FLOSS",
        "released": 2013,
        "link": "https://doi.org/10.1145/2491055.2491088"
    },
    {
        "title": "Architecture and design of a cloud-based visual simulation environment",
        "abstract": "Doing things \"in the cloud\" has become ubiquitous and the \"cloud\" has become a rich platform for the use of modeling and simulation (M&amp;S) anywhere and anytime to provide solutions to complex problems. Creation of an Integrated Development Environment (IDE) for building and executing visual M&amp;S applications \"in the cloud\" poses significant technical challenges. This paper presents an architecture and a design of a cloud-based visual M&amp;S IDE for the example problem domain \"traffic networks\". The IDE consists of integrated software tools that provide computer-aided assistance in the composition and visualization of simulation models under a web browser on a client computer while the simulation model is being executed on a server computer. Based on a client-server architecture enabling distributed multitiered M&amp;S development, the design employs an asynchronous visualization protocol with efficient resource utilization. The architecture and design can assist researchers and developers to create other cloud-based visual M&amp;S IDEs.",
        "keywords": "",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3400397.3400621"
    },
    {
        "title": "CMU CS academy: A browser-based, text-based introduction to programming through graphics and animations in python",
        "abstract": "There are a great number of resources to introduce CS in the K-8 space, most notably Scratch and code.org. There are two AP CS courses at the High School level, but there are not nearly as many resources to bridge the gap between the engaging, fun, K-8 resources and those AP courses. And what is available tends to lack continuity and rigor. It is generally accepted that coding and creativity go hand-in-hand. This is apparent in the learning opportunities in the K-8 space but as programming courses get more challenging, they tend to lose the creative aspect. In this demo, attendees will be able to unpack how students can learn to code as they learn to create, They will also discover resources that support creativity while introducing students to text-based programming through coding in Python with CMU Graphics. The goal of this session is to provide teachers with an opportunity to learn how they can bridge the gap from block-based coding experiences to the AP courses with a text-based, year-long, introduction to programming course whose only recommended prerequisite is algebra readiness. We will be using CMU CS Academy which teaches students to code in Python through a browser-based graphics and animation framework that provides instant, automated feedback and has a strong focus on creativity and problem-solving.",
        "keywords": "python-programming; free-browser-based-programming-environment; auto-graded-graphics-and-animations",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3372541"
    },
    {
        "title": "Multi-level access to information systems by QR codes for wearable devices: Article was prepared under scientific grant project of batumi shota rustaveli state university",
        "abstract": "The scientific project \"Multi-level access of information systems by QR codes for wearable devices\" was carried out within the framework of the scientific grant project of Batumi State University. The idea is practically implemented and discussed in the example of a higher educational institution (university). Various areas of business and state organizations where successful practical implementation of the obtained results is possible are also mentioned.Based on scientific research, an original software product was created, by means of which only one static QR code placed on different objects (in our research mode, BSU auditorium) allows people with different statuses to access different data, in our case, employees and students. At the same time, the QR code assigned to the room remains unchanged even if the processes in the room change, which excludes frequent changes in the graphic image (QR code) placed on the room(object). The mentioned changes will be implemented only in electronic form on the web page where this information is posted and the user will receive only the updated information. For another example, the method can be used to digitize cities, including tourist facilities, restaurants, cafes, banks, etc., to provide different information about users of different access levels (loyalty programs, etc.) through a single QR code. The field of the practical application of the system can be quite wide in terms of its simplicity and technological practicality. Research methodology is based on modern achievements of computer technology, Internet technologies, and programming tools. These technologies are widely used in the research process and in one of the results of the research - the software product.",
        "keywords": "",
        "released": 2023,
        "link": "https://doi.org/10.1145/3606305.3606330"
    },
    {
        "title": "Using a visual programming environment and custom robots to learn c programming and k-12 STEM concepts",
        "abstract": "This paper presents a robot-Visual Programming Environment (VPE) interface that can support K-12 students to learn science, technology, engineering, and math (STEM) concepts. Specifically, we employ Google’s Blockly VPE to construct a blocks-based visual programming tool to facilitate easy programming of and interaction with physical robots. Through a careful and intentional integration of the Blockly VPE and physical robots, we illustrate that many K-12 level STEM concepts, which are traditionally treated through lectures and problem-solving, can be explored in a hands-on manner. The use of Blockly VPE obviates the need for prior experience with computer programming or familiarity with advanced programming concepts. Moreover, it permits students to learn various programming constructs, sequentially, starting from the fundamentals and gradually progressing to advanced concepts. The web-based Blockly VPE provides an interface that allows the user to browse through a block library and construct a block code for which a corresponding C program is automatically generated. The default web-based Blockly interface has been modified to permit the user to edit the resulting C program or to create an entirely new C program. Moreover, the Blockly VPE allows the user to wirelessly upload the C program to a Linux server running on a Raspberry Pi computer hosted on the robot. The Raspberry Pi compiles the received C program and serially transfers corresponding instructions to the robot’s embedded hardware. The efficacy of the proposed robot-VPE interface is examined through students’ experiences in conducting several illustrative robot-based STEM learning activities. The results of content quizzes and surveys show gains in students’ understanding of STEM concepts after participation in robotics activities with the VPE interface.",
        "keywords": "Visual Programming; Robotics; Puppet Robot; K-12 STEM Education; Interface; Blockly",
        "released": 2016,
        "link": "https://doi.org/10.1145/3003397.3003403"
    },
    {
        "title": "Shared virtual worlds for accessible classroom robotics",
        "abstract": "RoboScape Online is a robotics simulation platform designed to reduce the barriers to entry for teachers to use robots as an educational tool in their classrooms. With simulated robots in a shared virtual 3D environment, students can be provided with \"hardware\" at no cost, no maintenance required, and free for them to \"take home\" while simultaneously collaborating with peers anywhere in the world. The environment supports remote, hybrid and in- person learning equally well. Programming support is provided through NetsBlox, a block-based programming environment, creating a novice-friendly experience while providing strong distributed computing and collaboration tools. Existing curricula focused on computational thinking and cybersecurity in NetsBlox have been used with physical robots for several years. These activities have been recreated with virtual robots, and the exact same code works in the simulated environment as well. However, virtual robots and their environments aren’t limited to only the same experiences as before. New robots can be designed equipped with sensors and actuators previously infeasible for classroom use, giving students more interesting \"missions\" to work on solutions to. The software is open source, with free servers available, and tools are also provided to create new scenarios and environments. Handouts explaining the basics of the RoboScape environment will be provided. A computer with a web browser is required to use the software.",
        "keywords": "k-12 computer science education; educational simulations; educational robotics",
        "released": 2022,
        "link": "https://doi.org/10.1145/3478432.3499259"
    },
    {
        "title": "Source academy: A web-based environment for learning programming with SICP",
        "abstract": "The Source Academy is a community-built immersive online environment for learning computing with the book Structure and Interpretation of Computer Programs (SICP). An interactive version of the textbook is integrated into the system, and the programming environment of the Source Academy allows learners to focus on SICP-specific sublanguages of JavaScript (Python and Scheme versions in preparation). The environment includes tools to support SICP’s mental models for computational processes and data, including a stepper that animates the substitution model of Chapter 1, a data visualizer that supports the box-and-pointer diagrams of Chapter 2, and a visualizer for the environment model of Chapter 3.The system is web-based (no software installation required) and supports dynamically loadable plugins (modules) for programming with graphics, audio, image, and video processing. An extension called Source Academy @ X provides Learning Management System features such as the management of programming assessments and their manual and automatic grading. Source Academy @ X includes gamification components such as achievements, contests, levels, and a game that offers a narrative to contextualize the assessments.The 45-minute demo provides CS educators with an overview of the Source Academy, including its tools, modules, and textbook integration, the Source Academy @ X extension for course management and a preview of Python and Scheme versions.",
        "keywords": "structure and interpretation of computer programs; learning management systems; computational thinking",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545947.3573232"
    },
    {
        "title": "Integrating cloud-based file storage and NoSQL databases with mobile app SQLite",
        "abstract": "Mobile apps typically make use of user data that needs to be persisted across multiple executions of the app. The primary data source can be stored either locally on the device or remotely in the cloud. A combination of the two approaches can be used to back up the data to a secondary source. In this tutorial we will illustrate two operational scenarios:• The primary data source located on the device, and a backup located in file storage in the cloud.• The primary data source located in the cloud, with a transient backup stored on the device when remote connectivity is unavailableThe ACM/IEEE Computer Science Curricula 2013[1] added platform-based development (PBD) as a new knowledge area to the Computer Science body of knowledge. CS2013 recommended adding web application development and applying it over a wide range of ecosystems as part of the PBD knowledge area. CS2013 acknowledged the \"increasing use of platform-specific programming environments, both at the introductory level and in upper-level electives\"[1].",
        "keywords": "",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3447065.3447066"
    },
    {
        "title": "Duplicated code pattern mining in visual programming languages",
        "abstract": "Visual Programming Languages (VPLs), coupled with the high-level abstractions that are commonplace in visual programming environments, enable users with less technical knowledge to become proficient programmers. However, the lower skill floor required by VPLs also entails that programmers are more likely to not adhere to best practices of software development, producing systems with high technical debt, and thus poor maintainability. Duplicated code is one important example of such technical debt. In fact, we observed that the amount of duplication in the OutSystems VPL code bases can reach as high as 39",
        "keywords": "visual programming; maximum satisfiability; maximum common sub-graph; duplicated code",
        "released": 2021,
        "link": "https://doi.org/10.1145/3468264.3473928"
    },
    {
        "title": "MatchingRef: Matching variable names in a reference page to help introductory CS students fix compiler errors",
        "abstract": "Debugging compiler errors is essential to programming and can be challenging for novice programmers. In introductory computer science courses, challenging errors can discourage students. One reason these errors are difficult to resolve is that most online help systems do not match a student’s code. For example, online reference pages use different variable names, identifiers, and method names compared with a student’s particular code. To utilize existing resources, students must wade through other people’s code (which is often too advanced for novices to comprehend). This is time-consuming and does not provide novices with solutions.To address this problem, we developed MatchingRef -a reference system that helps novices resolve compiler errors. It is a web-based reference guide that catalogs common Processing/Java compiler errors. MatchingRef integrates with the Processing programming environment to provide users with explanations and that match users’ particular code. It includes a list of strategies to fix each error, accompanied by one or more concrete examples. Importantly, the key feature that distinguishes MatchingRef from prior reference systems (e.g., Decaf [1], HelpMeOut [4], CodeWrite [2]) is that MatchingRef examples are all dynamically generated using variable, method, and class names from users’ programming environments.There are four guiding design principles behind MatchingRef. First is readability, which is listed as a criterion that good error messages should exhibit [5]. The description from Java documentation is usually technical and causes confusion for novice programmers. Hence, we provide explanations that are less cryptic and more familiar in wording. Second is learning by examples. Examples have been shown to be effective way to learn and fix programming errors, such as in online forum like Stack Overflow [7]. Therefore, we include examples in each suggestion so that users can have a concrete idea on how to fix the problems. Third is familiarity, a common design principle across domains [3]. MatchingRef matches elements in the fixing examples with the original code of the users. Finally, our system is intended to reduce cognitive load by customizing the pages to users’ code to show the relevant information. According to Cognitive Load Theory (CLT), humans have a finite ability to efficiently process input [6]. As MatchingRef provide users with matching error messages and matching names, their brain only needs to process useful information such as ways to fix the errors or roots of the errors. Users can avoid reading some information in the page multiple times such as variable names or class names because they are already familiar with them.We conducted a within-subjects pilot study (n = 4) to evaluate whether MatchingRef improved novices’ performance and comprehension while debugging compiler errors. Participants interacted with two designs of our system, one with matching variable names in the examples and one without this feature. Otherwise, the systems were identical. The participants were students in introductory computer science courses that use Processing. Due to the small sample size, we could not detect significant differences in task completion time. Although the conclusions we can draw are limited, we are encouraged to evaluate MatchingRef in a more formal study.",
        "keywords": "software engineering; processing development environment; introductory programming; computing education; compiler errors",
        "released": 2020,
        "link": "https://doi.org/10.1145/3372782.3408118"
    },
    {
        "title": "Web programming using the WebGPU API",
        "abstract": "Today’s web-based programming environments has become more multifaceted for accomplishing tasks that go beyond ’browsing’ web-pages. The process of developing efficient web-based programs for such a wide array of applications poses a number of challenges to the programming community. Applications possess a number of workload behaviors, ranging from control intensive (e.g., searching, sorting, and parsing) to data intensive (e.g., image processing, simulation and modeling, and data mining). Web-based applications can also be characterized as compute intensive (e.g., iterative methods, numerical methods, and financial modeling), where the overall throughput of the web application is heavily dependent on the computational efficiency of the underlying hardware. Of course, no single architecture is best for running all classes of workloads, and most applications possess a mix of the workload characteristics. For instance, control-intensive applications tend to run faster on the CPU, whereas data-intensive applications tend to run fast on massively parallel architectures (like the GPU), where the same operation is applied to multiple data items concurrently. To extend and support these various workload classes so that browser-based applications wouldn’t be hindered, a new generation of API needed to be developed (open the door for developers so that they can access the power of new hardware/technologies). One example of this, is the WebGPU API which exposes the capabilities of GPU hardware for the Web. The course is intended to help you get started with the WebGPU API while understanding both the HOW and WHY behind it works, so you can create your own solutions. This course is designed to teach you the new WebGPU API for graphics and compute techniques without any prior knowledge. All you need is some JavaScript experience and preferably an understanding of basic trigonometry. Whether you’re new to graphics and compute development or an old pro, everyone has to start somewhere. Generally, that means starting with the basics which is the focus of this course. You’ll learn through simple, easy-to-learn hands-on exercises that help you master the subject. It does this by using multiple task-based activities and discussions which complement and build upon one another.",
        "keywords": "",
        "released": 2023,
        "link": "https://doi.org/10.1145/3587423.3595543"
    },
    {
        "title": "MOCCA studio: A graphical tool for high-level programming of human-robot social interaction",
        "abstract": "In this paper, we introduce a handy and affordable solution we are developing, for education of human-robot social interaction. The solution consists of a smart device-controlled robot with a 3D printed body, a cloud-based integrated development environment that provides intuitive programming and simulation of the robot, and embedded functions enabling intelligent, natural response of the robot. The outline and architecture of the proposed system are briefly explained.",
        "keywords": "robot control architecture; human-robot social interaction; graphical programming tool",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3378680.3378817"
    },
    {
        "title": "Reflective debugging with a python web IDE",
        "abstract": "In this lightning talk, we explore the impact of adding reflective debugging to a web-based problem-solving IDE, Spinoza, that we created to support teaching programming with Python. Spinoza allows the instructor to create (or select from a library) Python problems with automatic unit tests. Each time a student attempts a new problem, the system randomly decides if reflective debugging will be required; in which case each time the student runs their code and the code does not pass the unit tests, the student will be required to classify the type of error (syntax, logic or runtime error), provide a description of the bug, and explain how they plan to fix it before they are allowed to revise and run the code again. Our main result from this pilot study is that the number of debugging steps to reach a correct solution was statistically significantly less when students were required to use reflective debugging. Our hope was that by being required to analyze each error for some problems (about one out of three), students would see the benefits and develop the habit of reflective debugging even when it was not required.",
        "keywords": "reflective debugging; novice web-based ide; learning analytics",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3439556"
    },
    {
        "title": "Demonstration of panda: A weakly supervised entity matching system",
        "abstract": "Entity matching (EM) refers to the problem of identifying tuple pairs in one or more relations that refer to the same real world entities. Supervised machine learning (ML) approaches, and deep learning based approaches in particular, typically achieve state-of-the-art matching results. However, these approaches require many labeled examples, in the form of matching and non-matching pairs, which are expensive and time-consuming to label.In this paper, we introduce Panda, a weakly supervised system specifically designed for EM. Panda uses the same labeling function abstraction as Snorkel, where labeling functions (LF) are user-provided programs that can generate large amounts of (somewhat noisy) labels quickly and cheaply, which can then be combined via a labeling model to generate accurate final predictions. To support users developing LFs for EM, Panda provides an integrated development environment (IDE) that lives in a modern browser architecture. Panda’s IDE facilitates the development, debugging, and life-cycle management of LFs in the context of EM tasks, similar to how IDEs such as Visual Studio or Eclipse excel in general-purpose programming. Panda’s IDE includes many novel features purpose-built for EM, such as smart data sampling, a builtin library of EM utility functions, automatically generated LFs, visual debugging of LFs, and finally, an EM-specific labeling model. We show in this demo that Panda IDE can greatly accelerate the development of high-quality EM solutions using weak supervision.",
        "keywords": "",
        "released": 2021,
        "link": "https://doi.org/10.14778/3476311.3476332"
    },
    {
        "title": "Towards automatic assessment of object-oriented programs",
        "abstract": "The computing education community has shown a long-time interest in how to analyze the Object-Oriented (OO) source code developed by students to provide them with useful formative tips. In this paper, we propose and evaluate an approach to analyze how students use Java and its language constructs. The approach is implemented through a cloud-based integrated development environment (IDE) and it is based on the analysis of the most common violations of the OO paradigm in the student source code. Moreover, the IDE supports the automatic generation of reports about student’s mistakes and misconceptions that can be used by instructors to improve the course design. The paper discusses the preliminary results of an experiment performed in a class of a Programming II course to investigate the effects of the provided reports in terms of coding ability (concerning the correctness of the produced code).",
        "keywords": "student assessment; polymorphism; object oriented development; inheritance; abstract data types",
        "released": 2020,
        "link": "https://doi.org/10.1145/3377812.3390907"
    },
    {
        "title": "Hands-on IoT education with mobile devices: Demo abstract",
        "abstract": "Distributed computing, computer networking, cyber-physical systems and the Internet of Things (IoT) are all around us, yet very little of the underlying concepts are being taught in introductory computer science courses in K12. Teaching IoT is especially problematic since it requires hardware with its own cost and maintenance requirements that many under-resourced schools cannot afford. However, smartphones are commonplace networked devices that boast a wide range of sensors. With the right approach, they can be used to introduce many advanced computing concepts even to novices. We have created a mobile app, PhoneIoT, which makes all available sensors accessible to the user’s computer through NetsBlox, a block-based educational programming environment specializing in networking and distributed computing. Accessing PhoneIoT uses the same simple networking primitives as other NetsBlox services, so no additional knowledge is required. PhoneIoT makes it possible to collect sensor data, build a custom graphical interface on the device and receive corresponding events, all without leaving your browser running NetsBlox. This demonstration will showcase a few simple projects such as an exercise tracking app and how to turn your phone into a game controller.",
        "keywords": "sensors; networking; internet of things; computer science education",
        "released": 2021,
        "link": "https://doi.org/10.1145/3412382.3458778"
    },
    {
        "title": "Creating and migrating chatbots with conga",
        "abstract": "Chatbots are agents that enable the interaction of users and software by means of written or spoken natural language conversation. Their use is growing, and many companies are starting to offer their services via chatbots, e.g., for booking, shopping or customer support. For this reason, many chatbot development tools have emerged, which makes choosing the most appropriate tool difficult. Moreover, there is hardly any support for migrating chatbots between tools.To alleviate these issues, we propose a model-driven engineering solution that includes: (i) a domain-specific language to model chatbots independently of the development tool; (ii) a recommender that suggests the most suitable development tool for the given chatbot requirements and model; (iii) code generators that synthesize the chatbot code for the selected tool; and (iv) parsers to extract chatbot models out of existing chatbot implementations. Our solution is supported by a web IDE called Conga that can be used for both chatbot creation and migration. A demo video is available at https://youtu.be/3sw1FDdZ7XY.",
        "keywords": "model-driven engineering; migration; domain-specific languages; chatbots",
        "released": 2021,
        "link": "https://doi.org/10.1109/ICSE-Companion52605.2021.00030"
    },
    {
        "title": "Shrinking JavaScript for CS1",
        "abstract": "In teaching and learning programming at first-year-university level, simple languages with small feature sets are preferable over industry-strength languages with extensive feature sets, to reduce the learners’ cognitive load. At the same time, there is increasing pressure to familiarise students with mainstream languages early in their learning journey, and these languages accumulate features as years go by. In response to these competing requirements, we developed Source, a collection of JavaScript sublanguages with feature sets just expressive enough to introduce first-year computer science students to the elements of computation. These languages are supported by a web-based programming environment custom-built for learning at beginner’s level, which provides transpiler, interpreter, virtual machine, and algebraic-stepper-based implementations of the languages, and includes tracing, debugging, visualization, type-inference, and smart-editor features. This paper motivates the choice of JavaScript as starting point and describes the syntax and semantics of the Source languages compared to their parent language, and their implementations in the system. We report our experiences in developing and improving the languages and implementations over a period of three years, teaching a total of 1561 computer science first-year students at a university.",
        "keywords": "teaching programming; learning tools; learning environments; JavaScript",
        "released": 2021,
        "link": "https://doi.org/10.1145/3484272.3484970"
    },
    {
        "title": "Securing bring-your-own-device (BYOD) programming exams",
        "abstract": "Traditional pen and paper exams are inadequate for modern university programming courses as they are misaligned with pedagogies and learning objectives that target practical coding ability. Unfortunately, many institutions lack the resources or space to be able to run assessments in dedicated computer labs. This has motivated the development of bring-your-own-device (BYOD) exam formats, allowing students to program in a similar environment to how they learnt, but presenting instructors with significant additional challenges in preventing plagiarism and cheating. In this paper, we describe a BYOD exam solution based on lockdown browsers, software which temporarily turns students’ laptops into secure workstations with limited system or internet access. We combine the use of this technology with a learning management system and cloud-based programming tool to facilitate conceptual and practical programming questions that can be tackled in an interactive but controlled environment. We reflect on our experience of implementing this solution for a major undergraduate programming course, highlighting our principal lesson that policies and support mechanisms are as important to consider as the technology itself.",
        "keywords": "programming exams; plagiarism prevention; lockdown browsers; learning management systems; cloud-based ides; byod exams",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3366907"
    },
    {
        "title": "The PrimeGame revolutions: A cloud-based collaborative environment for teaching introductory programming",
        "abstract": "The PrimeGame is an established mathematical programming game that has been used successfully in undergraduate computer science teaching since 2003. To meet the increasing demand for innovative programming tools in undergraduate tertiary and secondary education, we have created SoGaCo, a novel platform to deliver the PrimeGame and similar games to a wide audience via standard web browsers. SoGaCo is designed to have a very low total cost of ownership. This is achieved by enabling teachers to provision a customised collaborative development environment on commodity cloud computing infrastructure. Amongst the unique features of the platform are its social networking features and support for polyglot programming.In this paper, we describe the requirements for this system, its design and implementation. We focus on how the scalability and security challenges of an open web-based development environment are addressed. This includes a discussion of the sandboxing and verification techniques we have developed in order to safeguard server-side code execution on the Java Virtual Machine.",
        "keywords": "",
        "released": 2015,
        "link": "https://doi.org/10.1145/2811681.2811683"
    },
    {
        "title": "Kavita project: Voice programming for people with motor disabilities",
        "abstract": "Most computer programs are designed in a way that requires interaction based on finger movements and hand gestures. This type of environment, which assumes the dexterity of human hands, presents limitations for those with motor disabilities. This limitation excludes this population from learning to code and, for those who develop a musculoskeletal disorder in later stages, could jeopardize their programming careers. The objective of this research is to design a Voice User Interface (or VUI for its acronym in English) that allows the use of the user’s voice to program in an Integrated Development Environment (or IDE for its acronym in English). For this, a basic programming structure was defined using Alexa Skills, which allows the user to declare variables, print values, solve basic mathematical expressions, insert conditional expressions, and create loops. An online text editor was created using CodeMirror to run user input using the Python programming language. However, the results could not yet be evaluated since the application does not have a compiler integrated. In future work it is desired to add the compiler, and thus to be able to execute the user’s program in the online editor. The aim is to also add the ability to edit, debug and move the cursor using the Alexa Skill.",
        "keywords": "accessibility; open-source; programming languages; universal design; voice programming",
        "released": 2021,
        "link": "https://doi.org/10.1145/3441852.3476516"
    },
    {
        "title": "Neuroevolution-based generation of tests and oracles for games",
        "abstract": "Game-like programs have become increasingly popular in many software engineering domains such as mobile apps, web applications, or programming education. However, creating tests for programs that have the purpose of challenging human players is a daunting task for automatic test generators. Even if test generation succeeds in finding a relevant sequence of events to exercise a program, the randomized nature of games means that it may neither be possible to reproduce the exact program behavior underlying this sequence, nor to create test assertions checking if observed randomized game behavior is correct. To overcome these problems, we propose Neatest, a novel test generator based on the NeuroEvolution of Augmenting Topologies (NEAT) algorithm. Neatest systematically explores a program’s statements, and creates neural networks that operate the program in order to reliably reach each statement—that is, Neatest learns to play the game in a way to reliably cover different parts of the code. As the networks learn the actual game behavior, they can also serve as test oracles by evaluating how surprising the observed behavior of a program under test is compared to a supposedly correct version of the program. We evaluate this approach in the context of Scratch, an educational programming environment. Our empirical study on 25 non-trivial Scratch games demonstrates that our approach can successfully train neural networks that are not only far more resilient to random influences than traditional test suites consisting of static input sequences, but are also highly effective with an average mutation score of more than 65",
        "keywords": "Scratch; Neuroevolution; Game Testing; Automated Testing",
        "released": 2023,
        "link": "https://doi.org/10.1145/3551349.3556939"
    },
    {
        "title": "JavaScript code suggestion based on deep learning",
        "abstract": "Code suggestion system is widely used in integrated development environments (IDEs) for generating code recommendations while editing to improve program efficiency. Current most common systems focus on the settings that complete a single code unit or predict likely next single unit. In this paper, we describe a code suggestion prototype system for JavaScript based on Jupyter Notebook [1] (an IDE) to provide multiple successive code units completion. Our main work is as follows: 1. Provide a JavaScript pre-processing solution for feature extraction; 2. Apply several deep learning technologies, including LSTM [2], attention mechanism (AM) [3] and sparse point network (SPN) [4] to support system performance; 3. Design a solution for model deployment and provide post-processing methods to improve user experience. Offline model performance shows that the LSTM + SPN has achieved a 79.73",
        "keywords": "Deep learning; Code suggestion; Code completion",
        "released": 2019,
        "link": "https://doi.org/10.1145/3319921.3319922"
    },
    {
        "title": "A programming environment for multi-FPGA systems based on CyberWorkBench: An integrated design tool",
        "abstract": "This paper proposes a multi-FPGA programming environment based on NEC’s integrated design tool CyberWorkBench (CWB) for a multi-FPGA system FiC (Flow-in-Cloud). Programmers describe their program in SystemC as small modules connected with FIFO channels, then verify the operation with the behavioral simulation considering parallel execution. After the high-level synthesis (HLS) is done with CWB, modules distributed to each board are decided, and the interface module is inserted. The cycle accurate simulation is applied to ensure the operation and estimate the performance. Finally, generated Verilog HDL code for each board is implemented with Xilinx’s Vivado just like the traditional design and configuration is obtained. As an example, a simple convolutional neural network LeNet is described and implemented on a real system using the tool. Although the cycle accurate simulation takes 105.34sec, the estimated cycles are only 2.2",
        "keywords": "",
        "released": 2021,
        "link": "https://doi.org/10.1145/3468044.3468049"
    },
    {
        "title": "Web-based programming for low-cost gaming handhelds",
        "abstract": "Low-cost microcontroller boards like the BBC micro:bit are used to engage and inspire students worldwide to learn more about computing. Easy-to-use web-based programming environments and low-cost hardware allow novices to build physical computing systems with the micro:bit – systems that sense and respond to the real world. However, devices such as the micro:bit may not capture the attention of every student, as the interests of some may lie in graphic design, animation, or other areas that are not the main focus of physical computing. Video game creation offers the opportunity for students to engage with computing concepts from a different angle, while keeping open the possibilities for physical computing. To date however, there is no game creation platform that has both the same low-barrier to entry and low-cost hardware as the BBC micro:bit. We present MakeCode Arcade, a web app for creating video games for gaming handhelds, built on the same technologies as the BBC micro:bit, extended to support multiple microcontrollers and including a 2D game engine and easy-to-use sprite and music editors. We also designed a simple hardware specification that resulted in five different companies creating seven Arcade-compatible handhelds. Qualitative and quantitative evaluation demonstrates that Arcade enables a modern and fully web-based programming experience for low-cost microcontroller-based gaming handhelds.",
        "keywords": "web browser; video games; programming; gaming handhelds",
        "released": 2021,
        "link": "https://doi.org/10.1145/3472538.3472572"
    },
    {
        "title": "A penny a function: Towards cost transparent cloud programming",
        "abstract": "Understanding and managing monetary cost factors is crucial when developing cloud applications. However, the diverse range of factors influencing costs for computation, storage, and networking in cloud applications poses a challenge for developers who want to manage and minimize costs proactively. Existing tools for understanding cost factors are often detached from source code, causing opaqueness regarding the origin of costs. Moreover, existing cost models for cloud applications focus on specific factors such as compute resources and necessitate manual effort to create the models. This paper presents initial work toward a cost model based on a directed graph that allows deriving monetary cost estimations directly from code using static analysis. Leveraging the cost model, we explore visualizations embedded in a code editor that display costs close to the code causing them. This makes cost exploration an integrated part of the developer experience, thereby removing the overhead of external tooling for cost estimation of cloud applications at development time.",
        "keywords": "developer tooling; cost transparency; cost modeling; Cloud computing",
        "released": 2023,
        "link": "https://doi.org/10.1145/3623504.3623566"
    },
    {
        "title": "Detailed recordings of student programming sessions",
        "abstract": "Observation is important when we teach programming. It can help identify students that struggle, concepts that are not clearly presented during lectures, poor assignments, etc. However, as development tools become more widely available or courses move off-campus and online, we lose our ability to naturally observe students. Online programming environments provide an opportunity to record how students solve assignments and the data recorded allows for in-depth analysis. For example, file activities, mouse movements, text-selections, and text caret movements provide a lot of information on when a programmer collects information and what task is currently worked on. We developed CSQUIZ to allow us to observe students on our online courses through data analysis. Based on our experience with the tool in a course, we find recorded sessions a sufficient replacement for natural observations.",
        "keywords": "programming environments; programming behavior; programming assignment; measurement",
        "released": 2015,
        "link": "https://doi.org/10.1145/2729094.2754859"
    },
    {
        "title": "PROMOTO ’14: Proceedings of the 2nd workshop on programming for mobile &amp; touch",
        "abstract": "It is our great pleasure to welcome you to the proceedings of the PROMOTO’14. The 2nd Workshop on Programming with Mobile and Touch (PROMOTO’14) was held in Portland, OR on October 22, 2014, in conjunction with SPLASH/OOPSLA 2014. The goals of the workshop were to discuss the issues surrounding touch and mobile programming and to plan future directions.Workshop Overview Today, easy-to-use mobile devices like smartphones and tablets are becoming more prevalent than traditional PCs and laptops. New programming languages are emerging to enable programmers to develop software easily, leveraging the exciting advances in existing hardware, and providing abstractions that fit the capabilities of target platforms with multiple sensors, touch and cloud capabilities. PROMOTO’14 brought together researchers who have been exploring new programming paradigms, embracing the new realities of always connected, touch-enabled mobile devices. Specific areas of interest were the technical aspects of cross-platform computing, cloud computing, social applications, and education.Submissions for this event were invited in the general area of mobile and touch-oriented programming languages and programming environments, and teaching of programming for mobile devices. Topics of interest included: Mobile and touch-oriented programming languagesProgramming languages using innovative input mechanismsProgramming environments on or for mobile devicesTeaching of programming on or for mobile devicesProgramming tools such as debuggers on or for mobiles devicesLibraries and programming frameworks that simplify programming for mobile devicesThe workshop received 11 submissions from all over the world. Each paper was reviewed by three members of the program committee and 6 were chosen for presentation as full papers, short papers or tool demos. We also had three additional stimulating sessions: A keynote on \"Programming gadgets with gadgets\" presented by Jonathan de Halleux of Microsoft Research.A group hands-on session, were participants were challenged to create an app in an hour, and compare results.A lively panel on \"Mobile Computing and Education\"The Keynote The keynote by de Halleux son \"Programming gadgets with gadgets\", not reported on elsewhere, was a lively presentation with an array of gadgets on display. Hardware 2.0 is upon us: cheap micro-controller boards like Arduino have gained massive adoption in recent years. Paired with 3D printers, cheap sensors and actuators, Hardware 2.0 allows anyone to prototype the next hot gadget. And yet, the maker will have to learn a soup of software language and framework to build a connected IoC solution: C++ for the micro controller code, HTML + javascript for the client, some backend language and a communication layer to interact with the devices. In this keynote, de Halleux showed a unified approach for compilation of web server code, rich client and embedded firmware under a simple mobile friendly language and IDE.",
        "keywords": "",
        "released": 2014,
        "link": "https://dl.acm.org/doi/10.1145/2688471"
    },
    {
        "title": "Considering visual programming environments for documenting physical computing artifacts",
        "abstract": "In online communities makers share and give feedback on DIY projects. Such feedback could also help novices who get stuck in their projects. However, documenting work in progress is little considered in current tools. We therefore developed a HowTo related web platform for documenting work in progress and studied how children (aged 1318) used it to document their physical computing projects during workshops. The evaluation outcome questions the appropriateness of our web platform and reveals the benefits of visual programming environments for documenting physical computing artifacts. Suggestions are given how to extend visual programming environments into minimalistic documentation tools that provide ways for children to successfully share their work in progress with other makers.",
        "keywords": "visual programming; physical computing; documentation; diy; children",
        "released": 2014,
        "link": "https://doi.org/10.1145/2593968.2610462"
    },
    {
        "title": "Battery-free MakeCode: Accessible programming for intermittent computing",
        "abstract": "Hands-on computing has emerged as an exciting and accessible way to learn about computing and engineering in the physical world for students and makers of all ages. Current end-to-end approaches like Microsoft MakeCode require tethered or battery-powered devices like a micro:bit, limiting usefulness and applicability, as well as abdicating responsibility for teaching sustainable practices. Unfortunately, energy harvesting computing devices are usually only programmable by experts and require significant supporting toolchains and knowledge across multiple engineering and computing disciplines to work effectively. This paper bridges the gap between sustainable computing efforts, the maker movement, and novice-focused programming environments with MakeCode-Iceberg, a set of compiler extensions to Microsoft’s open-source MakeCode project. The extensions automatically and invisibly transform user code in any language supported (Blocks, JavaScript, Python)into a version that can safely and correctly execute across intermittent power failures caused by unreliable energy harvesting. Determining where, when, and what to save in a checkpoint on limited energy, time, and hardware budget is challenging. We leverage the unique intermediate representation of the MakeCode source-to-source compiler to design and deploy various checkpointing techniques. Our approach allows us to provide, for the first time, a fully web-based and toolchain-free environment to program intermittent computing devices, making battery-free operation accessible to all. We demonstrate new use cases with multiple energy harvesters, peripherals, and application domains: including a Smart Terrarium, Step Counter, and Combination Lock. MakeCode-Iceberg provides sustainable hands-on computing opportunities to a broad audience of makers and learners, democratizing access to energy harvesting and battery-free embedded systems.",
        "keywords": "Intermittent Computing; Energy Harvesting; Block based programming; Battery-free",
        "released": 2022,
        "link": "https://doi.org/10.1145/3517236"
    },
    {
        "title": "Design of big data algorithm based on MapReduce",
        "abstract": "With the widespread application of Internet technology, the utilization rate of similar blogs and social networks has been significantly improved. With the intervention of cloud computing and other technologies, a large amount of data generated during browsing the Internet can be effectively accumulated and processed, which indicates that big data has been integrated into people’s daily life. MapReduce, as a parallel programming environment, can effectively deal with big data related problems, and has been applied in large Internet companies such as Google and Amazon Maxdiff, an efficient histogram algorithm based on MapReduce, includes accurate algorithm and approximate algorithm, and proposes two-table equijoin algorithm and multistandard equijoin algorithm for data skew And optimize the efficiency of the connection algorithm when one or more data in the data set appear too much. This paper starts with the efficiency optimization of big data connection algorithm based on MapReduce, and studies the efficiency optimization of equijoin algorithm, data skew connection algorithm and connection algorithm in detail, and then puts forward an algorithm that can effectively improve the program execution efficiency, hoping to provide reference for the follow-up research work.",
        "keywords": "MapReduce; Big data; Algorithm",
        "released": 2020,
        "link": "https://doi.org/10.1145/3434581.3434721"
    },
    {
        "title": "A framework for collaborative and interactive agent-oriented developer operations",
        "abstract": "Considering the increasing prevalence of autonomous systems in today’s society, one could expect that agent-oriented programming (AOP) is gaining traction among mainstream software engineering practitioners. However, the tools and frameworks that are used and developed in the academic multi-agent systems engineering community struggle to keep up with recent developments in the software industry in regards to how complex information systems are developed and maintained. An important aspect of recent changes in software engineering practices is the application of technologies that supports the increasingly fast iteration of a programming-testing-deployment cycle. Such approaches require intense collaboration that crosses boundaries between traditionally separated roles like software development, quality assurance, and operations; these approaches are often referred to as DevOps. Researchers need to explore what additional value AOP has to offer in the context of new paradigms and practices. In this paper, we work towards the integration of DevOps and AOP by introducing an extension of jacamo-web, an Integrated Development Environment (IDE) that supports the collaborative, web-based development and real-time continuous integration of autonomous agents and Multi-Agent Systems (MAS).",
        "keywords": "iterative software development; ide; engineering multi-agent systems; agent-oriented programming",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3398761.3399086"
    },
    {
        "title": "Sentiment analysis of bengali online reviews written with english letter using machine learning approaches",
        "abstract": "In this paper, we have done sentiment analysis for English written Bengali words given in different online shops in Bangladesh. For this work we have chosen 4 latest mobile phone popular in Bangladesh. For this purpose we have used Multinomial naı̈ve bayes classification system. The dataset that has been used for this work has been taken from some online shops websites that is been publicly available. The only data taken hasbeen related to selected popular cellphone sets. For better understanding and realistic understanding some common features were selected that people looks for. In this work 6 feature were selected. They are-Camera, Battery, Screen, Sounds, Design and Hardware/Software performance. We went for these feature related comments and reviews for constructing our dataset. 90",
        "keywords": "sentiment analysis; python; natural language processing; naı̈ve; machine learning approaches; bengali",
        "released": 2019,
        "link": "https://doi.org/10.1145/3362966.3362977"
    },
    {
        "title": "Towards a pattern language for interactive coding tutorials",
        "abstract": "Online, text-based coding tutorials are popular among programming learners. Though they are relatively easy to create, it’s challenging to ensure their pedagogical effectiveness. Computer Science Education researchers have advocated for interactive tutorials, because they provide learners with opportunities to practice and receive feedback while completing a tutorial. Nonetheless, little guidance exists on how to best leverage interactivity in tutorials. We set out to develop a pattern language for interactive tutorials to fill this gap. Through a human-centered design process, we created and evolved three instructional patterns and their supporting interaction components in a tutorial on asynchronous programming. We describe the preliminary results of our work towards this pattern language in this paper.",
        "keywords": "programming education; pattern language; online code editors; coding tutorials",
        "released": 2020,
        "link": "https://doi.org/10.1145/3397537.3397558"
    },
    {
        "title": "SV-sim: Scalable PGAS-based state vector simulation of quantum circuits",
        "abstract": "High-performance quantum circuit simulation in a classic HPC is still imperative in the NISQ era. Observing that the major obstacle of scalable state-vector quantum simulation arises from the massively fine-grained irregular data-exchange with remote nodes, in this paper we present SV-Sim to apply the PGAS-based communication models (i.e., direct peer access for intra-node CPUs/GPUs and SHMEM for inter-node CPU/GPU clusters) for efficient generalpurpose quantum circuit simulation. Through an orchestrated design based on device functional pointer, SV-Sim is able to abstract various quantum gates across multiple heterogeneous backends, including IBM/Intel/AMD CPUs, NVIDIA/AMD GPUs, and Intel Xeon Phi, in a unified framework, but still asserting outstanding performance and tractable interface to higher-level quantum programming environments, such as IBM Qiskit, Microsoft Q# and Google Cirq. Circumventing the obstacle from the lack of polymorphism in GPUs and leveraging the device-initiated one-sided communication, SV-Sim can process circuit that are dynamically generated in Python using a single GPU/CPU kernel without the need of expensive JIT or runtime parsing, significantly simplifying the programming complexity and improving performance for QC simulation. This is especially appealing for the variational quantum algorithms given the circuits are synthesized online per iteration. Evaluations on the latest NVIDIA DGX-A100, V100-DGX-2, ALCF Theta, OLCF Spock, and OLCF Summit HPCs show that SV-Sim can deliver scalable performance on various state-of-the-art HPC platforms, offering a useful tool for quantum algorithm validation and verification. SV-Sim has been released at http://github.com/pnnl/sv-sim. A version specially tweaked for Q#/QDK is also provided.",
        "keywords": "quantum simulation; OpenSHMEM; NVSHMEM; GPU",
        "released": 2021,
        "link": "https://doi.org/10.1145/3458817.3476169"
    },
    {
        "title": "Pytch — an environment for bridging block and text programming styles (work in progress)",
        "abstract": "Block-based programming languages, and Scratch in particular, are widely used to introduce young learners to programming. As these students progress through their education, they want or need to transition to using text-based systems and encounter a number of challenges as they do so. Issues with syntax, text editing, and memorisation are all significant, but the change of programming paradigm is also a challenge. This paper discusses the design and development of a system to help students make the transition to text-based programming environments more easily. Sprites, animations and sound form the basis of most Scratch programs and these engaging features become unavailable at the same time as students are facing transition difficulties related to text editing and program structure. From programs designed in an actor-based event-driven system with easy concurrency, students have to move to procedural or class-based programs where multimedia features are accessed quite differently and programs are designed around explicit event loops. In this paper we introduce a new programming system, Pytch, which embodies “Scratch-Oriented programming” in Python. Using a web-based environment that requires no local setup, students can build Python programs using the familiar sprites and concurrent event-driven model learned in Scratch. The system offers the programming model inspired by Scratch through a Python library and a runtime augmented with a form of managed concurrency. The motivation and related work are discussed, and the system is presented in its current form. The next stage will be to evaluate the effectiveness of the system with users.",
        "keywords": "Scratch; Python; Programming languages; Games; Education",
        "released": 2021,
        "link": "https://doi.org/10.1145/3481312.3481318"
    },
    {
        "title": "Beyond CS principles: Bringing the frontiers of computing to K12",
        "abstract": "The AP Computer Science Principles (CSP) high school course introduces students to computer science and programming. What should motivated students study after successful completion of AP CSP? The AP CSA class teaches Java programming and it has traditionally not attracted students from underrepresented groups. We are working on an alternative, projects-based course that will teach cutting edge CS concepts, such as distributed computing, computer networking, cybersecurity, the internet of things and machine learning, in a hands-on, accessible manner. Such an approach enables students to work on problems that interest them making computing more relevant and the curriculum more engaging. We utilize NetsBlox, a collaborative, block-based programming environment that extends Snap! with a few carefully selected abstractions that open up the vast array of resources freely available on the internet for student programs. Moreover, the tool enables students to work together on the same project remotely similarly to how Google Docs operate. This demonstration will introduce the environment and highlight its utility in creating distributed applications such as a shared whiteboard app and projects that access public domain scientific data sources and visualize them in various ways using online services such as Google Maps or charting. More information is available at https://netsblox.org.",
        "keywords": "internet of things; distributed computing; cybersecurity; computer networking; block-based programming",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3439542"
    },
    {
        "title": "1st international workshop on live programming (LIVE 2013)",
        "abstract": "Live programming is an idea espoused by programming environments from the earliest days of computing (such as Lisp machines and SmallTalk) but have since lain dormant. Recently, the prevalence of asynchronous feedback in programming languages such as Javascript and advances in visualizations and user interfaces have lead to a resurgence of live programming in online education communities (such as Khan Academy) and in experimental IDEs (such as LightTable). The LIVE 2013 workshop includes 12 papers describing visions, implementations, mashups, and new directions of live programming environments. The participants include both practitioners of live coding and researchers in programming languages and software engineering. Finally, several demos curated on the live workshop page are presented.",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2486788.2487068"
    },
    {
        "title": "A microlearning online framework for teaching programming basics",
        "abstract": "This lightning talk describes the authors’ initiative to deliver effective and enjoyable online learning of programming-basics to middle-school and beyond students with no programming background. With the COVID-19 long-term implications that have driven school systems to online learning, students face new challenges as they struggle to maintain their focus during long online sessions, with some experiencing physical impacts (e.g., ’zoom fatigue’). Microlearning, a set of small (5-8 min of length) learning units targeting small learning objectives and usually delivered online, appears as a promising direction for educators to face these challenges. However, because of its fragmented nature, and difficulty to provide immediate ’value-based’ feedback to the learner, it is hard to apply microlearning in complex domains such as Computer-Science and programming. We are looking to develop a task-driven online microlearning environment for learning programming-basics. The environment will include motivating microtasks as well as formative feedback per microlearning unit. In a pilot study, we included short recorded lectures and project-driven activities. For the learning Integrated Development Environment (IDE) we used the application Tinkercad, which enables building programmable electronic devices. This learning IDE enabled the students to exercise ’micro-projects’ (involving software and simulated hardware) in which their code had to ’operate’ electronic device. We believe this concept can inspire a pedagogical framework that utilizes Microlearning for teaching programming and we will welcome the audience’s input.",
        "keywords": "programming-basics; online-learning; microlearning",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3439554"
    },
    {
        "title": "Real-time collaborative coding in a web IDE",
        "abstract": "This paper describes Collabode, a web-based Java integrated development environment designed to support close, synchronous collaboration between programmers. We examine the problem of collaborative coding in the face of program compilation errors introduced by other users which make collaboration more difficult, and describe an algorithm for error-mediated integration of program code. Concurrent editors see the text of changes made by collaborators, but the errors reported in their view are based only on their own changes. Editors may run the program at any time, using only error-free edits supplied so far, and ignoring incomplete or otherwise error-generating changes. We evaluate this algorithm and interface on recorded data from previous pilot experiments with Collabode, and via a user study with student and professional programmers. We conclude that it offers appreciable benefits over naive continuous synchronization without regard to errors and over manual version control.",
        "keywords": "pair programming; collaborative editing; collaboration",
        "released": 2011,
        "link": "https://doi.org/10.1145/2047196.2047215"
    },
    {
        "title": "Improv: Teaching programming at scale via live coding",
        "abstract": "Computer programming instructors frequently perform live coding in settings ranging from MOOC lecture videos to online livestreams. However, there is little tool support for this mode of teaching, so presenters must now either screen-share or use generic slideshow software. To overcome the limitations of these formats, we propose that programming environments should directly facilitate live coding for education. We prototyped this idea by creating Improv, an IDE extension for preparing and delivering code-based presentations informed by Mayer’s principles of multimedia learning. Improv lets instructors synchronize blocks of code and output with slides and create preset waypoints to guide their presentations. A case study on 30 educational videos containing 28 hours of live coding showed that Improv was versatile enough to replicate approximately 96",
        "keywords": "",
        "released": 2019,
        "link": "https://doi.org/10.1145/3330430.3333627"
    },
    {
        "title": "Fusion: Opportunistic web prototyping with UI mashups",
        "abstract": "Modern web development is rife with complexity at all layers, ranging from needing to configure backend services to grappling with frontend frameworks and dependencies. To lower these development barriers, we introduce a technique that enables people to prototype opportunistically by borrowing pieces of desired functionality from across the web without needing any access to their underlying codebases, build environments, or server backends. We implemented this technique in a browser extension called Fusion, which lets users create web UI mashups by extracting components from existing unmodified webpages and hooking them together using transclusion and JavaScript glue code. We demonstrate the generality and versatility of Fusion via a case study where we used it to create seven UI mashups in domains such as programming tools, data science, web design, and collaborative work. Our mashups include replicating portions of prior HCI systems (Blueprint for in-situ code search and DS.js for in-browser data science), extending the p5.js IDE for Processing with real-time collaborative editing, and integrating Python Tutor code visualizations into static tutorials. These UI mashups each took less than 15 lines of JavaScript glue code to create with Fusion.",
        "keywords": "web prototyping; ui mashups; opportunistic programming",
        "released": 2018,
        "link": "https://doi.org/10.1145/3242587.3242632"
    },
    {
        "title": "Developing web of data applications from the browser",
        "abstract": "WikiNEXT is a wiki engine 100",
        "keywords": "wikis; web2.0; web applications; semantic wikis; semantic web; knowledge management; ides",
        "released": 2014,
        "link": "https://doi.org/10.1145/2567948.2578040"
    },
    {
        "title": "Autocompletion for prefix-abbreviated input",
        "abstract": "Query autocompletion (QAC) is an important interactive feature that assists users in formulating queries and saving keystrokes. Due to the convenience it brings to users, QAC has been adopted in many applications, including Web search engines, integrated development environments (IDEs), and mobile devices. For existing QAC methods, users have to manually type delimiters to separate keywords in their inputs. In this paper, we propose a novel QAC paradigm through which users may abbreviate keywords by prefixes and do not have to explicitly separate them. Such paradigm is useful for applications where it is inconvenient to specify delimiters, such as desktop search, text editors, and input method editors. E.g., in an IDE, users may input getnev and we suggest GetNextValue. We show that the query processing method for traditional QAC, which utilizes a trie index, is inefficient under the new problem setting. A novel indexing and query processing scheme is hence proposed to efficiently complete queries. To suggest meaningful results, we devise a ranking method based on a Gaussian mixture model, taking into consideration the way in which users abbreviate keywords, as opposed to the traditional ranking method that merely considers popularity. Efficient top-k query processing techniques are developed on top of the new index structure. Experiments demonstrate the effectiveness of the new QAC paradigm and the efficiency of the proposed query processing method.",
        "keywords": "query suggestion; prefix-abbreviated input; autocompletion",
        "released": 2019,
        "link": "https://doi.org/10.1145/3299869.3319858"
    },
    {
        "title": "Storyteller: Guiding students through code examples",
        "abstract": "This paper describes a tool to help instructors guide learners through code examples. The tool captures low-level changes made to a group of files using a popular code editor. Then it allows the programming session to be replayed so that an author can annotate the evolution of the code and explain the reasons behind important decisions. The author-supplied narrative can include text, code highlights, media (hand-drawn pictures, screenshots, videos, and audio files), and self-grading questions. The combination of the narrative and the evolving code is called a code ’playback’. Playbacks are viewable in a web browser.The paper also discusses the experiences of one instructor’s use of the tool in several programming-focused courses over the last two years. The tool provides instructors with an alternative to live coding that allows one to describe code faster and with fewer mistakes. In addition, it provides a way for an instructor to build up relevant content that can replace a traditional textbook. The results of several anonymous student surveys are discussed.",
        "keywords": "live coding; textbook replacement; worked examples",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545945.3569843"
    },
    {
        "title": "FIRST principles to design for online, synchronous high school CS teacher training and curriculum co-design",
        "abstract": "The Covid-19 pandemic has offered new challenges and opportunities for teaching and research. It has forced constraints on in-person gathering of researchers, teachers, and students, and conversely, has also opened doors to creative instructional design. This paper describes a novel approach to designing an online, synchronous teacher professional development (PD) and curriculum co-design experience. It shares our work in bringing together high school teachers and researchers in four US states. The teachers participated in a 3-week summer PD on ideas of Distributed Computing and how to teach this advanced topic to high school students using NetsBlox, an extension of the Snap! block-based programming environment. The goal of the PD was to prepare teachers to engage in collaborative co-design of a 9-week curricular module for use in classrooms and schools. Between their own training and the co-design process, teachers co-taught a group of high school students enrolled in a remote summer internship at a university in North Carolina to pilot the learned units and leverage ideas from their teaching experience for subsequent curricular co-design. Formative and summative feedback from teachers suggest that this PD model was successful in meeting desired outcomes. Our generalizable FIRST principles—Flexibility, Innovativeness, Responsiveness (and Respect), Supports, and Teamwork (collaboration)—that helped make this unique PD successful, can help guide future CS teacher PD designs.",
        "keywords": "",
        "released": 2020,
        "link": "https://doi.org/10.1145/3428029.3428059"
    },
    {
        "title": "Verified from scratch: Program analysis for learners’ programs",
        "abstract": "Block-based programming languages like Scratch support learners by providing high-level constructs that hide details and by preventing syntactically incorrect programs. Questions nevertheless frequently arise: Is this program satisfying the given task? Why is my program not working? To support learners and educators, automated program analysis is needed for answering such questions. While adapting existing analyses to process blocks instead of textual statements is straightforward, the domain of programs controlled by block-based languages like Scratch is very different from traditional programs: In Scratch multiple actors, represented as highly concurrent programs, interact on a graphical stage, controlled by user inputs, and while the block-based program statements look playful, they hide complex mathematical operations that determine visual aspects and movement. Analyzing such programs is further hampered by the absence of clearly defined semantics, often resulting from ad-hoc decisions made by the implementers of the programming environment. To enable program analysis, we define the semantics of Scratch using an intermediate language. Based on this intermediate language, we implement the Bastet program analysis framework for Scratch programs, using concepts from abstract interpretation and software model checking. Like Scratch, Bastet is based on Web technologies, written in TypeScript, and can be executed using NodeJS or even directly in a browser. Evaluation on 279 programs written by children suggests that Bastet offers a practical solution for analysis of Scratch programs, thus enabling applications such as automated hint generation, automated evaluation of learner progress, or automated grading.",
        "keywords": "software model checking; scratch; education",
        "released": 2021,
        "link": "https://doi.org/10.1145/3324884.3416554"
    },
    {
        "title": "On the dichotomy of debugging behavior among programmers",
        "abstract": "Debugging is an inevitable activity in most software projects, often difficult and more time-consuming than expected, giving it the nickname the \"dirty little secret of computer science.\" Surprisingly, we have little knowledge on how software engineers debug software problems in the real world, whether they use dedicated debugging tools, and how knowledgeable they are about debugging. This study aims to shed light on these aspects by following a mixed-methods research approach. We conduct an online survey capturing how 176 developers reflect on debugging. We augment this subjective survey data with objective observations on how 458 developers use the debugger included in their integrated development environments (IDEs) by instrumenting the popular Eclipse and IntelliJ IDEs with the purpose-built plugin WatchDog 2.0. To clarify the insights and discrepancies observed in the previous steps, we followed up by conducting interviews with debugging experts and regular debugging users. Our results indicate that IDE-provided debuggers are not used as often as expected, as \"printf debugging\" remains a feasible choice for many programmers. Furthermore, both knowledge and use of advanced debugging features are low. These results call to strengthen hands-on debugging experience in computer science curricula and have already refined the implementation of modern IDE debuggers.",
        "keywords": "",
        "released": 2018,
        "link": "https://doi.org/10.1145/3180155.3180175"
    },
    {
        "title": "ARcadia: A rapid prototyping platform for real-time tangible interfaces",
        "abstract": "Paper-based fabrication techniques offer powerful opportunities to prototype new technological interfaces. Typically, paper-based interfaces are either static mockups or require integration with sensors to provide real-time interactivity. The latter can be challenging and expensive, requiring knowledge of electronics, programming, and sensing. But what if computer vision could be combined with prototyping domain-aware programming tools to support the rapid construction of interactive, paper-based tangible interfaces? We designed a toolkit called ARcadia that allows for rapid, low-cost prototyping of TUIs that only requires access to a webcam, a web browser, and paper. ARcadia brings paper prototypes to life through the use of marker based augmented reality (AR). Users create mappings between real-world tangible objects and different UI elements. After a crafting and programming phase, all subsequent interactions take place with the tangible objects. We evaluated ARcadia in a workshop with 120 teenage girls and found that tangible AR technologies can empower novice technology designers to rapidly construct and iterate on their ideas.",
        "keywords": "tangible user interfaces; real-time interactivity; paper prototyping; block-based programming; augmented reality",
        "released": 2018,
        "link": "https://doi.org/10.1145/3173574.3173983"
    },
    {
        "title": "Programming for children and teenagers in brazil: A 5-year experience of an outreach project",
        "abstract": "There has been a worldwide surge in programming education initiatives for children and teenagers. In Brazil, this trend faces some challenges, namely inadequate infrastructure of most schools, notably public ones, that lack access to computers and tablets, and basic education curricular requirements not contemplating computer science concepts. This article reports on the five-year experience of an outreach project from a public university in Brazil. The project aims to promote computer science education and to teach programming to children and teenagers. Undergraduate engineering students who participate in the project as members engage in activities such as planning the courses and their schedules, creating partnerships with local schools and other educational projects, giving lectures, producing scientific research and educational materials, as well as promoting the project on social media. The courses use free online programming tools, Python, MIT App Inventor, and Arduino to cover fundamental concepts of programming and computational thinking. They vary approaches and tools according to the age range and available technological resources of the target audience. The use of unplugged activities means to assist in learning and to circumvent computer access problems. Furthermore, they serve for introducing basic programming concepts in classes and motivating students with dynamic activities. Over its five-year existence, the project has achieved its purpose, by reaching a total of 2639 students through 45 workshops and 94 courses. It has provided courses in eleven public schools, created two booklets and one app as free educational material, along with presented papers and posters in scientific conferences.",
        "keywords": "programming; k-12; didactic strategies; computer science education; computational thinking",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3432554"
    },
    {
        "title": "Fulfilling papert’s dream: Computational fluency for all",
        "abstract": "Fifty years ago, Seymour Papert and colleagues developed Logo as the first programming language for children. Today, millions of children are participating in learn-to-code initiatives, but Papert’s dream remains unfulfilled. Papert (who passed away last summer) saw programming not as a set of technical skills but as a new form of fluency - a new way for all children to explore, experiment, and express themselves. In this presentation, I will examine strategies for fulfilling Papert’s dream. Drawing on examples from our Scratch online coding community, I will discuss how we can design programming environments and activities to help all children, from all backgrounds, to develop their thinking, develop their voices, and develop their identities.",
        "keywords": "scratch; programming; learning; education; creativity; computational thinking",
        "released": 2017,
        "link": "https://doi.org/10.1145/3017680.3025046"
    },
    {
        "title": "TrueChange™ under the hood: How we check the consistency of large models (almost) instantly",
        "abstract": "The OutSystems Platform is a visual model-driven development and delivery platform that allows developers to create enterprise-grade web and mobile applications.The models created with the platform are translated by its compiler into a set of standard-technology artifacts (C#, JavaScript, SQL, etc). The model must be checked for consistency (i.e., that it is well-formed and well-typed) before compilation can proceed. Our Integrated Development Environment (IDE) does this in real-time: after each change made a developer, the IDE either automatically heals the other parts of the model that are impacted by the change, or provides immediate feedback on the errors that must be manually corrected.It is not uncommon for an OutSystems model to contain in excess of 200,000 individual elements. Handling large models efficiently is thus of paramount importance: consistency checks must run as fast as possible, otherwise the developer’s experience is significantly impaired.In this paper we present the techniques we have developed to speed up consistency checks, and which resulted in the TrueChange™ engine. We use an incremental approached paired with automatically managed back pointers. We believe these techniques are of general application and not limited to our particular case.",
        "keywords": "model driven development; large models; domain specific language; consistency check",
        "released": 2021,
        "link": "https://doi.org/10.1109/MODELS-C.2019.00056"
    },
    {
        "title": "Mixing code and 3D printers with madeup (abstract only)",
        "abstract": "Madeup is a text- and blocks-based programming language for making things up—literally. Programmers write sequences of commands to move and turn through space, tracing out printable 3D shapes with algorithms and mathematical operations. The language is designed to teach computation from a tangible, first-person perspective and help students integrate computation back into the physical world. In this workshop, we empower educators to use the freely-available and browser-based Madeup programming environment in their classrooms. Participants should expect to learn actively.",
        "keywords": "syntonic learning; media computation; 3d printing",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2844682"
    },
    {
        "title": "ARcadia: A rapid prototyping platform for real-time tangible interfaces",
        "abstract": "Paper-based fabrication techniques offer powerful opportunities to prototype new technological interfaces. Typically, paper-based interfaces are either static mockups or require integration with sensors to provide real-time interactivity. The latter can be challenging and expensive, requiring knowledge of electronics, programming, and sensing. But what if computer vision could be combined with prototyping domain-aware programming tools to support the rapid construction of interactive, paper-based tangible interfaces? We designed a toolkit called ARcadia that allows for rapid, low-cost prototyping of TUIs that only requires access to a webcam, a web browser, and paper. ARcadia brings paper prototypes to life through the use of marker based augmented reality (AR). Users create mappings between real-world tangible objects and different UI elements. After a crafting and programming phase, all subsequent interactions take place with the tangible objects. We evaluated ARcadia in a workshop with 120 teenage girls and found that tangible AR technologies can empower novice technology designers to rapidly construct and iterate on their ideas.",
        "keywords": "tangible user interfaces; real-time interactivity; paper prototyping; block-based programming; augmented reality",
        "released": 2018,
        "link": "https://doi.org/10.1145/3170427.3186535"
    },
    {
        "title": "A web app for writing with mathematical logic",
        "abstract": "Logicwriter Actual is a web app (https://www.cs.drexel.edu/ bchar/logicwriter/standardConfig/web/index.html) designed for freeform entry and linear display in Unicode of text combined with symbolic logic characters such as ≡, ∃, ∧, ⇒, λ, and Ω. It is designed for the writing done by students or instructors in foundational-level (second year) courses introducing mathematical reasoning: elementary formal or informal proofs often involving commonplace situations or computer science contexts such as program behavior. Rather than being a scaffolded practice harness [1], or an automated reasoning tool/proof checker [2, 5], the goal of Logicwriter Actual is just to make it easier for students to practice more mathematical writing. The WYSIWYG result can be copy/pasted into most document processors (for submitted or shared work), Discord or Slack channels (for chat conversations), email, code editors, etc. It is designed to be immediately usable by browser- and laptop-savvy students, so more convenient to use in a foundational course than available alternatives (word processors, LaTeX, LyX, keyboard entry of Unicode indices, Math Jax plugins, etc. [3, 4, 6]) It is designed to need minimal computer resources (runs in browser, can be delivered from any web page server), and instructor time (for student training, or tech support). Because it is just a writing tool, it is compatible with most instructional approaches that ask students to write their own proofs and explanations. Assessment is underway through student survey of usage experience and effects, and by instructor survey/interview.to see if there are perceived benefits to its approach to text entry and style of implementation as a web app.",
        "keywords": "",
        "released": 2023,
        "link": "https://dl.acm.org/doi/10.5555/3606402.3606429"
    },
    {
        "title": "Microsoft MakeCode: Embedded programming for education, in blocks and TypeScript",
        "abstract": "Microsoft MakeCode (https://www.makecode.com) is a platform and accompanying web app for simplifying the programming of microcontroller-based devices in the classroom. For each device, MakeCode provides a customized end-to-end experience in the web browser consisting of code editors, device simulator, debugger, compiler to machine code, and linker to a pre-compiled C++ runtime, as well as a documentation and tutorial system. We present an overview of MakeCode and detail the major design decisions behind the platform.",
        "keywords": "microcontrollers; TypeScript; JavaScript; CS education; Blockly",
        "released": 2019,
        "link": "https://doi.org/10.1145/3358711.3361630"
    },
    {
        "title": "Teaching cybersecurity with networked robots",
        "abstract": "The paper presents RoboScape, a collaborative, networked robotics environment that makes key ideas in computer science accessible to groups of learners in informal learning spaces and K-12 classrooms. RoboScape is built on top of NetsBlox, an open-source, networked, visual programming environment based on Snap! that is specifically designed to introduce students to distributed computation and computer networking. RoboScape provides a twist on the state of the art of robotics learning platforms. First, a user’s program controlling the robot runs in the browser and not on the robot. There is no need to download the program to the robot and hence, development and debugging become much easier. Second, the wireless communication between a student’s program and the robot can be overheard by the programs of the other students. This makes cybersecurity an immediate need that students realize and can work to address. We have designed and delivered a cybersecurity summer camp to 24 students in grades between 7 and 12. The paper summarizes the technology behind RoboScape, the hands-on curriculum of the camp and the lessons learned.",
        "keywords": "visual programming; snap!; robotics; netsblox; cybersecurity; computer science education; block-based programming",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287450"
    },
    {
        "title": "Simple emulated computer improvements to facilitate understanding in introductory computer programming and computer organization/architecture classes",
        "abstract": "This paper describes improvements to a very simple, four instruction CPU, originally designed using digital logic simulation software, and used briefly in introductory C# programming classes to illustrate computer architecture concepts needed to appreciate the programming process. It is also used in a quick introduction to computer organization. One improvement is a C# version of this simple computer that hides the details of the complete logic simulation design. This implementation can also be used in a web programming environment of online classes. The other improvement provides an assembler again for use in an introduction to computer organization classes.",
        "keywords": "",
        "released": 2016,
        "link": "https://dl.acm.org/doi/10.5555/2904127.2904135"
    },
    {
        "title": "Jimbo: A collaborative IDE with live preview",
        "abstract": "Team collaboration plays a key role in the success of any multi-user activity. Software engineering is a highly collaborative activity, where multiple developers and designers work together to solve a common problem. Meaningful and effective designer-developer collaboration improves the user experience, which can improve the chances of success for the project. Learning to program is another activity that can be implemented in a more collaborative way, students can learn in an active style by working with others. The growth of online classes, from small structured seminars to massive open online courses (MOOCs), and the isolation and impoverished learning experience some students report in these, points to an urgent need for tools that support remote pair programming in a distributed educational setting.In this paper, we describe Jimbo, a collaborative integrated development environment (IDE) that we believe is beneficial and effective in both aforementioned activities. Jimbo integrates many features that support better collaboration and communication between designers and developers, to bridge communication gaps and develop mutual understanding. These novel features can improve today’s CS education by bringing students closer to each other and their instructors as well as training them to collaborate which is consistent with current practices in software engineering.",
        "keywords": "web development; user awareness; pair programming; live preview; distance learning; designer-developer collaboration; communication; collaborative learning; collaboration; Jimbo; IDE",
        "released": 2016,
        "link": "https://doi.org/10.1145/2897586.2897613"
    },
    {
        "title": "ASIDE: IDE support for web application security",
        "abstract": "Many of today’s application security vulnerabilities are introduced by software developers writing insecure code. This may be due to either a lack of understanding of secure programming practices, and/or developers’ lapses of attention on security. Much work on software security has focused on detecting software vulnerabilities through automated analysis techniques. While they are effective, we believe they are not sufficient. We propose to increase developer awareness and promote practice of secure programming by interactively reminding programmers of secure programming practices inside Integrated Development Environments (IDEs). We have implemented a proof-of-concept plugin for Eclipse and Java. Initial evaluation results show that this approach can detect and address common web application vulnerabilities and can serve as an effective aid for programmers. Our approach can also effectively complement existing software security best practices and significantly increase developer productivity.",
        "keywords": "secure software development; secure programming; interactive support; application security",
        "released": 2011,
        "link": "https://doi.org/10.1145/2076732.2076770"
    },
    {
        "title": "Interaction graphs: Visual analysis of eye movement data from interactive stimuli",
        "abstract": "Eye tracking studies have been conducted to understand the visual attention in different scenarios like, for example, how people read text, which graphical elements in a visualization are frequently attended, how they drive a car, or how they behave during a shopping task. All of these scenarios - either static or dynamic - show a visual stimulus in which the spectators are not able to change the visual content they see. This is different if interaction is allowed like in (graphical) user interfaces (UIs), integrated development environments (IDEs), dynamic web pages (with different user-defined states), or interactive displays in general as in human-computer interaction, which gives a viewer the opportunity to actively change the stimulus content. Typically, for the analysis and visualization of time-varying visual attention paid to a web page, there is a big difference for the analytics and visualization approaches - algorithmically as well as visually - if the presented web page stimulus is static or dynamic, i.e. time-varying, or dynamic in the sense that user interaction is allowed. In this paper we discuss the challenges for visual analysis concepts in order to analyze the recorded data, in particular, with the goal to improve interactive stimuli, i.e., the layout of a web page, but also the interaction concept. We describe a data model which leads to interaction graphs, a possible way to analyze and visualize this kind of eye movement data.",
        "keywords": "visual analytics; information visualization; eye tracking",
        "released": 2019,
        "link": "https://doi.org/10.1145/3317960.3321617"
    },
    {
        "title": "Student attitudes during the pilot of the computer science frontiers course",
        "abstract": "Motivation. We have created a modular project-based learning curriculum, Computer Science Frontiers (CSF) [1, 8], for secondary students in attempts to increase the persistence of computer science (CS) students in higher education. The CSF course is divided into four different modules (Distributed Computing, Internet of Things, Artificial Intelligence, and Software Engineering), each centered around a topic typically introduced to students only in higher education. Using the block-based programming environment NetsBlox [4], students are able to access various Application Programming Interfaces related to their interests [2, 3]. The goal of this course is to increase student interest in CS during high school - when first career choices occur [7] - in hopes they will persist in CS during their undergraduate studies. Research question. The research question for this study was: How does the Computer Science Frontiers course affect student attitudes towards computer science?Research Methods. We conducted over 20 interviews with students throughout a CSF pilot course that took place over the 2022-2023 school year. Interviews were conducted with at least five students at the end of every module. Two researchers have conducted thematic analysis with student responses from the first two modules [5]: Distributed Computing (DC) and Internet of Things (IoT). First, the two researchers developed a norm by tagging one interview together [6]. Next, the researchers independently coded the rest of the interviews for each module. After completing a single module’s interviews, the researchers met to rectify any discrepancies. Finally, the tags were grouped together based on common themes. Through this process, we found a total of seven themes. Results. The themes found through thematic analysis include: computer science, attitudes towards course, student wants, student struggles, attitudes towards projects, collaboration, and student progression. As a result of this study, we have identified different needs for secondary students with varying background in CS when studying more advanced CS topics, such as IoT. For example, a need of students who have less prior CS knowledge than others may be to review programming concepts in order to be successful in the course. We have also identified a positive change in student’s attitudes towards computer science after the first two modules. These insights provide the CS education community with ways to engage students with concepts that they have not been exposed to and how to increase their interest in CS. Implications. The CSF curriculum is currently online, and is available to computer science instructors. Each module is separated into eight to nine units which are accompanied by activities and teaching guides. This curriculum provides educators with materials and activities to introduce students to more advanced CS topics, either through individual modules or as an entire course. In future research, we plan to use CSF in an outreach program and implement the course in two secondary classrooms in the 2023-2024 school year.",
        "keywords": "socially relevant examples; secondary; project-based learning; education research; collaborative learning environment; block-based learning",
        "released": 2023,
        "link": "https://doi.org/10.1145/3568812.3603483"
    },
    {
        "title": "A glimpse of hopjs",
        "abstract": "Hop.js is a multitier programming environment for JavaScript. It allows a single JavaScript program to describe the client-side and the server-side components of a web application. Its runtime environment ensures consistent executions of the application on the server and on the client. This paper overviews the Hop.js design. It shows the JavaScript extensions that makes it possible to conceive web applications globally. It presents how Hop.js interacts with the outside world. It also briefly presents the Hop.js implementation. It presents the Hop.js web server implementation, the handling of server-side parallelism, and the JavaScript and HTML compilers.",
        "keywords": "Web Programming; Functional Programming",
        "released": 2016,
        "link": "https://doi.org/10.1145/2951913.2951916"
    },
    {
        "title": "An environment for learning interactive programming",
        "abstract": "We describe a web-based programming environment designed to support teaching introductory programming for a massive open online class. We discuss some of the thought processes behind the design of this environment and then focus on two key innovations incorporated in our environment: a simplified GUI library for interactive Python programming and a browser-based tool for visualizing the execution of event-driven Python programs.",
        "keywords": "visualization; python; interactive; CS1",
        "released": 2014,
        "link": "https://doi.org/10.1145/2538862.2538908"
    },
    {
        "title": "Tools and methods for creating interactive artifacts",
        "abstract": "Many embedded platforms that support the creation of interactive smart objects have become available over the last years. Arduino, Raspberry Pi, electric imp, mbed, MSP430, and .NET Gadgeteer are examples of hardware platforms with very different properties and capabilities. In order to make interactive artifacts additional sensors, actuators, and networking elements are available for the different platforms. Additionally there are different software environments and development tools that support developers in creating custom applications for embedded systems. It is apparent that one size doesn’t fit all and that choosing the right platform and tools is an important step towards an effective solution. In this TEI2014 studio we first provide an overview of available platforms and tools that allow developers to create novel and tangible interactive systems. We will present and discuss developing environments, with a specific focus on browser based programming tools and social coding. In a second step we will have 2 hands-on sessions, where in each we use a different platform and create an initial functional prototype. The aim is to provide the participants with an overview of existing embedded development tools suitable for creating interactive artifacts and to provide some hands on-experience with different new platforms.",
        "keywords": "tangible objects; social coding; smart artifacts; interaction hardware; embedded systems; development tools; custom device development",
        "released": 2014,
        "link": "https://doi.org/10.1145/2540930.2568483"
    },
    {
        "title": "Performance from aligning smalltalk &amp; javascript classes",
        "abstract": "Amber is a wonderful Smalltalk programming environment that runs on top of Javascript, including a browser-based IDE and compiler, as well as command-line support. The only challenge is that execution performance can be 1–2 orders of magnitude slower than native Javascript code. Amber-Direct is a series of modest changes to the compiler and some infrastructure classes and methods that bring most generated programs to within a factor of two of native Javascript.The challenge we faced was maintaining a seamless integration into existing Javascript classes while maximizing fidelity to Smalltalk execution semantics.",
        "keywords": "",
        "released": 2015,
        "link": "https://doi.org/10.1145/2811237.2811301"
    },
    {
        "title": "CoRED: Browser-based collaborative real-time editor for java web applications",
        "abstract": "While the users of completed applications are heavily moving from desktop to the web browser, the majority of developers are still working with desktop IDEs such as Eclipse or Visual Studio. In contrast to professional installable IDEs, current web-based code editors are simple text editors with extra features. They usually understand lexical syntax and can do highlighting and indenting, but lack many of the features seen in modern desktop editors. In this paper, we present CoRED, a browser-based collaborative real-time code editor for Java applications. CoRED is a complete Java editor with error checking and automatic code generation capabilities, extended with some features commonly associated with social media. As a proof of the concept, we have extended CoRED to support Java based Vaadin framework for web applications. Moreover, CoRED can be used either as a stand-alone version or as a component of any other software. It is already used as a part of browser based Arvue IDE.",
        "keywords": "vaadin; development tools; collaboration architectures",
        "released": 2012,
        "link": "https://doi.org/10.1145/2145204.2145399"
    },
    {
        "title": "LUV is not the answer: Continuous delivery of a model driven development platform",
        "abstract": "The OutSystems Platform is a visual model-driven development and delivery platform that allows developers to create enterprise-grade cross platform web and mobile applications.The platform consists of several inter-dependent components, most notably Service Studio, the Platform Server, and LifeTime. Service Studio is an integrated development environment used to create applications that are then compiled by the Platform Server. LifeTime is used to stage applications between different environments (e.g., development, testing, production).Our meta-model is versioned using a version number that we call Last Upgrade Version (LUV). Service Studio, the Platform Server, and the models they create/process are associated with a particular LUV. As a general rule, a platform component is only able to process models with the same LUV as the component itself.This approach is not very flexible: a change to the meta-model requires releasing a new set of platform components that our customers then need to install. Although there’s low resistance to installing new versions of Service Studio, the same is not true for the Platform Server. Thus, for all practical purposes LUV changes are tied to releases of major versions of the OutSystems Platform.In this paper we share the techniques that allowed us to transition to a Continuous Delivery process in which our meta-model can evolve freely with no impact on our installed base.",
        "keywords": "model evolution; model driven development; meta-model evolution; continuous delivery",
        "released": 2020,
        "link": "https://doi.org/10.1145/3417990.3419502"
    },
    {
        "title": "On the benefits of providing versioning support for end users: An empirical study",
        "abstract": "End users with little formal programming background are creating software in many different forms, including spreadsheets, web macros, and web mashups. Web mashups are particularly popular because they are relatively easy to create, and because many programming environments that support their creation are available. These programming environments, however, provide no support for tracking versions or provenance of mashups. We believe that versioning support can help end users create, understand, and debug mashups. To investigate this belief, we have added versioning support to a popular wire-oriented mashup environment, Yahoo! Pipes. Our enhanced environment, which we call “Pipes Plumber,” automatically retains versions of pipes and provides an interface with which pipe programmers can browse histories of pipes and retrieve specific versions. We have conducted two studies of this environment: an exploratory study and a larger controlled experiment. Our results provide evidence that versioning helps pipe programmers create and debug mashups. Subsequent qualitative results provide further insights into the barriers faced by pipe programmers, the support for reuse provided by our approach, and the support for debugging provided.",
        "keywords": "versioning; reuse; programming barriers; debugging; Yahoo! Pipes; Mashups; End-user software engineering",
        "released": 2014,
        "link": "https://doi.org/10.1145/2560016"
    },
    {
        "title": "Components and rationale of a big data toolkit spanning HPC, grid, edge and cloud computing",
        "abstract": "We look again at Big Data Programming environments such as Hadoop, Spark, Flink, Heron, Pregel; HPC concepts such as MPI and Asynchronous Many-Task runtimes and Cloud/Grid/Edge ideas such as event-driven computing, serverless computing, workflow, and Services. These cross many research communities including distributed systems, databases, cyberphysical systems and parallel computing which sometimes have inconsistent worldviews. There are many common capabilities across these systems which are often implemented differently in each packaged environment. For example, communication can be bulk synchronous processing or data flow; scheduling can be dynamic or static; state and fault-tolerance can have different models; execution and data can be streaming or batch, distributed or local. We suggest that one can usefully build a toolkit (called Twister2 by us) that supports these different choices and allows fruitful customization for each application area. We illustrate the design of Twister2 by several point studies. We stress the many open questions in very traditional areas including scheduling, messaging and checkpointing.",
        "keywords": "mpi; mapreduce; hpc; global machine learning; edge computing; dataflow; cloud computing",
        "released": 2017,
        "link": "https://doi.org/10.1145/3147213.3155012"
    },
    {
        "title": "Challenges with learning to program and problem solve: An analysis of student online discussions",
        "abstract": "Students who study problem solving and programming (in a language such as Python) at University level encounter a range of challenges, from low-level issues with code that won’t compile to misconceptions about the threshold concepts and skills. The current study complements existing findings on errors, misconceptions, difficulties and challenges obtained from students after-the-fact through instruments such as questionnaires and interviews. In our study, we analysed the posts from students of a large cohort (textasciitilde1500) of first-year University distance learning students to an online ’Python help forum’ - recording issues and discussions as the students encountered specific challenges. Posts were coded in terms of topics, and subsequently thematically grouped into Python-related, problem solving/generic programming related, and module specific. We discuss the set of topics and rank these in terms of the number of forum discussions in which they occur (as a proxy for their prevalence). The top challenges we identified concern student understanding and use of a mix of programming environments (in particular, Python IDLE for offline programming and CodeRunner for programming quizzes) and code fragment problems. Apart from these, Python-specific topics include, among others, collections, functions, error messages, iteration, outputting results, indentation, variables and imports. We believe that the results provide a good insight into the challenges that students encounter em as they learn to program. In future work we intend to study the discussions in further detail in terms of theories of conceptual change.",
        "keywords": "threshold concepts and skills; python; programming; problem solving; online student discussions; misconceptions; challenges",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3366838"
    },
    {
        "title": "MiDebug: Microcontroller integrated development and debugging environment",
        "abstract": "We present MiDebug, a web-based Integrated Development Environment (IDE) for embedded system programming with in-browser debugging capabilities. This web application greatly reduces the time and effort required for rapid prototyping of microcontroller based devices.",
        "keywords": "microcontroller programming; integrated development environment; debugging",
        "released": 2012,
        "link": "https://doi.org/10.1145/2185677.2185714"
    },
    {
        "title": "Accessible AST-based programming for visually-impaired programmers",
        "abstract": "Most programmers rely on visual tools (block-based editors, auto-indentation, bracket matching, syntax highlighting, etc.), which are inaccessible to visually-impaired programmers. While prior language-specific, downloadable tools have demonstrated benefits for the visually-impaired, we lack language-independent, cloud-based tools, both of which are critically needed. We present a new toolkit for building fully-accessible, browser-based programming environments for multiple languages. Given a parser that meets certain specifications, this toolkit will generate a block editor familiar to sighted users that also communicates the structure of a program using spoken descriptions, and allows for navigation using standard (accessible) keyboard shortcuts.This paper presents the toolkit and a first evaluation of it. While the toolkit allows for full editing of code, we chose to focus strictly on navigation for this evaluation, using the navigation-only study design of Baker, Milne and Ladner. Visually-impaired programmers completed several tasks with and without our tool, and we compared their results and experience. Users had improved accuracy when completing tasks, were significantly better able to orient when reading code, and felt better about completing the tasks when using the tool. Moreover, these improvements came with no significant change in task completion time over plain text, even for experienced programmers who navigate text using screen readers set to high words-per-minutes.",
        "keywords": "visually impaired/blind programmers; screen reader; code structure; code navigation; blocks; accessibility",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287499"
    },
    {
        "title": "Web-based visual programming for media computation using blockly (abstract only)",
        "abstract": "Tunely and Pixly are web-based programming environments for media computation built using the Blockly visual programming editor library. These language environments were inspired by Georgia Tech’s Media Computation approach and allow images (Pixly) and sounds (Tunely) to be transformed programmatically. Tunely and Pixly provided an approachable environment to students who have little to no experience in programming, and allow younger students to explore programming in a fun way without the challenges and frustration of learning syntax in a textual language. This SRC poster summarizes the design and implementation of these languages. We also briefly introduce initial work on integrating an accessibility tool to allow children with disabilities to explore these opportunities.",
        "keywords": "visual programming language; sound processing; media computation; image processing; blockly",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2851058"
    },
    {
        "title": "Programming as a performance: Live-streaming and its implications for computer science education",
        "abstract": "This article discusses an emerging phenomenon of streaming programming to a live audience who in turn can interact with the streamer. In essence, this means broadcasting the programming environment and typically a web camera feed of the streamer to viewers. Streaming programming bears many similarities with live-streaming playing of video games, which has become extremely popular among gamers over the recent years. In fact, streaming programming often use the same web services as streaming gaming, and the audiences overlap.In this article, we describe this novel approach to programming and situate it in the broader context of computer science education. To gain a deeper insight into this phenomena, we analyzed viewer discussions during a particular programming stream broadcasted during a game programming competition. Finally, we discuss the benefits this approach could offer to computer science education.",
        "keywords": "streaming; online communities; game-based learning; computer science education",
        "released": 2017,
        "link": "https://doi.org/10.1145/3059009.3059035"
    },
    {
        "title": "Providing data on financial results of public companies enriched with provenance for OBInvest",
        "abstract": "Financial Literacy (FL) initiatives, aimed at young people in formal or informal learning spaces, are defended and implemented in several countries, being encouraged since 2005 by the Organization for Economic Co-operation and Development (OECD). In Brazil, the teaching and learning process in several areas has been stimulated through Academic Competitions generally called Knowledge Olympics, which are essentially student contests that aim to encourage, find talent and awaken interest in the field knowledge presented in the competition. It was precisely for this purpose that the Brazilian Investment Olympics (OBInvest) was born, aiming to democratize access to education and promote reflections on economic and financial issues, through a FL perspective for high school students from all over the country. One of OBInvest’s objectives is to help boosting the development of computational tools, aiming to provide easier access to fundamental data for decision-making in the field of finance. However, from the tools developed by OBInvest, it was noted that the creation of new educational tools would be enhanced through the use of datasets enriched with provenance and aligned with FAIR principles. This work aims to offer a computational strategy based on data science techniques, which is easy to use and also provides curated data series through a reproducible pipeline, using open data on financial reports from publicly listed Brazilian companies, provided by the Brazilian Security and Exchange Commission, called Comissão de Valores Mobiliarios (CMV). During the exploration of related works, we found just a few academic works that use CVM data with little expressive results, which motivated the development of a tool called DRE-CVM, that was supported by computational tools, with a focus on the Python language, Pandas library, the KNIME workflow platform, and Jupyter integrated development environments, running on the Anaconda3 platform over a Docker container. It’s also possible run this experiment in the Google Colabotory cloud environment. This processing it’s capable of executing reproducible pipelines and using curated, fairified, and annotated data with the retrospective source metadata of the financial statements of publicly traded Brazilian companies. The artifact uses pipelines that can be reused by students and other interested parties in finance to study the behaviors of a company’s time series results and thus introduce research on predicting future results. The last executable version of the DRE-CVM experiment can be accessed through Zenodo website at https://doi.org/10.5281/zenodo.7110653 and can be reproduced using a Docker Container available on DockerHub repository. Some improvements can be incorporated into the presented work, the main suggestions for future work are: (i) Perform more substantial analyses on the created dataset, such as predicting results based on the history of demonstration results; (ii) Recover other types of information made available by CVM, to be used during the activities of the Brazilian Investment Olympics; (iii) Adapt the docker image so that it can be executed in the My Binder cloud environment, aiming to improve reproducibility issues.",
        "keywords": "fair principles; financial literacy; provenance",
        "released": 2023,
        "link": "https://doi.org/10.1145/3543873.3587566"
    },
    {
        "title": "GenLine and GenForm: Two tools for interacting with generative language models in a code editor",
        "abstract": "A large, generative language model’s output can be influenced through well-designed prompts, or text-based inputs that establish textual patterns that the model replicates in its output [6]. These capabilities create new opportunities for novel interactions with large, generative language models. We present a macro system with two tools that allow users to invoke language model prompts as macros in a code editor. GenLine allows users to execute macros inline as they write code in the editor (e.g., “Make an OK button” produces the equivalent HTML). GenForm provides a form-like interface where the user provides input that is then transformed into multiple pieces of output at the same time (e.g., a description of web code is transformed into HTML, CSS, and JavaScript).",
        "keywords": "prompt programming; macros; generative models; code synthesis",
        "released": 2021,
        "link": "https://doi.org/10.1145/3474349.3480209"
    },
    {
        "title": "Extending computational thinking into information and communication technology literacy measurement: Gender and grade issues",
        "abstract": "As Information and Communication Technology (ICT) literacy education has recently shifted to fostering computing thinking ability as well as ICT use, many countries are conducting research on national curriculum and evaluation. In this study, we measured Korean students’ ICT literacy levels by using the national measurement tool that assesses abilities of the IT (Information Technology) area and the CT (Computational Thinking) area. A research team revised an existing ICT literacy assessment tool for the IT test and developed a new CT test environment in which students could perform actual coding through a web-based programming tool such as Scratch. Additionally, after assessing ICT literacy levels, differences in ICT literacy levels by gender and grade were analyzed to provide evidence for national education policies. Approximately 23,000 elementary and middle school students participated in the 2018 national assessment of ICT literacy, accounting for 1",
        "keywords": "secondary education; elementary education; computational thinking; ICT literacy; 21st century abilities",
        "released": 2021,
        "link": "https://doi.org/10.1145/3427596"
    },
    {
        "title": "Introduction to app inventor",
        "abstract": "App inventor is a web-based drag-and-drop programming environment for Android applications. This tutorial will introduce App Inventor to the participants, demonstrate App Inventor’s capabilities, and discuss ways App Inventor can be used with students.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2382887.2382892"
    },
    {
        "title": "Impact of infusing interactive and collaborative learning in teaching introductory programming in a dynamic class",
        "abstract": "In this era of smart devices, new technologies, gadgets, apps, and numerous systems and services available over online, teaching an introductory programming course by traditional lecture method faces challenges to draw student’s attention; especially in their freshman year. In this work, we discuss our experience in teaching an introductory CS course by infusing both interactive and collaborative learning in pedagogy so that students can learn using interactive platforms, tools, technologies, systems, and services as available to them and collaboration within and among groups. For interactive learning, students used an interactive programming environment (e.g. repl.it classroom) as well as online eBooks. We designed several in-class exercises, assignments, small lab-based projects with example codes and expected outputs, and unit tests by using built-in unit tests library. We also, in the middle of semester, introduced collaborative learning through teamwork on well-defined projects during the learning time and submitted at the end. The collaborations include use of basic task management tools and multi-player tool of repl.it that the students can critic, supplement, improve peer works and learn. To evaluate the impact of this infusion, a pre- and post-survey were conducted on student cohort in two different semesters. The initial evaluation of the survey results and performances (final project and final grades) show evidence to conclude that the proposed pedagogical approach increased student motivation and engagement and facilitated learning to entry-level computer science students.",
        "keywords": "visual learning; introductory programming; interactive programming; interactive learning; ebook; collaborative learning",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3372608"
    },
    {
        "title": "Model-driven engineering IDE for quality assessment of data-intensive applications",
        "abstract": "This article introduces a model-driven engineering (MDE) integrated development environment (IDE) for Data-Intensive Cloud Applications (DIA) with iterative quality enhancements. As part of the H2020 DICE project (ICT-9-2014, id 644869), a framework is being constructed and it is composed of a set of tools developed to support a new MDE methodology. One of these tools is the IDE which acts as the front-end of the methodology and plays a pivotal role in integrating the other tools of the framework. The IDE enables designers to produce from the architectural structure of the general application along with their properties and QoS/QoD annotations up to the deployment model. Administrators, quality assurance engineers or software architects may also run and examine the output of the design and analysis tools in addition to the designer in order to assess the DIA quality in an iterative process.",
        "keywords": "quality-assessment; model-driven engineering; ide; eclipse; data-intensive technologies",
        "released": 2017,
        "link": "https://doi.org/10.1145/3053600.3053633"
    },
    {
        "title": "CS education infrastructure for all: Interoperability for tools and data analytics (abstract only)",
        "abstract": "CS Education makes heavy use of online educational tools like IDEs, Learning Management Systems, eTextbooks, interactive programming environments, and other smart content. Instructors and students would benefit from greater interoperability between tools. CS Ed researchers increasingly make use of the large collections of data generated by click streams coming from them. However, we all face barriers that slow progress: (1) Educational tools do not integrate well. (2) Information about CS learning process and outcome data generated by one system is not compatible with that from other systems. (3) CS problem solving and learning (e.g., coding solutions) is different from the type of data (discrete answers to questions or verbal responses) that current educational data mining focuses on. This BOF will discuss ways that we might support and better coordinate efforts to build community and capacity among CS Ed researchers, data scientists, and learning scientists toward reducing these barriers. CS Ed infrastructure should support broader re-use of innovative learning content that is instrumented for rich data collection, formats and tools for analysis of learner data, and best practices to make large collections of learner data available to researchers. Achieving these goals requires engaging a large community of researchers to define, develop, and use critical elements of this infrastructure to address specific data-intensive research questions.",
        "keywords": "student analytics; smart content; interoperability; infrastructure; computer science education research; LTI",
        "released": 2018,
        "link": "https://doi.org/10.1145/3159450.3162177"
    },
    {
        "title": "Extracting code segments and their descriptions from research articles",
        "abstract": "The availability of large corpora of online software-related documents today presents an opportunity to use machine learning to improve integrated development environments by first automatically collecting code examples along with associated descriptions. Digital libraries of computer science research and education conference and journal articles can be a rich source for code examples that are used to motivate or explain particular concepts or issues. Because they are used as examples in an article, these code examples are accompanied by descriptions of their functionality, properties, or other associated information expressed in natural language text. Identifying code segments in these documents is relatively straightforward, thus this paper tackles the problem of extracting the natural language text that is associated with each code segment in an article. We present and evaluate a set of heuristics that address the challenges of the text often not being colocated with the code segment as in developer communications such as online forums.",
        "keywords": "text analysis; mining software repositories; information extraction; code snippet description",
        "released": 2017,
        "link": "https://doi.org/10.1109/MSR.2017.10"
    },
    {
        "title": "Applicative information system for the web environment",
        "abstract": "Applicative information system for the web environment implemented on the basis of the computing system of general purpose, on the basis of a programming language of high level LISP with its immersing in the combinatory environment in basis K, S with possible hardware support of combinators of basis is offered. Environment levels are considered: Interface, Combinatory abstract machine, as a support basic element applicative programming environment, System level, Processor K, S - level of hardware units K, S and their conjugation to the personal computer, the circuit of the extension of a programming environment for creation of hardware support of basis K, S: LISP – K, S - the Assembler – the Hardware reducers K, S.",
        "keywords": "information system; combinatory basis; combinator; applicative",
        "released": 2011,
        "link": "https://doi.org/10.1145/2077489.2077515"
    },
    {
        "title": "Gibber: Abstractions for creative multimedia programming",
        "abstract": "We describe design decisions informing the development of Gibber, an audiovisual programming environment for the browser. Our design comprises a consistent notation across modalities in addition to high-level abstractions affording intuitive declarations of multimodal mappings, unified timing constructs, and rapid, iterative reinvocations of constructors while preserving the state of audio and visual graphs. We discuss the features of our environment and the abstractions that enable them. We close by describing use cases, including live audiovisual performances and computer science education.",
        "keywords": "web; multimodal programming; live coding; javascript; graphics; creative coding; audio",
        "released": 2014,
        "link": "https://doi.org/10.1145/2647868.2654949"
    },
    {
        "title": "Computing infrastructure and curriculum design for introductory data science",
        "abstract": "The goal of this workshop is to equip educators with concrete information on content and infrastructure for designing and painlessly running a modern data science course. This is a three-part workshop. Part 1 will outline a curriculum for an introductory data science course and discuss pedagogical decisions that go into the choice of topics and concepts as well as the choice of programming language (R) and syntax (primarily tidyverse), and the emphasis on literate programming for reproducibility (with R Markdown). Part 2 will discuss infrastructure choices around teaching data science with R: RStudio as an integrated development environment, cloud-based access with RStudio Cloud and Server, version control with Git, and collaboration with GitHub. Part 3 will focus on classroom management on GitHub (with ghclass). Workshop attendees will work through several exercises from the course and get first-hand experience with using the tool-chains and techniques described above. While the workshop content will focus on usage of R, many of the pedagogical takeaways will be language agnostic. All workshop content, including teacher facing documentation and student facing course materials, will also be available to participants via datasciencebox.org. Please bring a laptop with you.",
        "keywords": "version control; reproducibility; r; pedagogy; data science",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287556"
    },
    {
        "title": "OpenHTML: Designing a transitional web editor for novices",
        "abstract": "We describe the initial design rationale and early findings from studies of a web editor for beginners called openHTML. We explain our strategy of transitional design that views web editors as a part of a complex socio-technical system that spans multiple tools, practices, and actors. Our goal is to create a toolkit that can engage beginners in meaningful activities now and prepare them for more sophisticated activities in the future.",
        "keywords": "web development; learner-centered design; code editors",
        "released": 2013,
        "link": "https://doi.org/10.1145/2468356.2468690"
    },
    {
        "title": "Implementing real-time collaboration in TouchDevelop using AST merges",
        "abstract": "Collaborating on a piece of code is notoriously difficult when the number of people involved goes above 1. In particular, every computer programmer dreads the \"merge conflict\", a brutal, unforgiving experience, where they must reconcile their changes with someone else’s. If offline collaboration is already so painful, real-time collaboration seems even less of an option. It turns out, though, that by reasoning on changes at the level of the program AST, rather than the program text, we can devise a new conflict-free merge algorithm. The algorithm is particularly well-suited to real-time collaboration: we implemented it in the TouchDevelop web programming environment and dub the algorithm diffTree.",
        "keywords": "diff; collaborative editing; Merge",
        "released": 2015,
        "link": "https://doi.org/10.1145/2846661.2846672"
    },
    {
        "title": "Towards the web of applications: Incorporating end user programming into the web 2.0 communities",
        "abstract": "The Web is evolving from the Web of documents to the Web of applications. Web 2.0 communities need end-user programming tools to create interactive applications according to their skills and domain of interest. However, due to the different domains of programming in different communities, providing a generic EUP tool to all communities is not possible. We aim at encapsulating development of domain-oriented EUP tools as a community-based effort-taking place at two layers: (i) among different communities, and (ii) inside a particular community. Accordingly, we suggest a domain-independent model and its respective Web-based infrastructure to supports different online communities to create and appropriate end user development tools for building interactive artifacts collaboratively.",
        "keywords": "web-based applications; web 2.0; interactive applications; end-user programming; community-based domain construction",
        "released": 2009,
        "link": "https://doi.org/10.1145/1595836.1595839"
    },
    {
        "title": "DBSnap++: Creating data-driven programs by snapping blocks",
        "abstract": "A key development in Computer Science Education has been the introduction of block-based programming environments where programs are created by connecting blocks and the focus is on the program’s logic instead of its syntax. Most of these environments support conventional (imperative) programming instructions. More recently, some systems have been proposed to enable the specification of database queries. While these two types of environments have been independently studied, there is significantly less work on the development and study of integrated environments that allow the creation of complete data-driven programs (real-world like programs that integrate conventional instructions and database queries). This paper introduces DBSnap++, a web-based environment that enables the specification of dynamic data-driven programs. DBSnap++ supports the specification of intuitive database query trees, a new type of list that dynamically gets its content executing a database query, and programs that generate different results when the underlying data changes. This paper presents DBSnap++’s design and implementation details, an array of programs to demonstrate how it can be effectively used as a learning tool, and a thorough comparison with other environments. DBSnap++ is publicly available and aims to enable learners to fully understand and utilize the capabilities of data-driven programs.",
        "keywords": "query languages; databases curricula; Data-driven programs",
        "released": 2018,
        "link": "https://doi.org/10.1145/3197091.3197114"
    },
    {
        "title": "Online detection of effectively callback free objects with applications to smart contracts",
        "abstract": "",
        "keywords": "Smart contracts; Program analysis; Modular reasoning",
        "released": 2017,
        "link": "https://doi.org/10.1145/3158136"
    },
    {
        "title": "Understanding how work habits influence student performance",
        "abstract": "Understanding the relationship between a student’s broader work habits and their performance, particularly on open-ended programming assignments, is key towards being able to guide students towards success. In spite of this, most evidence of student behavior and its relationship to performance is anecdotal. The advent of large-scale courses which use online tools for delivering course content, monitoring the programming environment, and providing automatic feedback as well as grading now makes it possible to dive into the data and develop data-driven methods for understanding how a student’s approach to an assignment—from their first exposure to the description of the problem to their final submission of their completed assignment—influences their final performance.This study is a first look at a subset of the data collected from a project-based, online, upper-level course on cloud computing. We examine three raw data streams which include information on the time students spend on reading the project write-up, the timing, grades, and number of submissions they make, and the cloud resources used (both time and cost) in solving the assignment. Using these and several synthetic metrics we were surprised to find that there are few behaviors that are highly correlated to student success. Instead, we find that there is a strong correlation between students who continually apply consistent behaviors over the course of the semester to good final performance in the course. From this we use LASSO to create a predictor (adjusted R2=.48) of final performance based on two kinds of consistency measures across 15 metrics.",
        "keywords": "work habits; student performance; project-based learning; online education; learning analytics; educational data mining",
        "released": 2019,
        "link": "https://doi.org/10.1145/3304221.3319757"
    },
    {
        "title": "CODECAST: An innovative technology to facilitate teaching and learning computer programming in a c language online course",
        "abstract": "This paper introduces the CODECAST tool: an in-browser C language interpreter, paired with an event and voice recorder and player that facilitates teaching and learning to program by synchronizing audio with source code edition, visualization, step by step execution and testing.",
        "keywords": "teaching; programming; online learning; mooc; code visualization; code test; code execution; code editor; code edition; audio",
        "released": 2017,
        "link": "https://doi.org/10.1145/3051457.3053970"
    },
    {
        "title": "CSinParallel: Using WebMapReduce to teach parallel computing concepts, hands-on (abstract only)",
        "abstract": "Map-reduce computation is the on-ramp to data-intensive cloud computing, and arguably the most widely deployed form of parallel/distributed computing. Participants will carry out exercises designed for students at CS1, intermediate, and advanced levels that introduce data-intensive scalable computing concepts using WebMapReduce (WMR), a simplified open-source interface to the dominant Hadoop map-reduce programming environment. WMR supports programming in a choice of languages including Python, Java, C++, and C#. Besides a hands-on experience with introductory teaching materials, the workshop includes an overview of teaching advanced map-reduce programming using WMR, and a comparison of WMR to direct Hadoop programming. All materials will reside on csinparallel.org, and the demonstration WMR system is reservable for participants’ courses. Intended audience: CS instructors. Web-enabled laptop required.",
        "keywords": "wmr; webmapreduce; parallelism; parallel design patterns; parallel computing; parallel and distributed computing; map-reduce; exemplars; education; distributed computing; design patterns; curriculum; csinparallel; cs1; advanced courses",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2844688"
    },
    {
        "title": "Talktic: A development environment for pervasive computing applications",
        "abstract": "Talktic is a platform for the easy production of entertainment content developed under the keyword of \"pervasive computing.\" The Talktic platform consists of runtime environment, library, and development environment to support applications using an MCU board, personal computer, and network. It uses a virtual machine in the runtime environment and provides a programming environment and library based on a lightweight scripting language for easy development of entertainment content. The linkage with web services and the high degree of compatibility for the virtual machine and scripts are expected to generate new forms of entertainment content.",
        "keywords": "simplicity; internet networking media; design works",
        "released": 2008,
        "link": "https://doi.org/10.1145/1501750.1501758"
    },
    {
        "title": "Truenorth ecosystem for brain-inspired computing: Scalable systems, software, and applications",
        "abstract": "This paper describes the hardware and software ecosystem encompassing the brain-inspired TrueNorth processor - a 70mW reconfigurable silicon chip with 1 million neurons, 256 million synapses, and 4096 parallel and distributed neural cores. For systems, we present a scale-out system loosely coupling 16 single-chip boards and a scale-up system tightly integrating 16 chips in a 4  4 configuration by exploiting TrueNorth’s native tiling. For software, we present an end-to-end ecosystem consisting of a simulator, a programming language, an integrated programming environment, a library of algorithms and applications, firmware, tools for deep learning, a teaching curriculum, and cloud enablement. For the scale-up systems we summarize our approach to physical placement of neural network, to reduce intra- and inter-chip network traffic. The ecosystem is in use at over 30 universities and government/corporate labs. Our platform is a substrate for a spectrum of applications from mobile and embedded computing to cloud and supercomputers.",
        "keywords": "",
        "released": 2016,
        "link": "https://dl.acm.org/doi/10.5555/3014904.3014920"
    },
    {
        "title": "A visual programming environment for learning distributed programming",
        "abstract": "This paper introduces NetsBlox, a visual programming environment for learning distributed programming principles. Extending both the visual formalism and open source code base of Snap!, NetsBlox provides two accessible distributed programming abstractions to simplify the process of creating networked applications: message passing and Remote Procedure Calls (RPC). Messaging passing allows NetsBlox applications to send data to other connected NetsBlox clients. Remote Procedure Calls enable seamless integration of third party services, such as Google Maps, weather, traffic and other public domain data sources, into NetsBlox applications. Other RPCs help coordinating distributed clients which may be difficult for novice programmers allowing the user to more quickly create captivating and sophisticated applications. These abstractions empower users to develop networked programs, including multi-player games and client-server applications. By providing networking support, NetsBlox not only allows users to learn distribute programming concepts but also makes programming more engaging by incorporating diverse services available on the web.",
        "keywords": "visual programming; snap!; distributed programming; computer science education",
        "released": 2017,
        "link": "https://doi.org/10.1145/3017680.3017741"
    },
    {
        "title": "Clerk: Moldable live programming for clojure",
        "abstract": "Clerk is an open source Clojure programmer’s assistant that builds upon the traditions of interactive and literate programming to provide a holistic moldable development environment. Clerk layers static analysis, incremental computation, and rich browser-based graphical presentations on top of a Clojure programmer’s familiar toolkit to enhance their workflow.",
        "keywords": "notebooks; moldable development; live programming; literate programming; lisp; clojure",
        "released": 2023,
        "link": "https://doi.org/10.1145/3594671.3594682"
    },
    {
        "title": "Stories from the scratch community: Connecting with ideas, interests, and people",
        "abstract": "This special session aims to provoke discussion about new strategies for engaging young people in computer programming, drawing on experiences of educators and young people using the Scratch programming environment and online communities. The session will combine several different formats, including research presentations and analysis by two members of the team that develops and supports Scratch, short presentations and demonstrations by five educators and young people working with Scratch, and discussions among audience participants.",
        "keywords": "scratch; programming; learning; education; computational thinking; community",
        "released": 2013,
        "link": "https://doi.org/10.1145/2445196.2445336"
    },
    {
        "title": "Retention of flow: Evaluating a computer science education week activity",
        "abstract": "High profile computer science education events such as the Hour of Code can reach millions of students but without proper evaluation it is not clear what motivational and educational consequences the participation has. If, for instance, participants’ levels of motivation towards the end of an hour long activity are significantly fading, then their perception of programming to be \"hard and boring\" may actually get reinforced. By simply measuring how far participants progressed with their projects we have been able to collect retention data from thousands of participants in a way that allows us to interpret these data in terms of not only cognitive but also technical and practical activity challenges. Inflection points overlaying a negative exponential retention distribution serve as indicators of these challenges with potential impact on Flow. Retention of Flow is an evaluation approach to analyze computer science education activities, including interactive tutorials and online programming environments, with respect to cognitive as well as affective challenges.",
        "keywords": "retention; hour of code; flow; computer science education week; computer science education",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2844597"
    },
    {
        "title": "Measuring the usability and capability of app inventor to create mobile applications",
        "abstract": "MIT App Inventor is a web service that enables users with little to no previous programming experience to create mobile applications using a visual blocks language. We analyze a sample of 5,228 random projects from the corpus of 9.7 million and group projects by functionality. We then use the number of unique blocks in projects as a metric to better understand the usability and realized capability of using App Inventor to implement specific functionalities. We introduce the notion of a usability score and our results indicate that introductory tutorials heavily influence the usability of App Inventor to implement particular functionalities. Our findings suggest that the sequential nature of App Inventor’s learning resources results in users realizing only a portion of App Inventor’s capabilities and propose improvements to these learning resources that are transferable to other programming environments and tools.",
        "keywords": "Visual Languages; Quantitative Study; Mobile Computing; End-User Programming; Computer Science Education",
        "released": 2015,
        "link": "https://doi.org/10.1145/2824823.2824824"
    },
    {
        "title": "Modelling and managing deployment costs of microservice-based cloud applications",
        "abstract": "We present an approach to model the deployment costs, including compute and IO costs, of Microservice-based applications deployed to a public cloud. Our model, which we dubbed CostHat, supports both, Microservices deployed on traditional IaaS or PaaS clouds, and services that make use of novel cloud programming paradigms, such as AWS Lambda. CostHat is based on a network model, and allows for what-if and cost sensitivity analysis. Further, we have used this model to implement tooling that warns cloud developers directly in the Integrated Development Environment (IDE) about certain classes of potentially costly code changes. We illustrate our work based on a case study, and evaluate the CostHat model using a standalone Python implementation. We show that, once instantiated, cost calculation in CostHat is computationally inexpensive on standard hardware (below 1 ms even for applications consisting of thousand services and endpoints). This enables its use in real-time for developer tooling which continually re-evaluates the costs of an application in the background, while the developer is working on the code.",
        "keywords": "",
        "released": 2016,
        "link": "https://doi.org/10.1145/2996890.2996901"
    },
    {
        "title": "User-generated variables: Streamlined interaction design for feature requests and implementations",
        "abstract": "Programmers write source code that compiles to programs, and users execute the programs to benefit from their features. While issue-tracking systems help communication between these two groups of people, feature requests have usually been written in text with optional figures that follows community guidelines and needs human interpretation to understand what to implement in which part of the source code. To make this process more direct, intuitive, and efficient, a streamlined interaction design called \"User-Generated Variables (UGV)\" is proposed. First, the users can declare parameters that they want to tweak in existing programs without reading or understanding the source code. Then, the system turns the proposal into variable declarations in the relevant part of the source code. Finally, the programmers are notified of the proposal and can implement the actual features to reflect changes in the variable value. The proposed interaction is implemented in two existing Web-based Integrated Development Environments, and its user experience is briefly tested with eight users and programmers. Its technical requirements, limitations, and potentials are discussed. The content of this paper with live examples is available at http://junkato.jp/ugv.",
        "keywords": "programming experience; live programming; integrated development environment; User-generated content (UGC)",
        "released": 2017,
        "link": "https://doi.org/10.1145/3079368.3079403"
    },
    {
        "title": "Yottos operating system connecting low-power devices with high-level programming",
        "abstract": "We present Yottos, an event driven operating system for wireless embedded devices that reduces energy consumption by coalescing tasks into workloads with similar resource requirements thereby reducing time and energy consumed from power cycling peripherals. With Yottos we target a different group of programmers than the ones well-versed in embedded C, TinyOS and Contiki, namely web and app developers who on one hand are familiar with event driven programming in the form of user interaction events, but on the other have no experience with low-level hardware access. We trade off memory footprint (both data and code) in support of a programming environment more akin to iOS and Android development by supporting Objective-C and C/C++.",
        "keywords": "",
        "released": 2014,
        "link": "https://doi.org/10.1145/2668332.2668360"
    },
    {
        "title": "Using an LLM to help with code understanding",
        "abstract": "Understanding code is challenging, especially when working in new and complex development environments. Code comments and documentation can help, but are typically scarce or hard to navigate. Large language models (LLMs) are revolutionizing the process of writing code. Can they do the same for helping understand it? In this study, we provide a first investigation of an LLM-based conversational UI built directly in the IDE that is geared towards code understanding. Our IDE plugin queries OpenAI’s GPT-3.5-turbo model with four high-level requests without the user having to write explicit prompts: to explain a highlighted section of code, provide details of API calls used in the code, explain key domain-specific terms, and provide usage examples for an API. The plugin also allows for open-ended prompts, which are automatically contextualized to the LLM with the program being edited. We evaluate this system in a user study with 32 participants, which confirms that using our plugin can aid task completion more than web search. We additionally provide a thorough analysis of the ways developers use, and perceive the usefulness of, our system, among others finding that the usage and benefits differ between students and professionals. We conclude that in-IDE prompt-less interaction with LLMs is a promising future direction for tool builders.",
        "keywords": "",
        "released": 2024,
        "link": "https://doi.org/10.1145/3597503.3639187"
    },
    {
        "title": "Semantic mashup with the online IDE WikiNEXT",
        "abstract": "The proposed demonstration requests DBPedia.org, gets the results and uses them to populate wiki pages with semantic annotations using RDFaLite. These annotations are persisted in a RDF store and we will show how this data can be reused by other applications, e.g. for a semantic mashup that displays all collected metadata about cities on a single map page. It has been developed using WikiNEXT, a mix between a semantic wiki and a web-based IDE. The tool is online , open source ; screencasts are available on YouTube (look for \"WikiNext\").",
        "keywords": "wiki; web of data; web based IDE",
        "released": 2014,
        "link": "https://doi.org/10.1145/2567948.2577010"
    },
    {
        "title": "Educational programming systems for learning at scale",
        "abstract": "Learning programming at scale underlies computer science education ranging from basic programming to advanced software engineering topics. There are strong needs of providing effective system supports for learning programming at scale. Among various desirable characteristics of such system supports, system supports shall allow students to write programs via an online Integrated Development Environment (IDE), allow students to get feedback on how they perform on the given programming exercises, etc. To aim for such effective system supports for learning programming at scale, research teams from Peking University have developed two systems: POP (denoting Peking University Online Programming System) and POJ (denoting Peking University Online Judge System). These two systems have achieved high impact among students around the world (especially those in China). In this paper, we present the overview of the two systems, along with our ongoing and future work on extending the systems for achieving higher effectiveness in supporting learning programming at scale.",
        "keywords": "programming systems; online ide",
        "released": 2014,
        "link": "https://doi.org/10.1145/2556325.2567868"
    },
    {
        "title": "Discovering code dependencies by harnessing developer’s activity",
        "abstract": "Monitoring software developer’s interactions in an integrated development environment is sought for revealing new information about developers and developed software. In this paper we present an approach for identifying potential source code dependencies solely from interaction data. We identify three kinds of potential dependencies and additionally assign them to developer’s activity as well, to reveal detailed task-related connections in the source code. Interaction data as a source allow us to identify these candidates for dependencies even for dynamically typed programming languages, or across multiple languages in the source code. After first evaluations and positive results we continue with collecting data in professional environment of Web developers, and evaluating our approach.",
        "keywords": "task context; source code dependency; interaction data; implicit feedback; dynamic typing",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2819009.2819174"
    },
    {
        "title": "COPE: Vision for a change-oriented programming environment",
        "abstract": "Software engineering involves a lot of change as code artifacts are not only created once but maintained over time. In the last 25 years, major paradigms of program development have arisen – agile development with refactorings, software product lines, moving sequential code to multicore or cloud, etc. Each is centered on particular kinds of change; their conceptual foundations rely on transformations that (semi-) automate these changes.We are exploring how transformations can be placed at the center of software development in future IDEs, and when such a view can provide benefits over the traditional view. COPE, a Change-Oriented Programming Environment, looks at 5 activities: (1) analyze what changes programmers typically make and how they perceive, recall, and communicate changes, (2) automate transformations to make it easier to apply and script changes, (3) develop tools that compose and manipulate transformations to make it easier to reuse them, (4) integrate transformations with version control to provide better ways for archiving and understanding changes, and (5) develop tools that infer higher-level transformations from lower-level changes. Characterizing software development in terms of transformations is an essential step to take software engineering from manual development to (semi-) automated development of software.",
        "keywords": "",
        "released": 2016,
        "link": "https://doi.org/10.1145/2889160.2889208"
    },
    {
        "title": "Piloting computer science education week in mexico",
        "abstract": "Computer Science Education Week activities, featuring online? programming tools embedded with tutorials, report large participation numbers. However, to truly broaden participation, activities need to be made accessible in international contexts. In 2014, Tecnológico de Monterrey and Instituto de Innovación y Transferencia de Tecnologı́a de Nuevo León, modified the Scalable Game Design CS Ed Week activity to include a Mexican feasibility pilot study. The goal of the pilot was to broaden participation in Computer Science in Mexico by creating interest and demand in further activities, including launching of 2015 Mexico CS Ed Week. This paper reviews the initial results of this 2014 pilot, including the discussion of the unique challenges faced in this context, and examines efforts to make this activity more accessible and successful. In addition to pilot data highlighting future activity improvements, initial retention results show that despite challenges, Mexican students were able to effectively use the modified activity to create games on par with U.S. students.",
        "keywords": "international research; globalization of programming activities.; experience report; computer science education week; computer science education in mexico; computer science education; broadening participation",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2844598"
    },
    {
        "title": "Events-first programming in APP inventor",
        "abstract": "Events are a central concept in computer science. They are becoming more important with the prevalence of mobile and web platforms that use event-based programming. Yet, events are typically taught late in the CS curriculum – e.g., in a web programming or operating systems course. We have introduced events to CS0 students from day one using MIT App Inventor, a blocks-based programming environment that enables students to create apps for Android devices. This paper presents the system’s event-based model, along with typical coding problems and best-practice approaches for solving them. We advocate for increasing early emphasis on events in the CS curriculum.",
        "keywords": "",
        "released": 2014,
        "link": "https://dl.acm.org/doi/10.5555/2602724.2602739"
    },
    {
        "title": "LIMO: Learning programming using interactive map activities",
        "abstract": "Advances in geographic information, interactive two- and three-dimensional map visualization accompanied with the proliferation of mobile devices and location data have tremendously benefited the development of geo-educational applications. We demonstrate LIMO; a web-based programming environment that is centered around operations on interactive geographical maps, location-oriented data, and the operations of synthetic objects that move on the maps. LIMO materializes a low-cost open-ended environment that integrates interactive maps and spatial data (e.g., OpenStreetMap). The unique advantage of LIMO is that it relates programming concepts to interactive geographical maps and location data. LIMO offers an environment for students to learn how to program by providing: 1. An easy-to-program library of map and spatial operations, 2. High-quality interactive map graphics, and 3. Example programs that introduce users to writing programs in the LIMO environment.",
        "keywords": "interactive maps; computer programming education",
        "released": 2015,
        "link": "https://doi.org/10.1145/2820783.2820796"
    },
    {
        "title": "Live programming of mobile apps in app inventor",
        "abstract": "MIT App Inventor is a programming environment that lowers the barriers to creating mobile apps for Android devices, especially for people with little or no programming experience. App Inventor apps for a mobile device are constructed by arranging components with a WYSIWYG editor in a computer web browser, where the development computer is connected to the device by WiFi or USB. The behavior of the components is specified using a blocks-based graphical programming language. A key feature in making App Inventor accessible to beginning programmers is live programming: developers interact directly with the state of the evolving program as it is being constructed, and changes made in the web browser are realized instantaneously in the running app on the device. This paper describes the live programming features of App Inventor and explains how they are implemented.",
        "keywords": "mobile app development; live programming; interpretation; android",
        "released": 2014,
        "link": "https://doi.org/10.1145/2688471.2688482"
    },
    {
        "title": "SCoME: A web services composition modeling and engineering framework",
        "abstract": "To exploit the true potential of Web services, it is critical to develop technologies and tools for composing new services from existing ones. Indeed, to reduce development time and integration efforts, this process of service composition requires an effective development environment to facilitate quick and simple composition of Web services, and remains a key challenge to realize the true potential of Web services. While numerous composition approaches have been developed, very little has been done towards providing an Integrated Development Environment to ease the process of composition. In this context, this paper introduces a new incremental approach to service composition engineering and considers the composition global life-cycle, i.e. specifying, composing, verifying, deploying, monitoring, and analyzing to achieve a full governance of the composition.",
        "keywords": "",
        "released": 2013,
        "link": "https://doi.org/10.1109/WI-IAT.2013.67"
    },
    {
        "title": "Knowledge transfer in collaborative teams: Experiences from a two-week code camp",
        "abstract": "Software engineering has both technological and social dimensions. As development teams spanning across the globe are increasingly the norm and while the web enables massive online collaboration, there is a growing need for effective collaboration tools. In this paper, we describe experiences on collaborative programming as a tool for learning software development. To investigate the nature of collaboration in software engineering education, we arranged a two-week-long course experiment where students used a collaborative online integrated development environment to create different kinds of web services. We present lessons learned from the experiment and discuss how collaboration can act as a tool for knowledge transfer among learners.",
        "keywords": "Software engineerin education; Collaboration; Case study",
        "released": 2014,
        "link": "https://doi.org/10.1145/2591062.2591156"
    },
    {
        "title": "Redprint: Integrating API specific \"instant example\" and \"instant documentation\" display interface in IDEs",
        "abstract": "Software libraries for most of the modern programming languages are numerous, large and complex. Remembering the syntax and usage of APIs is a difficult task for not just novices but also expert programmers. IDEs (Integrated Development Environment) provide capabilities like autocomplete and intellisense to assist programmers; however, programmers still need to visit search engines like Google to find API (Application Program Interface) documentation and samples. This paper evaluates Redprint - a browser based development environment for PHP that integrates API specific \"Instant Example\" and \"Instant Documentation\" display interfaces. A comparative laboratory study shows that integrating API specific \"Instant Example\" and \"Instant Documentation\" display interfaces into a development environment significantly reduces the cost of searching and thus significantly reduces the time to develop software.",
        "keywords": "redprint; instant example display interface; instant documentation display interface; example centric programming",
        "released": 2011,
        "link": "https://doi.org/10.1145/2046396.2046408"
    },
    {
        "title": "WAPPEN: A web-based application framework for programming and its bison/flex plug-in",
        "abstract": "This poster presents an Eclipse RCP-based application framework named Wappen for learning programming, and especially, its plugin for Bison and Flex. In courses such as compiler construction and programming languages, learners have to use multiple languages. Time and e ort spent by learners on installation and configuration of programming environments are not negligible. Wappen provides an infrastructure on which teachers can arrange simple Web-based programming environments for various programming languages by writing plug-ins. Wappen for Oolong has been successfully used in our compiler construction lab, where Oolong is an assembly language for the Java Virtual Machine. This poster introduces Wappen for Bison/Flex that tries to help learners avoid pitfalls of Bison/Flex in some respects. It is planned to be put into practical use in our compiler construction lab this year.",
        "keywords": "web; programming languages; eclipse; compiler construction",
        "released": 2009,
        "link": "https://doi.org/10.1145/1562877.1563025"
    },
    {
        "title": "Building smartphone apps via HTML5, CSS, and JavaScript",
        "abstract": "HTML5 has become the new international web markup standard replacing XHTML and earlier versions of HTML. It has become the main web programming tool not only for traditional devices such as PC’s and laptops but also for emerging mobile devices such as tablets and smartphones (iPhone, Android, etc.). As a result, CS/IT/IS students are showing a keen interest in both this new HTML platform and developing applications for these new devices as the job market for expertise in these technologies is booming.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2168874.2168901"
    },
    {
        "title": "Fishtail: From task context to source code examples",
        "abstract": "Implementing software development tools as integrated development environment (IDE) plugins gives tools direct access to a range of useful representations of the program being created and can improve programmer efficiency. These benefits must be weighed against the effort to integrate the tool into the IDE, effort which may need to be repeated for each IDE targeted. In this paper, we introduce Fishtail, a prototype plugin for the Eclipse IDE, which assists programmers in discovering code examples and documentation on the web relevant to their current task. Fishtail uses a detailed history of programmer interactions with the source code to automatically determine relevant web resources. We describe the key factors that make it attractive to implement Fishtail as a plugin, and the requirements Fishtail imposes on the plugin/IDE interface. To reach a broader user base and understand how well our tool supports different programming styles and IDE architectures, we have recently begun investigating how to make a version of Fishtail available in the Visual Studio IDE. We outline some of the challenges we face in trying to reuse code from the original Eclipse plugin.",
        "keywords": "program views; interaction history; example-centric development; development environment; degree-of-interest",
        "released": 2011,
        "link": "https://doi.org/10.1145/1984708.1984722"
    },
    {
        "title": "Snap! (Build your own blocks) (abstract only)",
        "abstract": "This workshop is for high school and college teachers of general-interest (\"CS 0\") computer science courses, especially the AP CS: Principles course. SNAP! (Build Your Own Blocks) is a free, browser-based, graphical, drag-and-drop language inspired by Scratch. The beauty of the Scratch programming environment, designed for 8-14 year olds, is that it makes abstract concepts more concrete and understandable to a broader audience. SNAP! extends Scratch to support older learners (14-20) with built-in named procedures (thus recursion), procedures as data (thus higher order functions), structured lists, and sprites as first class objects with inheritance.Participants will learn SNAP! hands-on. See http://snap.berkeley.edu for details. Network connected laptop required.",
        "keywords": "visual programming; snap!; computer science education",
        "released": 2014,
        "link": "https://doi.org/10.1145/2538862.2539022"
    },
    {
        "title": "CASE for web sites: Towards an integration of traditional case concepts and novel development tools",
        "abstract": "",
        "keywords": "tools; requirements; Internet-based systems; CASE",
        "released": 1998,
        "link": "https://doi.org/10.1145/330560.331079"
    },
    {
        "title": "Pythy: Improving the introductory python programming experience",
        "abstract": "Pythy is a web-based programming environment for Python that eliminates software-related barriers to entry for novice programmers, such as installing an IDE or the Python runtime. Using only a web browser, within minutes students can begin writing code, watch it run, and access support materials and tutorials. While there are a number of web-based Python teaching tools, Pythy differs in several respects: it manages student assignment work, including deadlines, turn-in, and grading; it supports live, interactive code examples that instructors can write and students can explore; it provides auto-saving of student work in the cloud, with full, transparent version control; and it supports media-computation-style projects that manipulate images and sounds. Pythy provides a complete ecosystem for student learning, with a user interface that follows a more familiar web browsing model, rather than a developer-focused IDE interface. An evaluation compares student perceptions of Pythy in relation to JES, another student-friendly beginner Python environment. Classroom experiences indicate that Pythy does reduce the novice obstacles that it aims to address.",
        "keywords": "web-based; skulpt; python; on-line; media computation; interactive; browser",
        "released": 2014,
        "link": "https://doi.org/10.1145/2538862.2538977"
    },
    {
        "title": "Exploring learning analytics for computing education (abstract only)",
        "abstract": "Computing educators have become increasingly interested in learning analytics, which involves collecting and analyzing data on students’ learning processes and outcomes for the purpose of improving learning and instructional practices. A variety of computer programming environments enable the automated collection of log data on students’ programming processes. In addition, log data on students’ online social behavior can be easily collected. All of these data can be analyzed alongside data on students’ learning outcomes in order to identify correlations between learning processes and outcomes, and ultimately to better tailor instruction to students’ needs. This BOF will provide a platform for discussing the emerging field of learning analytics within the context of computing education. The following questions will serve as a starting point for our discussions: (1) What types of data should we be collecting on computing students’ (2) How can we best analyze these data in order to gain meaningful insights into students’ learning processes? (3) How can we design effective instructional interventions based on the data we collect and analyze?",
        "keywords": "learning management systems; learning analytics; computer science education",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2850492"
    },
    {
        "title": "MEX interfaces: Automating machine learning metadata generation",
        "abstract": "Despite recent efforts to achieve a high level of interoperability of Machine Learning (ML) experiments, positively collaborating with the Reproducible Research context, we still run into problems created due to the existence of different ML platforms: each of those have a specific conceptualization or schema for representing data and metadata. This scenario leads to an extra coding-effort to achieve both the desired interoperability and a better provenance level as well as a more automatized environment for obtaining the generated results. Hence, when using ML libraries, it is a common task to re-design specific data models (schemata) and develop wrappers to manage the produced outputs. In this article, we discuss this gap focusing on the solution for the question: \"What is the cleanest and lowest-impact solution, i.e., the minimal effort to achieve both higher interoperability and provenance metadata levels in the Integrated Development Environments (IDE) context and how to facilitate the inherent data querying task?\". We introduce a novel and low-impact methodology specifically designed for code built in that context, combining Semantic Web concepts and reflection in order to minimize the gap for exporting ML metadata in a structured manner, allowing embedded code annotations that are, in run-time, converted in one of the state-of-the-art ML schemas for the Semantic Web: MEX Vocabulary.",
        "keywords": "Reproducible Research; Reflection; Provenance; Metadata; Machine Learning Outputs; MEX; Interoperability; Annotation",
        "released": 2016,
        "link": "https://doi.org/10.1145/2993318.2993320"
    },
    {
        "title": "MOCSIDE: An open-source and scalable online IDE and auto-grader for computer science education",
        "abstract": "Programming is learned through practice, with said practice in introductory programming courses often translating to a prohibitively large number of assignments, increasing the grading workload for faculty and/or teaching assistants. In short, this is unsustainable. Several publishers and a few notable companies have provided meritable auto-grading solutions, although most are plagued with problems including minimal problem sets, limited customization options, high cost, and at times even a disconnect with the pedagogical needs of academia. This poster presents our newly-developed web application, MOCSIDE, an open-source and scalable online IDE and auto-grader for computer science education. Results indicate a positive user experience from students and instructors alike, with cost savings, ease of use, and code collaboration highlighted as key features.",
        "keywords": "online ide; cs2; cs1; computer science education; auto-grading",
        "released": 2022,
        "link": "https://doi.org/10.1145/3478432.3499125"
    },
    {
        "title": "Designing ScratchJr: Support for early childhood learning through computer programming",
        "abstract": "ScratchJr is a graphical programming language based on Scratch and redesigned for the unique developmental and learning needs of children in kindergarten to second grade. The creation of ScratchJr addresses the relative lack of powerful technologies for digital creation and computer programming in early childhood education. ScratchJr will provide software for children to create interactive, animated stories as well as curricula and online resources to support adoption by educators. This paper describes the goals and challenges of creating a developmentally appropriate programming tool for children ages 5-7 and presents the path from guiding principles and studies with young children to current ScratchJr designs and plans for future work.",
        "keywords": "graphical programming; education; early childhood; STEM",
        "released": 2013,
        "link": "https://doi.org/10.1145/2485760.2485785"
    },
    {
        "title": "Situating computational thinking with big data: Pedagogy and technology (abstract only)",
        "abstract": "As Computational Thinking becomes pervasive in undergraduate programs, new students must be educated in meaningful, authentic contexts that they find both motivating and relatable. I propose working with big data as a novel context for introductory programming, authentic given its importance in diverse fields such as agriculture, history, and more. Big data is considered difficult to use because of its inherent technical obstacles. To overcome these difficulties, I introduce a new project: CORGIS - a \"Collection of Real-time, Giant, Interesting, Situated Datasets\". The CORGIS project comprises a collection of libraries that provide an interface to big data for students, architectures for rapidly enabling new datasets, and a web-based textbook platform for disseminating relevant course materials. This textbook features an online block-based programming environment, real-time collaborative text editing, and continuous server-side storage. In this poster, I describe the educational theory guiding this work, the novel technolgy created and deployed, and the initial, promising results.",
        "keywords": "Motivation; Computational Thinking; CORGIS; Big data",
        "released": 2015,
        "link": "https://doi.org/10.1145/2676723.2693616"
    },
    {
        "title": "Enabling static security vulnerability analysis in PHP applications for novice developers with SSVChecker",
        "abstract": "Web-based systems pervade our society, supporting business-critical applications frequently requesting/storing customer’s personal information, necessitating increasingly higher levels of information assurance. Novice web programmers, with little or no secure programming skills, unknowingly develop web applications ripe with security vulnerabilities, thus compromising the integrity of the application. As a result, a number of static analysis security tools have been developed to flag potential security vulnerabilities. Yet, these tools are difficult to use, divorced from the software integrated development environments (IDE) and remain unknown to novice developers. This paper contributes an Eclipse plugin that enables static analysis of PHP source code using existing tools directly within a common IDE to enable novice developers to build more secure web applications. We make two claims for the extension of SSVChecker. First, it seamlessly embeds into a common IDE making it easy/familiar to use for novice developers. Second, it provides functionality leveraging multiple tools to reduce reported false positives and better focus novice developers on potential security vulnerabilities. To demonstrate these claims, we use SSVChecker on a popular, open source, PHP-based web application with known security vulnerabilities.",
        "keywords": "static analysis; security auditing; secure programming",
        "released": 2014,
        "link": "https://doi.org/10.1145/2663761.2664213"
    },
    {
        "title": "WikiNEXT: A wiki for exploiting the web of data",
        "abstract": "This paper presents WikiNEXT, a semantic application wiki. WikiNEXT lies on the border between application wikis and modern web based IDEs (Integrated Development Environments) like jsbin.com, jsfiddle.net, cloud9ide.com, etc. It has been initially created for writing documents that integrate data from external data sources of the web of data, such as DBPedia.org or FreeBase.com, or for writing interactive tutorials (e.g. an HTML5 tutorial, a semantic web programming tutorial) that mix text and interactive examples in the same page. The system combines some powerful aspects from (i) wikis, such as ease of use, collaboration and openness, (ii) semantic web/wikis such as making information processable by machines and (iii) web-based IDEs such as instant development and code testing in a web browser. WikiNEXT is for writing documents/pages as well as for writing web applications that manipulate semantic data, either locally or coming from the web of data. These applications can be created, edited or cloned in the browser and can be used for integrating data visualizations in wiki pages, for annotating content with metadata, or for any kind of processing. WikiNEXT is particularly suited for teaching web technologies or for writing documents that integrate data from the web of data.",
        "keywords": "wikis; web2.0; web applications; semantic wikis; semantic web; knowledge management",
        "released": 2014,
        "link": "https://doi.org/10.1145/2554850.2554962"
    },
    {
        "title": "Demo: A programming cloud of smartphones",
        "abstract": "In this demonstration we present SmartLab1, an exciting experimental testbed of approximately 40+ real Android Smartphones, plus emulated devices, deployed at the Department of Computer Science building at the University of Cyprus. SmartLab provides a public, permanent testbed for the development and testing of smartphone network applications via an intuitive web-based interface. Registered users can upload and install Android executables (APKs) on a number of Android smartphones, capture their output, reboot the devices, create concurrent interactive jobs using MonkeyRunner scripts, interact with the remote devices and many other exciting features. SmartLab aims to facilitate research in smartphone network programming environments, communication protocols, system design, and applications.",
        "keywords": "system design; programming cloud; android smartphones",
        "released": 2012,
        "link": "https://doi.org/10.1145/2307636.2307686"
    },
    {
        "title": "Using camlp4 for presenting dynamic mathematics on the web: DynaMoW, an OCaml language extension for the run-time generation of mathematical contents and their presentation on the web",
        "abstract": "We report on the design and implementation of a programming tool, DynaMoW, to control interactive and incremental mathematical calculations to be presented on the web. This tool is implemented as a language extension of OCaml using Camlp4. Fragments of mathematical code written for a computer-algebra system as well as fragments of mathematical web documents are embedded directly and naturally inside OCaml code. A DynaMoW-based application is made of independent web services, whose parameter types are checked by the OCaml extension. The approach is illustrated by two implementations of online mathematical encyclopedias on top of DynaMoW.",
        "keywords": "web services; quotations; metaprogramming; mathematical encyclopedias; antiquotations",
        "released": 2011,
        "link": "https://doi.org/10.1145/2034773.2034809"
    },
    {
        "title": "Simplifying web programming",
        "abstract": "Modern web programming is plagued by a jungle of heterogeneous programming frameworks and lacks adequate abstractions for end-to-end rapid, structured, design and development. We studied the current problems faced by developers using an online survey, and found that integrating client-side interactivity with the back-end is a major source of inefficiency. Based on the reported issues, we developed a new programming environment, called WebNat, to reduce the burden of client-server programming. WebNat makes it easy to specify bindings of client-side views with server-side data and provides multiple abstractions that enable succinct specifications for interactive web applications. We conducted a user study to understand its usefulness and barriers to adoption. Our participants were able to learn and use WebNat in less than 2 hours showing minimal learning curve. We also discovered that although novices embrace the system readily, experience developers are more cautious about adopting a new web programming framework.",
        "keywords": "",
        "released": 2015,
        "link": "https://doi.org/10.1145/2723742.2723750"
    },
    {
        "title": "A wiki way of programming for the web of data",
        "abstract": "WikiNEXT is a wiki engine that enables users to write rapidly applications directly from the browser, in particular applications that can exploit the web of data. WikiNEXT relies on semantic web formalisms and technologies (RDF/RDFa lite) to describe wiki page content and embedded metadata, and to manipulate them (for example, using the SPARQL language). WikiNEXT is a mix between a web-based IDE (Integrated Development Environment) and a semantic wiki. It embeds several editors (a WYSIWYG editor, and an HTML/JavaScript editor + a JavaScript library manager) for coding in the browser, provides an API for exploiting semantic metadata, and uses a graph based data store and an object oriented database for persistence on the server side. It has been specially designed for writing online programming tutorials (i.e. an HTML5 tutorial, a semantic web tutorial on how to consume linked data, etc.), or more generally for developing web applications that can be mixed with more classical wiki documents (in fact all WikiNEXT pages are web applications). The tool is online, open source ; screencasts are available on YouTube (look for ’WikiNEXT’).",
        "keywords": "wikis; web applications; semantic wikis; semantic web; knowledge management",
        "released": 2014,
        "link": "https://doi.org/10.1145/2567948.2577349"
    },
    {
        "title": "CAMP: A standard for managing applications on a PaaS cloud",
        "abstract": "Cloud Application Management for Platforms (CAMP) is a standard that addresses the problem of portability of artifacts and interoperability of APIs in a Platform as a Service (PaaS) environment. It defines the artifacts and APIs that need to be offered by a PaaS to manage building, running, administering, monitoring and patching of applications in the cloud. This is a collaborative open standard that is being developed in OASIS. One of the goals for this effort is to allow developers, users, and vendors to create tools and services that interact with any conforming PaaS. The interoperability between platform clouds that CAMP offers means that a CAMP client such as an Integrated Development Environment (IDE) can target multiple clouds with a single common interface/implementation. In addition to various vendors, OpenStack Solum and Apache Brooklyn have both adopted CAMP and it is central to their design.",
        "keywords": "paas rest api; paas resource model; paas management; paas; cloud standard; cloud computing; camp",
        "released": 2014,
        "link": "https://doi.org/10.1145/2688130.2688131"
    },
    {
        "title": "Lost while searching: Difficulties in information seeking among end-user programmers",
        "abstract": "End-user programmers, those who write code but lack formal training in computer science, are often reliant on various tools such as API documentation or searching the Web for information in order to complete a specific task. This study examines the information foraging behaviors of a group of web and graphic designers engaged in a series of code modification tasks. We find that users were largely unsuccessful in their foraging activities, with few information seeking events resulting in noticeable changes to participants’ source code. Participants viewed remarkably few results generated by their queries and rarely refined queries multiple times. However, these kinds of activities were positively correlated with task success metrics. We conclude with a discussion of the study’s results and their implications on the design of future programming environments and search tools for end-user programmers.",
        "keywords": "search behaviors; novice programmers; information foraging; end-user programming",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2655780.2655801"
    },
    {
        "title": "Mocks, proxies, and transpilation as development strategies for web development",
        "abstract": "With the advent of HTML 5, we can now develop rich web apps that rival classical standalone apps. This richness together with the portability of web technologies, turned HTML 5 into a viable (and in the case of mobile - essential) solution to develop cross-platform apps. This possibility is heavily dependent on Javascript having acceptable performance, good testability, and a modern development environment. Despite its extensive use in creating highly interactive environments, most Javascript development environments currently use a compile/run paradigm. Similarly, testing is frequently tacked on, rather than being an integrated part of the development cycle. We propose PharoJS which leverages the Smalltalk IDE with a seamless transition from native Smalltalk tests, through proxied browser tests, to full browser-resident tests. We support the standard event-driven browser model and transpile Smalltalk code into efficient Javascript for execution in the browser. We further support testing - both manually and automatically - in a range of browsers to provide assured consistency upon deployment. In addition to transpiling the Smalltalk code to Javascript to perform tests in the browser, we can also run non-interactive tests within the Smalltalk environment. The unique feature we provide is the ability to run interactive tests largely within the Smalltalk IDE, so as to fully exploit the debugging and development environment, while the actual interaction occurs on the browser. We exhibit this new mode of development via a simple application.",
        "keywords": "",
        "released": 2016,
        "link": "https://doi.org/10.1145/2991041.2991051"
    },
    {
        "title": "End-user programming of web-native interactive applications",
        "abstract": "Web 2.0 has enabled Web users to create and share a variety of hyper-text based artifacts including embedded images, sound, and video on the Web. Creating Web-based interactive artifacts such as computer games, however, has remained a challenge: to end users due to the lack of end user programming tools; and to programmers due to the poor interactivity performance of the Web. With the emergence of HTML5 and improving performance of JavaScript engines, professional Web programmers have only just begun to develop Web-native interactive artifacts. Today’s standard Web technologies make the Web a hospitable platform for efficient interactive applications both for professional programmers and end-users. With proper support, in tools and languages, end-user programming of interactive applications is feasible. In this paper, we review the current state of Web application development and the possibilities and potential benefits of end-user programming on the Web. We will use a case study, AgentWeb, a Web-based end-user development environment, as a representative of interactive Web applications. It is based completely on open Web technologies, rather than on any proprietary technologies. Given that 2D graphic interactive applications may be developed and efficiently executed on the Web, we discuss some of the potential applications in educational settings, including individual and collaborative learning.",
        "keywords": "web programming; web native applications; web applications; open web; end-user programming; World Wide Web; HTML5",
        "released": 2011,
        "link": "https://doi.org/10.1145/2023607.2023610"
    },
    {
        "title": "PowerStation: Automatically detecting and fixing inefficiencies of database-backed web applications in IDE",
        "abstract": "Modern web applications are built using a myriad of software components, and each of them exposes different programming models (e.g., application logic expressed in an imperative language, database queries expressed using declarative SQL). To improve programmer productivity, Object Relational Mapping (ORM) frameworks have been developed to allow developers build web applications in an object-oriented manner. Despite such frameworks, prior work has found that developers still struggle in developing performant ORM-based web applications. This paper presents PowerStation, a RubyMine IDE plugin for optimizing web applications developed using the Ruby on Rails ORM. Using automated static analysis, PowerStation detects ORM-related inefficiency problems and suggests fixes to developers. Our evaluation using 12 real-world applications shows that PowerStation can automatically detects 1221 performance issues across them. A tutorial on using PowerStation can be found at https://youtu.be/rAV8CGuSj6k.",
        "keywords": "performance anti-patterns; database-backed applications; RubyMine Plugin; Object-Relational Mapping frameworks",
        "released": 2018,
        "link": "https://doi.org/10.1145/3236024.3264589"
    },
    {
        "title": "Japper: A comprehensive framework for streamlining jupyter-based scientific web application development",
        "abstract": "Jupyter Notebooks have been rapidly adopted by researchers across disciplines to perform scientific computing using its interactive and versatile data exploration and analysis capabilities. Furthermore, running Jupyter Notebooks in standalone web application mode has emerged as a fast and more sustainable way for researchers to develop and share scientific applications using a familiar programming language and development environment. However, significant challenges still exist in developing robust and user-friendly scientific applications using Jupyter Notebook due to development complexity and user interface limitations. This paper introduces Japper, a comprehensive Jupyter-based scientific web application development framework. Japper consists of a core toolkit, established best practices, and architectural patterns specifically tailored for the Jupyter ecosystem. It simplifies project initiation and expedites development workflows by providing intuitive interfaces, advanced front-end customization features, and streamlined deployment. Japper has been used in developing several scientific web applications in diverse fields. Two examples are described here to demonstrate its potential as a broadly applicable and effective application development framework.",
        "keywords": "Framework; Jupyter; Vue.js; Web applications",
        "released": 2024,
        "link": "https://doi.org/10.1145/3626203.3670594"
    },
    {
        "title": "Drag-and-drop refactoring: Intuitive and efficient program transformation",
        "abstract": "Refactoring is a disciplined technique for restructuring code to improve its readability and maintainability. Almost all modern integrated development environments (IDEs) offer built-in support for automated refactoring tools. However, the user interface for refactoring tools has remained largely unchanged from the menu and dialog approach introduced in the Smalltalk Refactoring Browser, the first automated refactoring tool, more than a decade ago. As the number of supported refactorings and their options increase, invoking and configuring these tools through the traditional methods have become increasingly unintuitive and inefficient. The contribution of this paper is a novel approach that eliminates the use of menus and dialogs altogether. We streamline the invocation and configuration process through direct manipulation of program elements via drag-and-drop. We implemented and evaluated this approach in our tool, Drag-and-Drop Refactoring (DNDRefactoring), which supports up to 12 of 23 refactorings in the Eclipse IDE. Empirical evaluation through surveys and controlled user studies demonstrates that our approach is intuitive, more efficient, and less error-prone compared to traditional methods available in IDEs today. Our results bolster the need for researchers and tool developers to rethink the design of future refactoring tools.",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2486788.2486792"
    },
    {
        "title": "Camp CyberGirls: Using a virtual world to introduce computing concepts to middle school girls",
        "abstract": "In this paper we report on the design and results of a one-week, residential summer camp experience that introduced computing concepts to middle school girls in the context of an online, multiplayer, virtual world known as the Curiosity Grid. In contrast to programming environments designed specifically as teaching tools to introduce children to programming, virtual world programming exposes novice learners to a more representative computer science experience. Students write real code and get real syntax errors when their code is not correct. They also design objects in a three-dimensional world where knowledge of mathematical concepts such as 3-D global and local coordinate systems, and 3-D transformations are important to the creation of objects and behaviors. Programming artifacts from the camp and feedback from the camp participants provide a strong argument that middle school girls can handle the challenge of this approach and even be enthusiastic about it.",
        "keywords": "virtual worlds; outreach; middle school girls; educational programming environments",
        "released": 2014,
        "link": "https://doi.org/10.1145/2538862.2538881"
    },
    {
        "title": "Design, develop and teach the second web programming course in computer science curriculum",
        "abstract": "In current Computer Science curriculum, teaching web programming courses has become a consensus. Web programming involves many web technologies. How to design and integrate these technologies into web programming courses is still a challenging task for web programming instructors in computer science program. Many universities have been offering one web programming course as an elective in their computer science curriculum. This paper presents our strategies and experiences to teach the second web programming course in CS curriculum. We answered some questions regarding what topics and technologies should be involved, what textbooks might be chosen, what programming environment needs to be set up to support the course, and what assignments and projects could be assigned for students. This paper intends to share some useful information and experience for other instructors teaching the second web programming course in Computer Science curriculum.",
        "keywords": "",
        "released": 2014,
        "link": "https://dl.acm.org/doi/10.5555/2591468.2591479"
    },
    {
        "title": "Mobile computational thinking with APP inventor 2",
        "abstract": "Computational Thinking Through Mobile Computing is an NSF-funded project for introducing students to computational thinking through creating mobile apps. In this hands-on workshop, which is targeted at undergraduate and secondary school computer science teachers, participants will develop Android apps using MIT App Inventor 2. This is a new version of the visual blocks-based programming environment with additional language features (local variables, improved handling of procedure and event parameters) and browser-based blocks editing. The workshop will focus on computational concepts relevant to mobile apps: event-based programming, location awareness, social computing, persistence and sharing, and leveraging the sensors and actuators of mobile devices. The workshop will also present pedagogical materials (lessons, tutorials, assignments), evaluation materials (blocks-based quizzes, surveys, project rubrics), and student projects. A laptop and gmail account are required for this workshop. Participants can borrow an Android device to use during the workshop, or they may use their own Android device if they have one.",
        "keywords": "",
        "released": 2014,
        "link": "https://dl.acm.org/doi/10.5555/2602724.2602729"
    },
    {
        "title": "WIPE: A programming environment for novices",
        "abstract": "This paper presents an overview of the design principles and the evaluation of a new programming environment, WIPE (Web Integrated Programming Environment), designed specifically to teach novices the fundamentals of programming. The environment is designed for use in secondary education as a first programming course, in order to help students become familiar with the main programming concepts.",
        "keywords": "web-based compiler; secondary education; programming and programming languages; interactive learning environment; e-learning",
        "released": 2005,
        "link": "https://doi.org/10.1145/1067445.1067479"
    },
    {
        "title": "Creating interactive web data applications with spreadsheets",
        "abstract": "While more and more data are available through web services, it remains difficult for end-users to create web applications that make use of these data without having to write complex code. We present Gneiss, a live programming environment that extends the spreadsheet metaphor to support creating interactive web applications that dynamically use local or web data from multiple sources. Gneiss closely integrates a spreadsheet editor with a web interface builder to let users demonstrate bindings between properties of web GUI elements and cells in the spreadsheet while working with real web service data. The spreadsheet editor provides two-way connections to web services, to both visualize and retrieve different data based on the user input in the web interface. Gneiss achieves rich interactivity without the need for event-based programming by extending the ’pull model’ of formulas that is familiar to the spreadsheet users. We use a series of examples to demonstrate Gneiss’s ability to create a variety of interactive web data applications.",
        "keywords": "web services; web applications; spreadsheets; mashups; live programming; end-user programming",
        "released": 2014,
        "link": "https://doi.org/10.1145/2642918.2647371"
    },
    {
        "title": "Collabode: Collaborative coding in the browser",
        "abstract": "Collaborating programmers should use a development environment designed specifically for collaboration, not the same one designed for solo programmers with a few collaborative processes and tools tacked on. This paper describes Collabode, a web-based Java integrated development environment built to support close, synchronous collaboration between programmers. We discuss three collaboration models in which participants take on distinct roles: micro-outsourcing to combine small contributions from many assistants; test-driven pair programming for effective pairwise development; and a mobile instructor connected to the work of many students. In particular, we report very promising preliminary results using Collabode to support micro-outsourcing.",
        "keywords": "outsourcing; collaboration",
        "released": 2011,
        "link": "https://doi.org/10.1145/1984642.1984658"
    },
    {
        "title": "Notional machines in a semester-long introductory physical computing high school unit",
        "abstract": "Notional machines i.e. pedagogical devices to communicate program execution play a key role in computing classrooms, especially within introductory settings [2, 5]. From machine-generated representations to classroom learning activities, a variety of notional machines have been examined in the field of computing education research. A more recent review [2] has also noted the adoption of multiple notional machines by instructors during a course or a unit to communicate a family of interconnected, computing concepts within a learning context. Despite notional machines considered as a signature pedagogy for computing education, very few accounts are based on classroom observations–most of them draw from instructor reflections or programming interface designs [2]. Further, even fewer have been situated in the more recent contexts of computing education i.e., high school classrooms where programming environments such as physical computing have been employed to make computing concepts further accessible to novices [3]. However, what is lesser known is how teachers make these computing concepts accessible to students through notional machines. To address the gap, in Fall 2020 and Spring 2021, we conducted a two-phase study that involved: (a) co-designing notional machines with an experienced high school computing teacher in Fall 2020, and, (b) observing his classes during the 14-week electronic textiles unit within Exploring Computer Science curriculum [1] in Spring 2021. For this poster, we will share findings from a preliminary qualitative analysis of online class screen recordings (5 hours, 10 class periods) of class periods that involved discussions around programs during the unit. We answer the following questions: (a) What were the different types of notional machines implemented throughout the unit within the context of physical computing? (b) How were they related to each other and to the key computing ideas within the unit? Our video analysis so far has revealed a variety of notional machines to introduce and sustain student learning during this unit. They took the form of roleplays, metaphors, and analogies, ranging from a period-long enactment to in-the-moment explanations to better understand specific aspects of program execution such as variable definition, function calls, and conditional statements execution. From extensive code tracing to debugging specific issues to diagnosing student thinking, these notional machines provided a variety of opportunities for the teacher to move across the different levels of abstractions while explaining program execution. During the poster session, we will share qualitative details about each of these categories of notional machines with examples that highlight their key characteristics in terms of form, conceptual focus, level of abstraction, and purpose within the unit. This analysis will provide one of the first accounts of notional machines emerging from classroom observational data. More importantly, it will be one of the first accounts of notional machines studied within a high school classroom, significant in the light of recent enthusiasm to introduce high school students to computing globally [4].",
        "keywords": "secondary computing; physical computing; notional machines",
        "released": 2021,
        "link": "https://doi.org/10.1145/3446871.3469796"
    },
    {
        "title": "String-embedded language support in integrated development environment",
        "abstract": "Most general-purpose programming languages allow to use string literals as source code in other languages (they are named string-embedded languages). Such strings can be executed or interpreted by dedicated runtime component. This way host program can communicate with DBMS or web browser. The most common example of string-embedded language is Dynamic SQL or SQL embedded into C#, C++, Java or other general-purpose programming languages. Standard Integrated Development Environment functionality such as syntax highlighting or static error checking in embedded languages can help developers who use such technique, but it is necessary to process string literals as a code to provide these features. We present a platform allowing to create tools for string-embedded languages processing easily, and compare it with other similar tools like IntelliLang. We also demonstrate a plug-in for ReSharper created by using the platform. The plug-in provides code highlighting and static error checking for string-embedded T-SQL in C#.",
        "keywords": "string-embedded language; parsing; parser generator; lexer generator; integrated development environment; abstract parsing; IDE; Dynamic SQL",
        "released": 2014,
        "link": "https://doi.org/10.1145/2687233.2687247"
    },
    {
        "title": "Studio k: A game development environment designed for gains in computational thinking (abstract only)",
        "abstract": "Studio K is a game design curriculum constructed to provide middle school students an engaging entry into computer science and programming. Developed at the University of Wisconsin-Madison, the program employs Microsoft’s 3D programming environment, Kodu, in tandem with support and analytic tools for facilitators, and an online community that provides players with a support system. These key features are bolstered with incorporation of telemetry data gathered through design sessions that are used to improve site functioning, curriculum relevancy, and administrative tools. This program is applied across contexts, with applications in formal classrooms, informal extracurricular clubs or camps, and alternative learning environments such as library systems or home schools. Studio K provides a well-supported, unique entry into computer science in which programming knowledge becomes a tool that supports learners’ goals in designing and developing games.",
        "keywords": "game design; computer science education",
        "released": 2014,
        "link": "https://doi.org/10.1145/2538862.2544312"
    },
    {
        "title": "Interactive support for secure programming education",
        "abstract": "Software flaws are a root cause of many of today’s information security vulnerabilities. Current curricula emphasis on traditional information security issues does not address this root cause. We propose educating students on secure programming techniques through interactive tool support in the Integrated Development Environment (IDE). We believe this approach can complement other curricula efforts by teaching and providing continuous reinforcement of practices throughout programming tasks. In this paper, we evaluate our prototype tool, ASIDE, which provides instant security warnings, detailed explanations of vulnerabilities, and code generation. We report the results of an observational study on 20 students from an advanced Web programming course. The results provide early evidence that our tool could potentially help students learn about and practice secure programming in the context of their programming assignments.",
        "keywords": "security education; secure programming; IDE",
        "released": 2013,
        "link": "https://doi.org/10.1145/2445196.2445396"
    },
    {
        "title": "Debugging support for end user mashup programming",
        "abstract": "Programming for the web can be an intimidating task, particularly for non-professional (\"end-user\") programmers. Mashup programming environments attempt to remedy this by providing support for such programming. It is well known, however, that mashup programmers create applications that contain bugs. Furthermore, mashup programmers learn from examples and reuse other mashups, which causes bugs to propagate to other mashups. In this paper we classify the bugs that occur in a large corpus of Yahoo! Pipes mashups. We describe support we have implemented in the Yahoo! Pipes environment to provide automatic error detection techniques that help mashup programmers localize and correct these bugs. We present the results of a think-aloud study comparing the experiences of end-user mashup programmers using and not using our support. Our results show that our debugging enhancements do help these programmers localize and correct bugs more effectively and efficiently.",
        "keywords": "yahoo! pipes; programming barriers; mashups; end-user software engineering; end-user programming; debugging",
        "released": 2013,
        "link": "https://doi.org/10.1145/2470654.2466213"
    },
    {
        "title": "An environment for large software team projects",
        "abstract": "This paper describes an advanced integrated development environment that may be used by juniors and seniors for large software team projects. The environment is mainly designed for Java Web-based applications with database support; however, it may be used for other types of software applications in other programming languages with minor adjustments. The key components of this environment include a database management system, a Web server, a concurrent versioning system, and an industrial-strength integrated development environment. All the components are open-source and can be downloaded and installed free of charge.",
        "keywords": "",
        "released": 2007,
        "link": "https://dl.acm.org/doi/10.5555/1181849.1181887"
    },
    {
        "title": "Empowering end users for social internet of things",
        "abstract": "We present Socialite, a novel end user programming tool for the Social Internet of Things (SIoT). SIoT is a new paradigm where IoT merges with social networks, allowing people and connected devices as well as the devices themselves to interact within a social network framework. Through an online survey with 60 potential users, we identified eight desired features for the SIoT, which were then clustered into four rule categories that can be programmed by end users and/or imposed by systems. The rules created by end users are used to reason about both devices and people in their social relationships to support automated decisions during runtime. Socialite uses ontology/semantic models for basic/low-level knowledge representation (e.g., device and user) to encapsulate the heterogeneity in devices from various manufacturers, and uses production rules (trigger-action programming) for high-level reasoning. With the ontology model, our reasoning supports both device type automation (e.g., current temperature from a thermostat) and capability-based automation (e.g., current temperature from any devices with the same capability). Furthermore, the Socialite rules leverage social relationships and device capabilities to facilitate collaboration by efficiently sharing configuration and information among users/friends and even with devices from people unknown to a user. In a 24-participant user study (12 with no programming experience), we found that Socialite was easy to learn and use, for both programmers and non-programmers. Participants were able to create automation based rules, social relationship involved rules, as well rules they created during the study.",
        "keywords": "Social Internet of Things; Semantic Reasoning Framework; End User Programming",
        "released": 2017,
        "link": "https://doi.org/10.1145/3054977.3054987"
    },
    {
        "title": "HTML 5 programming: Conference tutorial",
        "abstract": "HTML5 will soon become the new international HTML standard replacing XHTML and earlier versions of HTML. It will be the main web programming tool not only for traditional devices such as PC’s and laptops but also for emerging mobile devices such as iPhone and Android smartphones. It may also displace proprietary software such as Flash and Silverlight for rich web media presentations. Key web industry players are quickly adopting HTML5 and incorporating it into their browsers and applications. As a result, students are showing keen interest in this new HTML platform and CS/IT/IS instructors should soon be redesigning their web courses accordingly.",
        "keywords": "",
        "released": 2011,
        "link": "https://dl.acm.org/doi/10.5555/1961574.1961589"
    },
    {
        "title": "Holistic recommender systems for software engineering",
        "abstract": "Software maintenance is a relevant and expensive phase of the software development process. Developers have to deal with legacy and undocumented code that hinders the comprehension of the software system at hand. Enhancing program comprehension by means of recommender systems in the Integrated Development Environment (IDE) is a solution to assist developers in these tasks. The recommender systems proposed so far generally share common weaknesses: they are not proactive, they consider a single type of data-source, and in case of multiple data-source, relevant items are suggested together without considering interactions among them. We envision a future where recommender systems follow a holistic approach: They provide knowledge regarding a programming context by considering information beyond the one provided by single elements in the context of the software development. The recommender system should consider different elements such as development artifact (e.g., bug reports, mailing lists), and online resources (e.g., blogs, Q&amp;A web sites, API documentation), developers activities, repository history etc. The provided information should be novel and emerge from the semantic links created by the analysis of the interactions among these elements.",
        "keywords": "Recommender Systems; Developer Support",
        "released": 2014,
        "link": "https://doi.org/10.1145/2591062.2591081"
    },
    {
        "title": "Lessons from a web-based IDE and runtime",
        "abstract": "At Microsoft Research, we have built a purely web-based IDE called TouchDevelop that enables anyone to pick up a device and start programming. The IDE is geared towards touch based devices without keyboards, ranging from phones, over tablets, to large display screens. Programs can be edited and run on the device without an auxiliary PC. Transitioning between programming on one device, and continuing on another device is seamless. The web application also works offline.TouchDevelop has been successfully applied to teaching introductory programming classes at the high-school level and at some college level for non-CS majors. For researchers, TouchDevelop provides a green-field platform to explore IDE and programming language design, as well as runtime techniques and distributed data storage abstractions.In this talk, I will provide an overview of TouchDevelop from a language, IDE, and runtime perspective, while diving into some of the novel techniques enabled by our particular platform.",
        "keywords": "web ide; touch-based entry; tablet; smart phone; introductory programming",
        "released": 2014,
        "link": "https://doi.org/10.1145/2543728.2543746"
    },
    {
        "title": "Harnessing stack overflow for the IDE",
        "abstract": "Developers often consult online tutorials and message boards to find solutions to their programming issues. Among the many online resources, Question &amp; Answer websites are gaining popularity. This is no wonder if we consider a case like Stack Overflow, where more than 92",
        "keywords": "stack overflow; seahawk; Q&amp;A websites",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2666719.2666725"
    },
    {
        "title": "End user software engineering: CHI 2010 special interest group meeting",
        "abstract": "End users create software whenever they create, for instance, interactive web pages, games, educational simulations, or spreadsheets. Researchers are working to bring the benefits of rigorous software engineering methodologies to these end users to try to make their software more reliable. Unfortunately, errors are pervasive in end-user software, and the resulting impact is sometimes enormous. This special interest group meeting will bring together the community of researchers who are addressing this topic with the companies that are creating and using end-user programming tools.",
        "keywords": "web authoring; psychology of programming; natural programming; end-user software engineering (euse); end-user development (eud); end users shaping effective software (euses); empirical studies of programmers (esp)",
        "released": 2010,
        "link": "https://doi.org/10.1145/1753846.1753953"
    },
    {
        "title": "Automatically generating tutorials to enable middle school children to learn programming independently",
        "abstract": "Enabling middle school children to learn from code shared on the internet may provide computer science learning opportunities to those who would not otherwise have them. We augmented a programming environment designed for middle school children to automatically generate tutorials from code snippets in order to help users learn new programming skills. In our new system, users select code snippets from a program shared on the web and then complete an automatically generated tutorial in order to re-create that snippet within their own program. To evaluate the potential learning gains from our generated tutorials, we conducted a between-subjects study in which we evaluated the performance of children introduced to new programming constructs through automatically generated tutorials. Participants who used the automatically generated tutorials performed 64",
        "keywords": "programming systems for children; code reuse; automatically generated tutorials",
        "released": 2013,
        "link": "https://doi.org/10.1145/2485760.2485764"
    },
    {
        "title": "Mobile computational thinking with app inventor 2 (abstract only)",
        "abstract": "Computational Thinking Through Mobile Computing is an NSF-funded project for introducing students to computational thinking through creating mobile apps. In this hands-on workshop, which is targeted at undergraduate and secondary school computer science teachers, participants will develop Android apps using MIT App Inventor 2. This is a new version of the visual blocks-based programming environment with additional language features (e.g., local variables) and browser-based blocks editing. The workshop will also present pedagogical materials (lessons, tutorials, assignments), evaluation materials (blocks-based quizzes, surveys, project rubrics), and student projects. All of the pedagogical materials presented in the workshop, as well as all of the materials used by the workshop presenters in their individual courses, are posted on the Web and are available to everyone under a Creative Commons license. A laptop is required for this workshop. Each participant will be provided with an Android mobile device to use during the workshop. Participants who have their own Android phones or tablets can use them if they choose. This workshop is based upon work supported by the National Science Foundation under Grant Numbers 1225680, 1225719, 1225745, 1225976, and 1226216.",
        "keywords": "mobile computing; event-based programming; computational thinking; blocks programming; CS0",
        "released": 2014,
        "link": "https://doi.org/10.1145/2538862.2539023"
    },
    {
        "title": "Operating systems",
        "abstract": "Early operating systems were control programs a few thousand bytes long that scheduled jobs, drove peripheral devices, and kept track of system usage for billing purposes. Modern operating systems are much larger, ranging from hundreds of thousands of bytes for personal computers (e.g. MS-DOS, Xenix) to tens of millions of bytes for mainframes (e.g. Honeywell’s Multics, IBM’s MVS, AT&amp;T’s Unix) and hundreds of millions of bytes for some servers (Microsoft’s Windows NT). In addition to managing processors, memory, and dozens of input-output devices, modern operating systems also provide numerous services such as Internet communications, Web communications, interprocess communications, file and directory systems, data transfer over local networks, and command languages and graphical user interfaces for invoking and controlling programs. These high-level services hide the primitive facilities of the base computer, such as interrupts, status registers, and device interfaces, from the user. The operating system builds its high- level services by wrapping the low-level hardware facilities in layers of software, resulting in a powerful virtual machine that is much easier to use than the basic hardware. Thus an operating system provides two classes of functions: orderly allocation of computing resources among processes contending for them, and an extended machine that provides a powerful programming environment. These two classes are not independent; poor structure can make resource allocation a nightmare. The microkernel architecture to be discussed below is a good structure that enables efficient resource allocation and powerful programming environments.",
        "keywords": "",
        "released": 2003,
        "link": "https://dl.acm.org/doi/10.5555/1074100.1074661"
    },
    {
        "title": "CodeWrite: Supporting student-driven practice of java",
        "abstract": "Drill and practice exercises enable students to master skills needed for more sophisticated programming. A barrier to providing such activities is the effort required to set up the programming environment. Testing is an important component to writing good software, but it is difficult to motivate students to write tests. In this paper we describe and evaluate CodeWrite, a web-based tool that provides drill and practice support for Java programming, and for which testing plays a central role in its use. We describe how we have used CodeWrite in a CS1 course, and demonstrate its effectiveness in providing good coverage of the language features presented in the course.",
        "keywords": "student-generated content; online; contributing student pedagogy; constructive evaluation; assessment; CodeWrite",
        "released": 2011,
        "link": "https://doi.org/10.1145/1953163.1953299"
    },
    {
        "title": "QPR.js: A runtime framework for QoS-aware power optimization for parallel JavaScript programs",
        "abstract": "JavaScript has become a general-purpose programming environment that enables complex, media-rich web applications. An increasing number of JavaScript programs are parallelized to run efficiently on today’s multicore CPUs, which are capable of dynamic core scaling (DCS) and voltage/frequency scaling (DVFS). However, significant power savings are still left on the table since an operating point (in terms of the number of active cores and CPU voltage/frequency) is selected by monitoring CPU utilization or OS events, without considering the user’s performance goal. To address this, we propose QPR.js, a QoS-aware power-optimizing runtime system for JavaScript. Using the QPR.js API, the application developer can specify a QoS goal and provide a fitness function to quantify the current level of QoS. During execution the QPR.js runtime system uses this information to autonomously find an optimal operating point minimizing power consumption while satisfying the QoS goal. Our evaluation with five parallel JavaScript programs demonstrates an average of 35.2",
        "keywords": "power optimization; multi-core; javascript; dvfs",
        "released": 2014,
        "link": "https://doi.org/10.1145/2627369.2627648"
    },
    {
        "title": "Standing on the shoulders of their peers: Success factors for massive cooperation among children creating open source animations and games on their smartphones",
        "abstract": "We developed a website for kids where they can share new as well as remixed animations and games, e.g., interactive music videos, which they created on their smartphones or tablets using a visual \"LEGO-style\" programming environment called Catroid. Online communities for children like our website have unique requirements, and keeping the commitment of kids on a high level is a continuous challenge. For instance, one key motivator for kids is the ability to entertain their friends. Another success factor is the ability to learn from and cooperate with other children. In this short position paper we attempt at identifying the requirements for the success of such an online community, both from the point of view of the kids as well as of their parents, and at finding ways to make it attractive for both.",
        "keywords": "tablets; smartphones; remixing; programming; parents; music; kids; games; education; collaboration; children; animation",
        "released": 2012,
        "link": "https://doi.org/10.1145/2307096.2307141"
    },
    {
        "title": "Reusable decision space for mashup tool design",
        "abstract": "Mashup tools are a class of integrated development environments that enable rapid, on-the-fly development of mashups - a type of lightweight Web applications mixing content and services provided through the Web. In the past few years there have been growing number of projects, both from academia and industry, aimed at the development of innovative mashup tools. From the software architecture perspective, the massive effort behind the development of these tools creates a large pool of reusable architectural decisions from which the design of future mashup tools can derive considerable benefits. In this paper, focusing on the design of mashup tools, we explore a design space of decisions comprised of design issues and alternatives. The design space knowledge not only is broad enough to explain the variability of existing tools, but also provides a road-map towards the design of next generation mashup tools.",
        "keywords": "software architecture; mashup tools; design rationale",
        "released": 2012,
        "link": "https://doi.org/10.1145/2305484.2305520"
    },
    {
        "title": "Roles in building web applications using java",
        "abstract": "In this paper we apply the powerJava model of roles and relationships to a web application programming environment. First we show how the notion of role, as defined in powerJava, combines and automates several aspects which are important in web application programming, and which are now unrelated and dealt with separately and mostly by hand, and thus prone to errors. Second we show how from the powerJava code a web application can be automatically constructed using Struts and Spring.",
        "keywords": "",
        "released": 2009,
        "link": "https://doi.org/10.1145/1562100.1562106"
    },
    {
        "title": "Interactive audio web development workflow",
        "abstract": "New low-level sound synthesis capabilities have recently become available in Web browsers. However, there is a considerable gap between the enabling technology for interactive audio and its wide-spread adoption in Web media content. We identify several areas where technologies are necessary to support the various stages of development and deployment, describe systems we have developed to address those needs, and show how they work together within a specific Web content development scenario.",
        "keywords": "web development workflow; w3c web audio api; interactive audio; development tools",
        "released": 2014,
        "link": "https://doi.org/10.1145/2647868.2655064"
    },
    {
        "title": "Measuring of and reacting to learners’ progress in logic programming courses",
        "abstract": "To be able to support learners adequately in logic programming courses, it is crucial to know about their current level of competency during the learning process. Based on this, the course can be adapted and individual support can be given. In a traditional lecture the learning process is often a black box for the teacher, so there is no possibility to incorporate it. This paper describes how an architecture consisting of an online programming environment, private blogs and a reporting application can be used to solve the problem and shows how it was applied in the context of university lectures.",
        "keywords": "reflection; programming language education; learning process evaluation",
        "released": 2010,
        "link": "https://doi.org/10.1145/1822090.1822134"
    },
    {
        "title": "CSinParallel: Using map-reduce to teach parallel programming concepts across the CS curriculum (abstract only)",
        "abstract": "Map-reduce, the cornerstone computational framework for cloud computing applications, has star appeal to draw students to the study of parallelism. Participants will carry out hands-on exercises designed for students at CS1/intermediate/advanced levels that introduce data-intensive scalable computing concepts, using WebMapReduce (WMR), a simplified open-source interface to the widely used Hadoop map-reduce programming environment. These hands-on exercises enable students to perform data-intensive scalable computations carried out on the most widely deployed map-reduce framework, used by Facebook, Microsoft, Yahoo, and other companies. WMR supports programming in a choice of languages (including Java, Python, C++, C#, Scheme); participants will be able to try exercises with languages of their choice. Workshop includes brief introduction to direct Hadoop programming, and information about access to cluster resources supporting WMR. Workshop materials will reside on csinparallel.org, along with WMR software. Intended audience: CS instructors. Laptop required (Windows, Mac, or Linux).",
        "keywords": "wmr; webmapreduce; map-reduce computing; introductory course; hadoop; education; distributed computing; data-intensive scalable computing; curriculum; csinparallel; cs1",
        "released": 2013,
        "link": "https://doi.org/10.1145/2445196.2445504"
    },
    {
        "title": "Unite: An adapter for transforming analysis tools to web services via OSLC",
        "abstract": "This paper describes Unite, a new tool intended as an adapter for transforming non-interactive command-line analysis tools to OSLC-compliant web services. Unite aims to make such tools easier to adopt and more convenient to use by allowing them to be accessible, both locally and remotely, in a unified way and to be easily integrated into various development environments. Open Services for Lifecycle Collaboration (OSLC) is an open standard for tool integration and was chosen for this task due to its robustness, extensibility, support of data from various domains, and its growing popularity. The work is motivated by allowing existing analysis tools to be more widely used with a strong emphasis on widening their industrial usage. We have implemented Unite and used it with multiple existing static as well as dynamic analysis and verification tools, and then successfully deployed it internationally in the industry to automate verification tasks for development teams in Honeywell. We discuss Honeywell’s experience with using Unite and with OSLC in general. Moreover, we also provide the Unite Client (UniC) for Eclipse to allow users to easily run various analysis tools directly from the Eclipse IDE.",
        "keywords": "Transformation to web services; Tool integration; Software analysis; OSLC Automation; OSLC; Eclipse Lyo",
        "released": 2022,
        "link": "https://doi.org/10.1145/3540250.3558939"
    },
    {
        "title": "End user software engineering: CHI: 2009 special interest group meeting",
        "abstract": "End users create software whenever they write, for instance, educational simulations, spreadsheets, or dynamic e-business web applications. Researchers are working to bring the benefits of rigorous software engineering methodologies to these end users to try to make their software more reliable. Unfortunately, errors are pervasive in end-user software, and the resulting impact is sometimes enormous. This special interest group meeting will bring together the community of researchers who are addressing this topic with the companies that are creating and using end-user programming tools.",
        "keywords": "psychology of programming; natural programming; end-user software engineering (EUSE); end-user development (EUD); end users shaping effective software (EUSES); empirical studies of programmers (ESP)",
        "released": 2009,
        "link": "https://doi.org/10.1145/1520340.1520393"
    },
    {
        "title": "Documentation comes to life in computational thinking acquisition with agentsheets",
        "abstract": "This paper is about the use of live documentation in Computational Thinking Acquisition (CTA) programs with AgentSheets. AgentSheets is a visual programming environment to build games. Based on previous studies showing that semiotic relations among visual game elements could be further explored to the benefit of the learners, we designed PoliFacets, a Web extension to AgentSheets cast as a live conversational document. With it, teachers and learners can follow different threads of conversation about (multiple representations of) game elements and relations between them. We present a qualitative evaluation study of PoliFacets with two experienced AgentSheets instructors and three school teachers trained to coach students in CTA programs. Findings show that although our system has not yet completely fulfilled our design intent, it has led participants to gain relevant insights about their teaching and learning, as well as to articulating doubts and misunderstandings that otherwise could have gone unnoticed.",
        "keywords": "metacommunication; live documentation; end-user programming; computational thinking acquisition; agentsheets",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2393536.2393558"
    },
    {
        "title": "One-day activities for k-12 face-to-face outreach",
        "abstract": "The recent successes of Computer Science Education Week and code.org’s Hour of Code have meant that more K-12 students than ever are being given an authentic, engaging and eye-opening exposure to the wonders of computer science. There are resources aplenty to help high school and college faculty with outreach. These range from easy-to-learn, open-ended programming environments (Scratch, Alice, Snap!), to online coding challenges (code.org, Lite-bot), to non-computer activities with live performances (CS Unplugged, cs4fn), to having the entire outreach experience delivered \"in a box\", thanks to NCWIT.We wanted to bring educators together to share experiences with what they’ve done specifically with a one-day event, given these vast resources. Now that there are so many online coding experiences, it is enough to shuttle young students into a computer room, point their browser at one of these experiences, and answer questions as they come up? Is it important to include hands-on and hands-off (e.g., nifty demos, inspiring talks) components, and if so, in what order? What do different demographics find the most engaging? Is there any chance that we can do \"damage\", since these highlight-reel experiences might over-simplify how hard some of the problems are, and that not every important result has a flashy payoff? Do some of the early experiences leave students with the impression that computer science is only (say) apps, interactive multimedia programs or solving mazes? Finally, when it’s over, what follow-up is appropriate? Participants on the panel will share best practices, common pitfalls, and advice.",
        "keywords": "outreach; k-12; computer science education",
        "released": 2015,
        "link": "https://doi.org/10.1145/2676723.2677337"
    },
    {
        "title": "Programming with everybody: Tightening the copy-modify-publish feedback loop",
        "abstract": "People write more code than they ever share online. They also copy and tweak code more often than they contribute their modifications back to the public. These situations can lead to widespread duplication of effort. However, the copy-modify-publish feedback loop which could solve the problem is inhibited by the effort required to publish code online. In this paper we present our preliminary, ongoing effort to create Ditty, a programming environment that attacks the problem by sharing changes immediately, making all code public by default. Ditty tracks the changes users make to code they find and exposes the modified versions alongside the original so that commonly-used derivatives can eventually become canonical. Our work will examine mechanical and social methods to consolidate global effort on common code snippets, and the effects of designing a programming interface that inspires a feeling of the whole world programming together.",
        "keywords": "social computing; programming environments; open source software development; collaboration; awareness",
        "released": 2012,
        "link": "https://doi.org/10.1145/2380296.2380342"
    },
    {
        "title": "How well do online forums facilitate discussion and collaboration among novice animation programmers?",
        "abstract": "Animation programming is a widely-respected approach for helping students to learn programming skills, and online forums are a widely-used approach for helping students to interact with one another. But in what ways, if any, does combining animation programming with online forums lead to useful discussion and collaboration among learners? To answer this question, we analyzed online forum discussions among people who were learning to create animation programs using the Scratch programming environment. We discovered that specific kinds of online posts were more likely than others to be followed by discussion, and we found that the ensuing collaboration often involved the exchange of design ideas and feedback within small groups of users. These findings reveal opportunities for enhancing online forums and surrounding tools so they more effectively facilitate discussion, collaboration, and ultimately development of programming skills.",
        "keywords": "scratch; novice programming environments; forums",
        "released": 2012,
        "link": "https://doi.org/10.1145/2157136.2157195"
    },
    {
        "title": "Methodology and framework for the development of scientific applications with high-performance computing through web services",
        "abstract": "One of the biggest problems in the development of high-performance scientific applications is the need for programming environments that allow source code development in an efficient way. However, there is a clear lack of approaches with specific methodologies or optimal working environments to develop high-performance computing software systems. Additionally, existing frameworks are focused on the design and implementation phases, forgetting software component reuse from the earliest stages of the development process.An aspect-oriented and component-based approach is proposed for the development of complex parallel applications from existing functional components and new component definitions, according to business rules established by the users, through a web service entry of the platform. The proposed approach includes a specific methodology to develop high-performance scientific applications through the reuse of components from the earliest stages. Finally, an additional supercomputing-oriented framework aims to facilitate the development of these systems and to make creation, cataloguing, validation and reuse of each application and its components easier.",
        "keywords": "reuse; methodology; high-performance computing; framework; HPC; CBSE; AOP",
        "released": 2012,
        "link": "https://doi.org/10.1145/2261605.2261631"
    },
    {
        "title": "Using pencil code to bridge the gap between visual and text-based coding (abstract only)",
        "abstract": "This workshop introduces a new educational programming environment Pencil Code, which helps bridge the learning gap between visual programming and text-based coding. The free open-source online tool allows students to work with programs using either blocks or Coffeescript or Javascript text code. Students can switch between visual and text modes at any time.The workshop will begin with a collaborative discussion of the opportunities, challenges, and differences presented when learning with block code and moving to text code. Then we will give a short presentation of how Pencil Code is used in classrooms, with some preliminary findings.The main part of the workshop is a hands-on activity where participants gain experience with Pencil Code. Participants will use the tool with lessons in a curriculum framework, for teaching functions and interactivity using both text code and block code. Finally, there will be a discussion of best practices for teaching students in the transition, and an opportunity to create your own lessons using Pencil Code or other tools.Attendees will come away with an understanding the issues faced by students transitioning to text code for the first time, and they will gain practical experience with teaching lessons with Pencil Code. Participants will receive curriculum material appropriate for middle-school and high-school classrooms. The tool is open-source and free to use at http://pencilcode.net/.",
        "keywords": "visual programming; pencil code; k-12; javascript; curriculum; computer science education; coffeescript",
        "released": 2015,
        "link": "https://doi.org/10.1145/2676723.2678293"
    },
    {
        "title": "Implementing a modular integrated system for biodiversity conservation and promotion using web technologies",
        "abstract": "In the context of promoting environmental wealth to visitors, this paper explores the development of a web platform, widening the visibility of local biodiversity and aiding in its preservation. We introduce a modular web platform, constructed from interconnected front-end and back-end modules and built upon open-source technologies. In the past, delivering captivating, media-rich user experiences, called for specific hardware and proprietary development tools. This study highlights how the latest in web technology, combined with contemporary web browsers (such as those supporting the WebGL standard), now allows for the rollout of these advanced services on everyday mobile devices using widely accepted web technologies like HTML, CSS, and JavaScript. The immersive qualities of multimedia and cutting-edge AR/VR technologies have enhanced the magic of natural sites and the attractiveness of points of interest. Under this notion, we’ve worked on a thorough investigation of how these paradigm-shifting discoveries might be used to make a virtual retreat for enthusiasts of ecology. The proposed platform’s focus on the protection and promotion of biodiversity is the basis of not only improving the user experience but it also emerges as a tool for the preservation of the Ionian Islands’ natural marvels as we delve into its architecture and capabilities.",
        "keywords": "Biodiversity; ecotourism",
        "released": 2024,
        "link": "https://doi.org/10.1145/3635059.3635085"
    },
    {
        "title": "PyCompArch: Python-based modules for exploring computer architecture concepts",
        "abstract": "As computer architecture integrates multiple concepts such as microarchitecture, design, the hardware-software interface, compilers, and operating systems, there is an always increasing need to develop new methods for learning and exploring the field. Parallelism in computer systems is a key focus in computer architecture and some core parallel concepts include Amdahl’s law, efficiency, and overhead. While there are a number of ways to examine these topics in traditional lectures and assignments, a unique way is to leverage Python-based programming environments that allow students to independently explore concepts and their governing parameters.This paper presents the highlights of PyCompArch Python module developed using the IPython Notebook environment to help the study of concepts in computer architecture. Python is a widely used general-purpose, high-level programming language, but traditionally the language does not play a leading role in the education of computer architecture. IPython Notebooks allow developers to interactively run Python code cells and to construct Python codes that execute on remote servers that eliminate any system requirements of the individual. In this way, the environment supports web-based remote \"in the cloud\" code development that can be modified during lectures or in homework assignments. The PyCompArch module supports a number of ways to help individuals learn concepts of parallelism related to computer architecture as well as explore experiments in computer performance and control. For example, PyCompArch supports the evaluation of performance of real-world benchmarks such as Open Computer Vision (OpenCV) and dynamic frequency scaling (DFS) in Raspberry Pi systems. Overall, the PyCompArch supports student learning and development of experiments in computer architecture.",
        "keywords": "",
        "released": 2015,
        "link": "https://doi.org/10.1145/2795122.2795126"
    },
    {
        "title": "Crowdsourcing task traces for service robotics",
        "abstract": "Demonstration is an effective end-user development paradigm for teaching robots how to perform new tasks. In this paper, we posit that demonstration is useful not only as a teaching tool, but also as a way to understand and assist end-user developers in thinking about a task at hand. As a first step toward gaining this understanding, we constructed a lightweight web interface to crowdsource step-by-step instructions of common household tasks, leveraging the imaginations and past experiences of potential end-user developers. As evidence of the utility of our interface, we deployed the interface on Amazon Mechanical Turk and collected 207 task traces that span 18 different task categories. We describe our vision for how these task traces can be operationalized as task models within end-user development tools and provide a roadmap for future work.",
        "keywords": "crowdsourcing; end-user development; service robotics",
        "released": 2023,
        "link": "https://doi.org/10.1145/3568294.3580112"
    },
    {
        "title": "An integrated development environment for faster feature engineering",
        "abstract": "The application of machine learning to large datasets has become a core component of many important and exciting software systems being built today. The extreme value in these trained systems is tempered, however, by the difficulty of constructing them. As shown by the experience of Google, Netflix, IBM, and many others, a critical problem in building trained systems is that of feature engineering. High-quality machine learning features are crucial for the system’s performance but are difficult and time-consuming for engineers to develop. Data-centric developer tools that improve the productivity of feature engineers will thus likely have a large impact on an important area of work.We have built a demonstration integrated development environment for feature engineers. It accelerates one particular step in the feature engineering development cycle: evaluating the effectiveness of novel feature code. In particular, it uses an index and runtime execution planner to process raw data objects (e.g., Web pages) in order of descending likelihood that the data object will be relevant to the user’s feature code. This demonstration IDE allows the user to write arbitrary feature code, evaluate its impact on learner quality, and observe exactly how much faster our technique performs compared to a baseline system.",
        "keywords": "",
        "released": 2014,
        "link": "https://doi.org/10.14778/2733004.2733054"
    },
    {
        "title": "Wikigramming: A wiki-based training environment for programming",
        "abstract": "Wiki is one of the most successful technologies in Web 2.0 because it is so simple that anyone can start using it instantly. The main aim of this research is to realize a collaborative programming environment that is as simple as Wiki. Each Wiki page contains source code of a Scheme function which is executed on the server. Users can edit any function at any time without complicated procedure, and see the results of their changes instantly. In order to avoid intentional or unintentional destruction of working programs, when users attempt to modify existing functions, the modified version must pass unit tests written by other users. Though changes are made anonymously, we can have some confidence if test cases are written by many users.",
        "keywords": "wiki; unit test; training; programming environment",
        "released": 2011,
        "link": "https://doi.org/10.1145/1984701.1984703"
    },
    {
        "title": "An FPGA-enabled framework for rapid automated design of photonic integrated circuits",
        "abstract": "This paper introduces an FPGA-enabled framework to accelerate the automated design process for Photonic Integrated Circuit (PIC) devices. PICs are foreseen as a foundation for the next-generation semiconductors. However, the complexity of PIC design presents considerable challenges. Machine Learning (ML) techniques have shown promise in the realm of PIC design. The primary hurdle, however, is the extended training duration, solely constrained by the slow electromagnetic (EM) Finite-Difference Time-Domain (FDTD) solver. We propose a fast framework with a dedicated FPGA FDTD accelerator tailor-designed to speed up the PIC simulation. Benchmarking was carried out against commercial tools, with the single-FPGA accelerator outperforming both a multicore CPU and a GPU cluster. We taped out and evaluated the PIC devices designed through the proposed framework, and the experimental outcomes aligned. This demonstrates the full design circle, showcasing that the proposed framework enabled by FPGA breaks the current bottleneck in this domain. This study was conducted entirely on a commercial cloud platform (AWS), leveraging CPUs, FPGAs, and GPUs, with FPGA programming efficiently executed using High-Level Synthesis (HLS) and the Xilinx Runtime (XRT). The FPGA, along with its modern development tools, is seamlessly integrated into a heterogeneous computing platform, showcasing the accessible and practical nature of this approach. Our findings show the exciting possibility that ML-based physical design could be notably sped up enabled by FPGAs in a cloud-hosted heterogeneous cluster as a service.",
        "keywords": "cloud computing; finite difference time domain; fpga; heterogeneous computing; machine learning; photonic integrated circuits",
        "released": 2024,
        "link": "https://doi.org/10.1145/3626202.3637565"
    },
    {
        "title": "CodeBasket: Making developers’ mental model visible and explorable",
        "abstract": "One of software developers’ most important activities is exploring the broader context of a certain programming task, which strongly requires navigating source code and working out a mental model of the collected information. Without tool support, creating and maintaining this mental model leads to significant cognitive load because developers have to handle both relating relevant source code entities to their mental model as well as remembering already explored search paths. Furthermore, the opposite direction, that is, recalling relevant facts out of the mental model, and subsequently, seeking corresponding entities within the source code, demands similar cognitive efforts. In this paper, we introduce CodeBasket, an approach for making developers’ mental model visible and explorable. As for that, CodeBasket helps developers keeping their mental model persistent by providing a two-dimensional canvas on which they can freely arrange visual representations of source code entities, named eggs. Since those eggs are linked to the underlying source code, eventually, they can be used for navigating directly to related source code entities. We implemented a first prototype as a touch-enabled web application that is connected to a conventional integrated development environment In order to get early feedback on our approach, we used CodeBasket within a formative study.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2819366.2819375"
    },
    {
        "title": "Domain-expert configuration of hypermedia multi-agent systems in industrial use cases",
        "abstract": "Based on the analysis of two real-world use cases for agriculture and manufacturing, we suggest that Hypermedia Multi-Agent Systems (MAS) are a viable option to interconnect and coordinate devices, services, machine-learning systems, and people in industrial scenarios. We propose and implement an architecture based on three components: an infrastructure that manages Web of Things environments and executes Hypermedia MAS, a visual development environment for programming agents, and a goal specification interface for end-users. While the infrastructure manages information flows between the system components and provides an environment for agents, the visual language enables domain experts to configure the behaviour of the system leveraging agent-oriented programming abstractions both at design time and run time, and the goal specification interface permits users to delegate goals to the running Hypermedia MAS while re-using domain vocabulary.",
        "keywords": "hypermedia multi-agent systems; web of things",
        "released": 2023,
        "link": "https://dl.acm.org/doi/10.5555/3545946.3598981"
    },
    {
        "title": "ICER ’16: Proceedings of the 2016 ACM conference on international computing education research",
        "abstract": "We warmly welcome you to the twelfth annual International Computing Education Research conference (ICER 2016), sponsored by the ACM Special Interest Group on Computer Science Education. This year ICER will be held in Melbourne, Australia, and will be located in the Monash University Law Chambers in the city centre of Melbourne.The ICER conference has been steadily growing. This year there were a record number of research paper submissions with a total of 102 papers submitted and 26 papers accepted for an acceptance rate of 25",
        "keywords": "",
        "released": 2016,
        "link": "https://dl.acm.org/doi/10.1145/2960310"
    },
    {
        "title": "The beauty and joy of computing (BJC), AP CS principles, and the CS 10K effort",
        "abstract": "BJC was chosen as one of the initial pilots for a new \"AP CS:Principles\" exam to be introduced in 2015. The purpose of this course is to attract nontraditional computing students (especially women and minorities, but also English majors) to the breadth and depth of ideas in modern computer science. The National Science Foundation wants to prepare 10,000 new high school computer science teachers to teach the new AP course by 2015 (the \"CS10K\" effort). Under their CE21 (Computing Education for the 21st Century) initiative, we were funded to provide paid intensive six-week summer workshops for high school teachers, including two weeks of face-to-face training, one before and one after four weeks of our online course. This talk will review the status of all of these projects, the development of Build Your Own Blocks (BYOB), a graphical programming environment based on MIT’s Scratch that is used in the curriculum, and how faculty, students and high school teachers can engage with these important efforts.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2168874.2168903"
    },
    {
        "title": "A pattern-based function and workflow visual environment for FaaS development across the continuum",
        "abstract": "The ability to split applications across different locations in the continuum (edge/cloud) creates needs for application break down into smaller and more distributed chunks. In this realm the Function as a Service approach appears as a significant enabler in this process. The paper presents a visual function and workflow development environment for complex FaaS (Apache OpenwhisK) applications. The environment offers a library of pattern based and reusable nodes and flows while mitigating function orchestration limitations in the domain. Generation of the deployable artefacts, i.e. the functions, is performed through embedded DevOps pipelines. A range of annotations are available for dictating diverse options including QoS needs, function or data locality requirements, function affinity considerations etc. These are propagated to the deployment and operation stacks for supporting the cloud/edge interplay. The mechanism is evaluated functionally through creating, registering and executing functions and orchestrating workflows, adapting typical parallelization patterns and an edge data collection process.",
        "keywords": "function as a service; function orchestration; serverless computing; software development",
        "released": 2023,
        "link": "https://doi.org/10.1145/3578245.3584934"
    },
    {
        "title": "Webstudio: Building infrastructure for web data management",
        "abstract": "To explore various ideas and algorithms for improving relevance of a search engine, we found it necessary to build an infrastructure to provide large-scale data management and data processing capabilities. WebStudio is an infrastructure we have constructed to provide an integrated development environment (IDE) for researchers and developers to use in quickly building prototypes and conducting experiments at Web-scale. It is also a Web data management system to allow users to easily store, access, and manipulate Web data.",
        "keywords": "web search; web data management",
        "released": 2007,
        "link": "https://doi.org/10.1145/1247480.1247578"
    },
    {
        "title": "Online identification of learner problem solving strategies using pattern recognition methods",
        "abstract": "Learning and programming environments used in computer science education give feedback to the users by system messages. These are triggered by programming errors and give only \"technical\" hints without regard to the learners’ problem solving process. To adapt the messages not only to the factual but also to the procedural knowledge of the learners, their problem solving strategies have to be identified automatically and in process. This article describes a way to achieve this with the help of pattern recognition methods. Using data from a study with 65 learners aged 12 to 13 using a learning environment for programming, a classification system based on hidden Markov models is trained and integrated in the very same environment. We discuss findings in that data and the performance of the automatic online identification, and present first results using the developed software in class.",
        "keywords": "tool-based analysis; secondary education; problem solving strategies; pattern recognition; computer science education; algorithms",
        "released": 2010,
        "link": "https://doi.org/10.1145/1822090.1822167"
    },
    {
        "title": "MOCSIDE: An open-source and scalable online IDE and auto-grader for introductory programming courses",
        "abstract": "Programming is learned through practice, with said practice in introductory programming courses often translating to a prohibitively large number of assignments, increasing the grading workload for faculty and/or teaching assistants. In short, this is unsustainable. Several publishers and a few notable companies have provided meritable solutions, although most are plagued with problems including minimal problem sets, limited customization options, high cost, and even a disconnect with the pedagogical needs within academia. This paper presents a survey of the more popular solutions currently available, followed by a presentation of our newly-developed web application, MOCSIDE: open-source and scalable online IDE and auto-grader for computer science education.",
        "keywords": "",
        "released": 2021,
        "link": "https://dl.acm.org/doi/10.5555/3512733.3512734"
    },
    {
        "title": "Peer-to-peer collaboration in the lively kernel",
        "abstract": "With the increasing popularity of the World Wide Web, end-user applications are moving from the desktop to the browser. More and more applications that we have come to know as desktop applications are now making their way into the web. This has made online collaboration a key aspect for many applications. Collaborative applications like Facebook, Flickr and Google Docs are just an early hint of how we can benefit from users being able to share data. Still, collaborative features are not easy to implement in web applications. Most web programming environments aim at easy user interface creation and persistence, but not for online collaboration and pushing data from one user to another. The Lively Kernel is a highly dynamic web programming platform and runtime environment developed at Sun Microsystems Laboratories. By utilizing the Lively Kernel platform, it is easy to implement desktop like applications for the web using JavaScript. In this paper we summarize the experiences from adding peer-to-peer collaboration into the Lively Kernel. These additions include persistent data storage, communication channels between users and user identification.",
        "keywords": "web application; collaboration; Lively Kernel; JavaScript",
        "released": 2010,
        "link": "https://doi.org/10.1145/1774088.1774257"
    },
    {
        "title": "Xilinx vitis unified software platform",
        "abstract": "FPGAs provide significant advantages in throughput, latency, and energy efficiency for implementing low-latency, compute-intensive applications when compared to general-purpose CPUs and GPUs. Over the last decade, FPGAs have evolved into highly configurable SoCs with on-chip CPUs, domain-specific programmable accelerators, and flexible connectivity options. Recently, Xilinx introduced a new heterogeneous compute architecture, the Adaptive Compute Acceleration Platform (ACAP), with significantly more flexibility and performance to address an evolving set of new applications such as machine learning. This advancement on the device side is accompanied by similar advances on higher-level programming approaches to make FPGAs and ACAPs significantly easy to use for a wide range of applications. Xilinx Vitis Unified Software Platform is a comprehensive development environment to build and seamlessly deploy accelerated applications on Xilinx platforms including Alveo cards, FPGA-instances in the cloud, and embedded platforms. It addresses the three major industry trends: the need for heterogenous computing, applications that span cloud to edge to end-point, and AI proliferation. Vitis supports application programming using C, C++ and OpenCL, and it enables the development of large-scale data processing and machine learning applications using familiar, higher-level frameworks such as TensorFlow and SPARK. To facilitate communication between the host application and accelerators, Xilinx Runtime library (XRT) provides APIs for accelerator life-cycle management, accelerator execution management, memory allocation, and data communication between the host application and accelerators. In addition, a rich set of performance-optimized, open-source libraries significantly ease the application development. Vitis AI, an integral part of Vitis, enables AI inference acceleration on Xilinx platforms. It supports industry’s leading deep learning frameworks like Tensorflow and Caffe, and offers a comprehensive suite of tools and APIs to prune, quantize, optimize, and compile pre-trained models to achieve the highest AI inference performance on Xilinx platforms. This talk provides an overview of Vitis and Vitis AI development environments.",
        "keywords": "vitis unified software platform; vitis ai; machine learning tools; machine learning inference; higher-level programming tools for fpga; heterogenous computing; fpga acceleration",
        "released": 2020,
        "link": "https://doi.org/10.1145/3373087.3375887"
    },
    {
        "title": "Creating a mobile web application platform: The lively kernel experiences",
        "abstract": "The software industry is currently in the middle of two transitions – towards web-based software and towards web-enabled mobile devices. In this paper, we summarize our experiences in porting the Sun Labs Lively Kernel - an interactive web programming environment developed at Sun Microsystems Laboratories - onto a Nokia N810 mobile device. We report our experiences based on two different approaches that were used. First, we ported the system onto a regular web browser running in the mobile device. Second, we developed a custom-built native execution environment that provides more direct and extensive access to the underlying resources of the system. Based on these experiments, we will discuss the lessons learned as well as provide directions and guidance for future work.",
        "keywords": "web programming; rich internet applications; mobile devices",
        "released": 2009,
        "link": "https://doi.org/10.1145/1529282.1529321"
    },
    {
        "title": "Fine-grained, structured configuration management for web projects",
        "abstract": "Researchers in Web engineering have regularly noted that existing Web application development environments provide little support for managing the evolution of Web applications. Key limitations of Web development environments include line-oriented change models that inadequately represent Web document semantics and in ability to model changes to link structure or the set of objects making up the Webapplication. Developers may find it difficult to grasp how theoverall structure of the Web application has changed over time and may respond by using ad hoc solutions that lead to problems of maintain ability, quality and reliability. Web applications are software artifacts, and as such, can benefit from advanced version control and software configuration management (SCM)technologies from software engineering. We have modified an integrated development environment to manage the evolution and maintenance of Web applications. The resulting environment is distinguished by itsfine-grained version control framework, fine-grained Web contentchange management, and product versioning configuration management, in which a Web project can be organized at the logical level and itsstructure and components are versioned in a fine-grained manner aswell. This paper describes the motivation for this environment as well as its user interfaces, features, and implementation.",
        "keywords": "web engineering; version control; software configuration management",
        "released": 2004,
        "link": "https://doi.org/10.1145/988672.988731"
    },
    {
        "title": "Craftopolis: Blending tangible, informal construction into virtual multiuser communities",
        "abstract": "The last decade has seen a blossoming of creative online activities for children in which groups, or communities, of youngsters participate within (e.g.) multiplayer games, social networks, shared programming environments, and so forth. Despite the marvelous features of these environments, they all share the limitation of being exclusively \"virtual\" in their design: children can play in virtual worlds, create virtual buildings and farms, or design programs, but they cannot experiment or create with tangible materials in these activities. In this paper, we present a prototype of a shared online children’s \"world\" in which the basic elements are tangible, informal, \"rooms\" or constructions that can be controlled computationally and accessed over the World Wide Web. This system, Craftopolis, enables users to make their own computationally-enriched physical models (e.g., of dollhouse rooms, dioramas, game boards, and so forth), using any materials whatever, and to link those rooms into a shared online space.",
        "keywords": "tangible interaction; multiuser environments; children’s crafts; Craftopolis",
        "released": 2010,
        "link": "https://doi.org/10.1145/1810543.1810581"
    },
    {
        "title": "Accelerating haskell array codes with multicore GPUs",
        "abstract": "Current GPUs are massively parallel multicore processors optimised for workloads with a large degree of SIMD parallelism. Good performance requires highly idiomatic programs, whose development is work intensive and requires expert knowledge.To raise the level of abstraction, we propose a domain-specific high-level language of array computations that captures appropriate idioms in the form of collective array operations. We embed this purely functional array language in Haskell with an online code generator for NVIDIA’s CUDA GPGPU programming environment. We regard the embedded language’s collective array operations as algorithmic skeletons; our code generator instantiates CUDA implementations of those skeletons to execute embedded array programs.This paper outlines our embedding in Haskell, details the design and implementation of the dynamic code generator, and reports on initial benchmark results. These results suggest that we can compete with moderately optimised native CUDA code, while enabling much simpler source programs.",
        "keywords": "skeletons; haskell; gpgpu; dynamic compilation; data parallelism; arrays",
        "released": 2011,
        "link": "https://doi.org/10.1145/1926354.1926358"
    },
    {
        "title": "End user software engineering: Chi’2008 special interest group meeting",
        "abstract": "End users create software whenever they write, for instance, educational simulations, spreadsheets, or dynamic e-business web applications. Researchers are working to bring the benefits of rigorous software engineering methodologies to these end users to try to make their software more reliable. Unfortunately, errors are pervasive in end-user software, and the resulting impact is sometimes enormous. This special interest group meeting has two purposes: to incorporate attendees’ and feedback into an emerging survey of the state of this interesting new sub-area, and generally to bring together the community of researchers who are addressing this topic, with the companies that are creating end-user programming tools.",
        "keywords": "psychology of programming; natural programming; end-user software engineering (euse); end users shaping effective software (euses); empirical studies of programmers (esp)",
        "released": 2008,
        "link": "https://doi.org/10.1145/1358628.1358687"
    },
    {
        "title": "ArTEMiS: An automatic assessment management system for interactive learning",
        "abstract": "The increasing number of students in computer science courses leads to high efforts in manual assessment of exercises. Existing assessment systems are not designed for exercises with immediate feedback in large classes. In this paper, we present an AuTomated assEssment Management System for interactive learning.ArTEMiS assesses solutions to programming exercises automatically and provides instant feedback so that students can iteratively solve the exercise. It is open source and highly scalable based on version control, regression testing and continuous integration. ArTEMiS offers an online code editor with interactive exercise instructions, is programming language independent and applicable to a variety of computer science courses. By using it, students gain experiences in version control, dependency management and continuous integration.We used ArTEMiS in 3 university and 1 online courses and report about our experiences. We figured out that ArTEMiS is suitable for beginners, helps students to realize their progress and to gradually improve their solutions. It reduces the effort of instructors and enhances the learning experience of students.",
        "keywords": "version control; programming exercises; online editor; online courses; interactive exercise instructions; instant feedback; in-class exercises; continuous integration; automated assessment",
        "released": 2018,
        "link": "https://doi.org/10.1145/3159450.3159602"
    },
    {
        "title": "Tamacola — a meta language kit for the web: A report on creating a self-hosting lisp compiler on the tamarin VM",
        "abstract": "Tamacola is a dynamic, self-sustaining meta-language system grounded upon the Tamarin VM. Tamacola compiles a Scheme-like S-expression language into ActionScript bytecodes, and contains meta-linguistic features, such as a PEG parser generator and macro system, which make it useful for defining new languages. In fact, Tamacola is written in itself, using its meta-linguistic features.Since the Tamarin VM can load ActionScript bytecode files to extend and replace running programs, Tamacola can extend itself and define new languages while it is running. Furthermore, since the Tamarin VM is part of the ubiquitous Adobe Flash player, this self-modification can be accomplished while running in a web browser, with no extra installation requirement.Objects in Tamacola are intimately tied to their Action-Script counterparts, providing good interoperability between Tamacola and the Flash Player. To show that the system is ready for practical use, we used Tamacola to implement both an interactive programming environment (\"Workspace\") and a simple particle language.",
        "keywords": "self hosting; compiler; Adobe Flash",
        "released": 2010,
        "link": "https://doi.org/10.1145/1942793.1942799"
    },
    {
        "title": "Designing for cognitive diversity: Improving the GitHub experience for newcomers",
        "abstract": "Social coding platforms such as GitHub have become defacto environments for collaborative programming and open source. When these platforms do not support specific cognitive styles, they create barriers to programming for some populations. Research shows that the cognitive styles typically favored by women are often unsupported, creating barriers to entry for woman newcomers. In this paper, we use the GenderMag method to evaluate GitHub to find cognitive style-specific inclusivity bugs. We redesigned the \"buggy\" GitHub features through a web browser plugin, which we evaluated through a between-subjects experiment (n=75). Our results indicate that the changes to the interface improve users’ performance and self-efficacy, mainly for individuals with cognitive styles more common to women. Our results can inspire designers of social coding platforms and software engineering tools to produce more inclusive development environments.Diversity is an important aspect of society. One form of diversity is cognitive diversity—differences in cognitive styles, which helps generate a diversity of thoughts. Unfortunately, software tools often do not support different cognitive styles (e.g., learning styles), disproportionately impacting those whose styles are not supported. These individuals pay a cognitive \"tax\" each time they use the tools. In this work, we found \"inclusivity bugs\" in GitHub, a social coding platform. We then redesigned these buggy features and evaluated them with users. Our results show that the redesign makes it easier for the group of individuals whose cognitive styles were unsupported in the original design, with the percentage of completed tasks rising from 67",
        "keywords": "human-computer interaction; cognitive styles; human factors; diversity and inclusion; open source",
        "released": 2023,
        "link": "https://doi.org/10.1109/ICSE-SEIS58686.2023.00007"
    },
    {
        "title": "Accessibility support in web frameworks",
        "abstract": "Despite the existence of accessibility testing tools, software still largely inaccessible mainly due to lack of awareness among developers and issues with existing tools [14, 18]. This motivated us to evaluate the accessibility support of development tools that do not require specific accessibility knowledge such as web frameworks. We tested the accessibility support of three JavaScript web frameworks; Angular, React, and Vue. For each of the three frameworks, we built a web application with 32 pages, each of which violated a single accessibility guideline. We found that only React generated a warning for one of the accessibility violations that is lack of label for non-text content. The rest of the accessibility violations went unnoticed by the three frameworks.",
        "keywords": "accessibility guidelines; web frameworks",
        "released": 2021,
        "link": "https://doi.org/10.1145/3441852.3476531"
    },
    {
        "title": "EduCo: An integrated social environment for teaching and learning software engineering courses",
        "abstract": "There have been studies suggesting that collaboration and cooperation can deliver higher performance than competition or individual work. The Web does not only provide ubiquitous access to resources and computation power but also can be an open structure for better and continuous collaboration. In this study, we introduce our vision and construction of an integrated social environment called EduCo to assist teaching and learning software engineering courses. EduCo is a Web environment for instructors to teach and for students to learn and practice designing, programming, and managing software in software engineering courses. It is also a social network platform that helps stimulate participation, interaction, sharing, awareness, accountability, and teamwork. This paper describes the initial construction of the system with many core capabilities realized. The paper also presents our case studies from applying the system to several programming language classes. The results from the case studies suggest that the system has the potential to encourage students’ participation and satisfaction. In addition, this paper presents our vision for future enhancements of the system with core capabilities such as feeds, dashboards, notifications, tracking, and reporting.",
        "keywords": "Web; Software design tool; Social network; Project management; Collaborative development environment",
        "released": 2014,
        "link": "https://doi.org/10.1145/2684200.2684280"
    },
    {
        "title": "SeeSS: Seeing what i broke – visualizing change impact of cascading style sheets (css)",
        "abstract": "Cascading Style Sheet (CSS) is a fundamental web language for describing the presentation of web pages. CSS rules are often reused across multiple parts of a page and across multiple pages throughout a site to reduce repetition and to provide a consistent look and feel. When a CSS rule is modified, developers currently have to manually track and visually inspect all possible parts of the site that may be impacted by that change. We present SeeSS, a system that automatically tracks CSS change impact across a site and enables developers to easily visualize all of them. The impacted page fragments are sorted by severity and the differences before and after the change are highlighted using animation.",
        "keywords": "world wide web and hypermedia; web development; toolkits; development tools; cascading style sheet",
        "released": 2013,
        "link": "https://doi.org/10.1145/2501988.2502006"
    },
    {
        "title": "Web service creation in SOA based on the gSOAP",
        "abstract": "This paper expounds the concepts and thoughts of SOA, and analyzes the conceivable methods of implementing the SOA, and points out the possibility of using the WEB services to implement the SOA. On the question of how to develop the WEB services, this paper uses the open source development tool gSOAP to achieve it.We make the detailed introduction to the thoughts and process of WEB service using the gSOAP, and provide an example to verify the feasibility of the development.",
        "keywords": "gSOAP; Web Services; SOA",
        "released": 2021,
        "link": "https://doi.org/10.1145/3443467.3443880"
    },
    {
        "title": "Towards automated code assessment with OpenJupyter in MOOCs",
        "abstract": "The popularity of Massive Open Online Courses (MOOCs) as a means of delivering education to large numbers of students has been growing steadily over the last decade. As technology improves, more educational content is becoming readily available to the public. JupyterLab, an open-source web-based interactive development environment (IDE), is also becoming increasingly popular in education, however, it is so far primarily used in small classroom settings. JupyterLab can provide a more interactive, hands-on, and collaborative learning experience for students in MOOCs, and it is highly customizable and can be accessed from anywhere. To capitalize on these benefits, we have developed OpenJupyter, which integrates JupyterLab at scale with MOOCs, enhancing the student learning experience and providing hands-on exercises for data science courses, making them more interactive and engaging. While MOOCs provide access to education for a large number of students, one of the significant challenges is providing effective and timely feedback to learners.&nbsp;OpenJupyter includes an auto-assessment capability that addresses this problem in MOOCs by automating the evaluation process and providing feedback to learners in a timely manner. In this paper, we provide an overview of the architecture of OpenJupyter, its scalability in the context of MOOCs, and its effectiveness in addressing the auto-assessment challenge. We also discuss the Advantages and limitations associated with using OpenJupyter in a MOOC context and provide a reference for educators and researchers who wish to implement similar tools. Our efforts aim to foster an open educational environment in the field of programming by providing learners with an interactive learning tool and a streamlined technical setup, allowing them to acquire and test their knowledge at their own pace.",
        "keywords": "JupyterLab; MOOC; auto-assessment; openjupyter; programming",
        "released": 2023,
        "link": "https://doi.org/10.1145/3573051.3596180"
    },
    {
        "title": "Studying programmer behaviour at scale: A&nbsp;case&nbsp;study&nbsp;using&nbsp;amazon mechanical turk",
        "abstract": "Developing and maintaining a correct and consistent model of how code will be executed is an ongoing challenge for software developers. However, validating the tools and techniques we develop to aid programmers can be a challenge plagued by small sample sizes, high costs, or poor generalisability. This paper serves as a case study using a web-based crowdsourcing approach to study programmer behaviour at scale. We demonstrate this method to create controlled coding experiments at modest cost, highlight the efficacy of this approach with objective validation, and comment on notable findings from our prototype experiment into one of the most ubiquitous, yet understudied, features of modern software development environments: syntax highlighting.",
        "keywords": "behaviour; crowdsourcing; programming",
        "released": 2021,
        "link": "https://doi.org/10.1145/3464432.3464436"
    },
    {
        "title": "GPE4CGSP: Interoperability between heterogeneous grid infrastructures",
        "abstract": "In this paper we present GPE4CGSP, which targets the interoperability between GPE (Grid Programming Environment) and CGSP (ChinaGrid Support Platform). The web services technique and gridftp data transfer protocol are used to implement the interoperation between GPE and CGSP. Grid application can be deployed to CGSP through GPE. Without modification, GPE client can freely visit and use the resources in CGSP. Typically, end users can submit jobs to CGSP through GPE application client. GPE4CGSP provides one feasible way for the interoperability of heterogeneous grid infrastructures. The evaluation proves that the job execution time of GPE4CGSP is less than that of GPE4GTK.",
        "keywords": "middleware; interoperability; grid",
        "released": 2007,
        "link": "https://doi.org/10.1145/1375783.1375808"
    },
    {
        "title": "EcoSim: A language and experience teaching parallel programming in elementary school",
        "abstract": "Traditional introductory programming classes teach sequential programming using a single-threaded programming model. It is typical to wait until a student has developed proficiency in sequential programming before teaching parallel programming. As computer hardware becomes increasingly parallel, there is a greater need for software engineers who are proficient in designing parallel programs, and not just by \"parallelizing\" sequential designs. Teaching parallelism first is an important step towards educating tomorrow’s programmers.We present an overview of a five-day introductory parallel programming course. We taught the course to nine and ten year-olds with no prior programming experience. Our course utilized a fundamentally parallel language we designed for the course, one with a near-natural language syntax that exposed the parallel processors throughout the code. This language, coupled with an interactive online programming environment, allowed us to teach a wide range of parallel programming concepts in a very limited timeframe.We also present examples of student-written code that demonstrates their understanding of some basic parallel programming concepts, and we describe the overall course goal and specific lesson plans geared towards teaching students how to \"think parallel.\"",
        "keywords": "readability; pedagogy; parallel languages; introductory programming; instructional design; elementary school; education; concurrent languages; K-12",
        "released": 2012,
        "link": "https://doi.org/10.1145/2157136.2157155"
    },
    {
        "title": "Online programming exams - an experience report",
        "abstract": "When seeking to maximise the authenticity of assessment in programming courses it makes sense to provide students with practical programming problems to solve in an environment that is close to real software development practice, i.e., online, open book, and using their typical development environment. This creates an assessment environment that should afford students sufficient opportunities to evidence what they have learned, but also creates practical challenges in terms of academic integrity, flexibility in the automated grading process, and assumptions surrounding how the student may attempt to solve the problems both in terms of correct and incorrect solutions. In this experience report, we outline two independently observed cohorts of students sitting the same Java programming exam, with different weights, over three years. This is undertaken as a reflective exercise in order to derive a series of recommendations and retrospectively obvious pitfalls to act as guidance for educators considering online programming exams for large (i.e. n &gt; 150) introductory programming courses. After discussing our assessment methodology, we provide 4 high-level observations and centre a set of recommendations around these to aid practitioners in their assessment design.",
        "keywords": "authentic assessment; plagiarism; programming; video",
        "released": 2023,
        "link": "https://doi.org/10.1145/3587102.3588829"
    },
    {
        "title": "Flexible, reusable tools for studying novice programmers",
        "abstract": "We would like more computer science education research studies to be easily replicable. Unfortunately, the tools used for data collection are often too specialized, unstable, or just plain unavailable for use in experimental replication. Here, we present two tools to aid in the replication and extension of existing research regarding novice programmers–or to support entirely new and unrelated enquiries. The first tool is specific to the BlueJ pedagogic programming environment, and provides a starting point for replicating or extending existing studies regarding novice programmers learning Java. The second tool is a portable, stand-alone web-server with a language-agnostic interface for storing data. The distinguishing feature of this server is that it is schema free, meaning it can easily support a wide range of data collection projects simultaneously with no reconfiguration whatsoever.",
        "keywords": "tools; data logging; blueJ; CS education research",
        "released": 2009,
        "link": "https://doi.org/10.1145/1584322.1584328"
    },
    {
        "title": "Searching live meeting documents \"show me the action\"",
        "abstract": "Live meeting documents require different techniques for effectively retrieving important pieces of information. During live meetings, people share web sites, edit presentation slides, and share code editors. A simple approach is to index with Optical Character Recognition (OCR) the video frames, or key-frames, being shared and let user retrieve them. Here we show that a more useful approach is to look at what actions users take inside the live document streams. Based on observations of real meetings, we focus on two important signals: text editing and mouse cursor motion. We describe the detection of text and cursor motion, their implementation in our WebRTC (Web Real-Time Communication)-based system, and how users are better able to search live documents during a meeting based on these extracted actions.",
        "keywords": "video conferencing; screen-sharing; real-time search; ocr; live document search; indexing",
        "released": 2015,
        "link": "https://doi.org/10.1145/2682571.2797082"
    },
    {
        "title": "User-evolvable tools in the web",
        "abstract": "Self-supporting development environments like Smalltalk and Emacs can be used to directly evolve themselves, making their tools very malleable and adaptable. In Web-based software development environments users can collaborate in creating software without having to install the environment locally. Bringing these two together and making Web-based environments self-supportive is challenging, since users have to take care of to breaking the system, since there might be others using it also. Environments aimed at end-users usually provide a scripting level above the base system. Instead of providing users with a fixed set of tools, we propose to make the tools user-evolvable by building them as scriptable objects in a shared user editable repository. In our system, the Lively Kernel, the core system is developed using modules and classes, and on top of it users create active content by directly manipulating and scripting objects. By leveraging the scripting level for the development of tools themselves, we allow users to adapt their tools in a self-supporting way, without the need to invasively change the system’s core. In this paper we show how development tools in Lively are collaboratively evolved. Tools can be directly explored, adapted, and published in a shared manner while they are being used.",
        "keywords": "",
        "released": 2013,
        "link": "https://doi.org/10.1145/2491055.2491074"
    },
    {
        "title": "End-user mashup programming: Through the design lens",
        "abstract": "Programming has recently become more common among ordinary end users of computer systems. We believe that these end-user programmers are not just coders but also designers, in that they interlace making design decisions with coding rather than treating them as two separate phases. To better understand and provide support for the programming and design needs of end users, we propose a design theory-based approach to look at end-user programming. Toward this end, we conducted a think-aloud study with ten end users creating a web mashup. By analyzing users’ verbal and behavioral data using Schön’s reflection-in-action design model and the notion of ideations from creativity literature, we discovered insights into end-user programmers’ problem-solving attempts, successes, and obstacles, with accompanying implications for the design of end-user programming environments for mashups. The contribution of our work is three-fold: 1) the methodology of using a design lens to view programming, 2) evidence, through insights gained, of the usefulness of this approach, and 3) the implications themselves.",
        "keywords": "mashups; end-user programming; design",
        "released": 2010,
        "link": "https://doi.org/10.1145/1753326.1753477"
    },
    {
        "title": "Making mashups with marmite: Towards end-user programming for the web",
        "abstract": "There is a tremendous amount of web content available today, but it is not always in a form that supports end-users’ needs. In many cases, all of the data and services needed to accomplish a goal already exist, but are not in a form amenable to an end-user. To address this problem, we have developed an end-user programming tool called Marmite, which lets end-users create so-called mashups that re-purpose and combine existing web content and services. In this paper, we present the design, implementation, and evaluation of Marmite. An informal user study found that programmers and some spreadsheet users had little difficulty using the system.",
        "keywords": "web services; spreadsheet; mashup; end-user programming",
        "released": 2007,
        "link": "https://doi.org/10.1145/1240624.1240842"
    },
    {
        "title": "Introducing abstraction and decomposition to novice programmers",
        "abstract": "This paper discusses a learning exercise we use in our beginning programming classes to introduce students to the concepts of abstraction and decomposition. The assignment is to write a perpetual calendar generation program: given a month and a year the program will display the correct monthly calendar. The learning goals of the exercise include how to decompose a large problem into smaller pieces and how to specify what each piece needs to do. This exercise helps students learn the process of incremental and iterative development. More than the actual solution, the value of this exercise is in the several themes of software development that are discussed during its development. We have successfully used this assignment for several years in a variety of CS1/CS2 programming environments (Pascal, C, Java and .net) and also as a Java servlet based web application exercise. Over this period, the case-study has received very favorable feedback from students as to its interestingness and pedagogical value.",
        "keywords": "programming case study; cs1/cs2",
        "released": 2009,
        "link": "https://doi.org/10.1145/1562877.1562939"
    },
    {
        "title": "Web matrix: Preliminary experiences in its use to introduce programming to non-majors",
        "abstract": "Web Matrix is Microsoft’s free software development tool. Although it does not have all of the features of Visual Studio it is well suited to introducing students to object-oriented programming and the .NET framework. Students in four sections of a non-majors course at a state university were successful in completing an assignment with Web Matrix and in putting the resulting .aspx files on a remote Web server. None of the limitations of Web Matrix (compared to Visual Studio) compromised its value as a teaching tool at this level of instruction. Some of the qualities of Web Matrix may actually make it preferable to Visual Studio for introductory teaching purposes.Web Matrix is a Microsoft integrated development environment (IDE) including visual development and automatic code generation available as a free download from http://www.asp.net. It is the result of the \"Web Matrix Project\" initiated by a small team of ASP.NET developers at Microsoft Corporation, lead by Scott Guthrie and Nikhil Korthari. What began as primarily an internal testing tool evolved quickly into a popular personal development environment for the development of ASP.NET applications and Web services. It also includes support for development of applications for mobile devices. It requires no product registration and comes with its own personal Web server. Now in its second version, the tool provides developers a quick and easy way to create small .NET projects and, in our opinion, has features and qualities that make it an excellent teaching tool.",
        "keywords": "",
        "released": 2004,
        "link": "https://dl.acm.org/doi/10.5555/1041530.1041551"
    },
    {
        "title": "From computational thinking to computational values",
        "abstract": "SIGCSE members love the beauty of computational thinking. They know the joy of bringing those ideas to young people. That love for computational thinking entails respect for the computational values that empower people in the digital world. For academics, those values have been central to the flowering of computing as an intellectual endeavor. Today, those values are increasingly threatened by stresses from both within and outside academia: squabbles over who owns academic work, increasingly stringent and overreaching intellectual property laws, and the replacement of open computing platforms by closed applications and walled-garden application markets.In this talk I’ll describe some things we’ve done at MIT to support computational values, like open publication of all our course materials, our faculty policy on open publication of academic research, and our recently announced initiative for open online instruction based on non-proprietary software platforms. I’ll discuss Creative Commons licensing and Free Software, and the importance of tinkerability for empowering citizens in an information society. And I’ll describe App Inventor for Android, a new programming tool motivated by the vision that all of us us can experience mobile computing as creators using tools that we can control and reshape, rather than only as consumers of packaged applications.",
        "keywords": "keynote",
        "released": 2012,
        "link": "https://doi.org/10.1145/2157136.2157206"
    },
    {
        "title": "Embedding social networking information into jazz to foster group awareness within distributed teams",
        "abstract": "A Collaborative Development Environments (CDE) provides a project workspace with a standardized toolset to help distributed development teams cope with geographical distance. However, there is a lack of support to reduce socio-cultural distance, which poses practical barriers to the development of connections and shared context/culture between team members. The rise of the Social Web has created several opportunities to publish personal information, often further composed through Web mashups, which can be regarded as a valuable data source in order to establish a shared context among remote developers, with little or no chances to meet.In this paper we present our preliminary work that aims to provide distributed software teams with overall, contextual awareness aggregated in one place. Using the IBM Jazz as CDE, which already provides both presence and workspace awareness, we leveraged the FriendFeed aggregator service to embed personal information about distributed co-workers, collected from social networks. Disseminating additional group awareness information to developers, who have little or no chances to meet, can help to speed up the establishment of organizational values, attitudes, and trust-based inter-personal connections.",
        "keywords": "web 2.0; social web; mashup; jazz; group awareness; eclipse; collaborative development environment; cde",
        "released": 2009,
        "link": "https://doi.org/10.1145/1595836.1595842"
    },
    {
        "title": "Sketching interactive systems with sketchify",
        "abstract": "Recent discussions in the interaction design community have called attention to sketching as an omnipresent element of any disciplined activity of design, and have pointed out that sketching should be extended beyond the simple creation of a pencil trace on paper. More specifically, the need to deal with all attributes of a user experience, especially the timing, phrasing, and feel of the interaction, has been identified. In this article, we propose extending the concept of sketching with a pencil on paper to the more generic concept of fluent exploration of interactive materials. We define interactive materials as any piece of software or hardware that represents or simulates a part of the interactive user experience, such as input from sensors, output in the form of sound, video, or image, or interaction with Web services or specialized programs. We have implemented the proposed concept within Sketchify, a tool for sketching user interfaces. Sketchify gives designers the freedom to manipulate interactive materials by combining elements of traditional freehand sketching with functional extensions and end-user programming tools, such as spreadsheets and scripting. We have evaluated Sketchify in the education of interaction designers, identifying both successful aspects and aspects that need further improvements.",
        "keywords": "user interface software tools; rapid prototyping; interaction design; design process; Sketching",
        "released": 2011,
        "link": "https://doi.org/10.1145/1959022.1959026"
    },
    {
        "title": "Through the looking-glass: From performance observation to dynamic adaptation",
        "abstract": "Since the beginning of “high-performance” parallel computing, observing and analyzing performance for purposes of finding bottlenecks and identifying opportunities for improvement has been at the heart of delivering the performance potential of next-generation scalable systems. Interestingly, it is the ever-changing parallel computing landscape that is the main driver of requirements for parallel performance technology and the improvements necessary beyond the current state-of-the-art. Indeed, the development and application of our TAU Performance System over many years largely follows an evolutionary path of addressing measurement and analysis problems in new parallel machines and programming environments. However, the outlook to future parallel systems with high degrees of concurrency, heterogeneous components, dynamic runtime environments, asynchronous execution, and power constraints suggests a new perspective will be needed on the role of performance observation and analysis in respect to tool technology integration and performance optimization methods. The reliance on post-mortem analysis of application-level (\"1st person\") performance measurements is prohibitive for exascale-class machines because of the performance data volume, the primitive basis for performance data attribution, and the fundamental problem of performance variation that will exist. Instead, it will be important to provide introspection support across the exascale software stack to understand how system (\"3rd person\") resources are used during execution. Furthermore, the opportunity to couple a global performance introspection capability (a \"performance backplane\") with online performance decision analytics inspires the concept of an autonomic performance system that can feed back policy-based decisions to guide the computation to better states of execution. The talk will explore these issues by giving a brief retrospective on performance tool evolution, setting the stage for current research projects where a new performance perspective is being pursued. It will also speculate on what might be included in next-generation parallel systems hardware, specifically to make the exascale machines more performance-aware and dynamically-adaptive.",
        "keywords": "runtime environments; optimization methods; high-performance computing",
        "released": 2015,
        "link": "https://doi.org/10.1145/2749246.2749248"
    },
    {
        "title": "Introduction to computer science using alice 2.0: Tutorial presentation",
        "abstract": "This tutorial will introduce Alice 2.0, an interactive programming course developed at Carnegie Mellon University. This program is an ideal introductory high school or college one-semester Computer Science course. This program is especially useful for recruiting female students into the work of Computer Science. Alice is an innovative 3D programming environment that makes it easy to create an animation for telling a story, playing an interactive game, or a video to share on the web. Alice is a freely available teaching tool designed to be a student’s first exposure to object-oriented programming. In Alice’s interactive interface, students drag and drop graphic tiles to create a program, where the instructions correspond to standard statements in a production oriented programming language, such as Java. By manipulating the objects in their virtual world, students gain experience with all the programming constructs typically taught in an introductory programming course. Attendees will gain knowledge on how to incorporate Alice 2.0 into their introductory curriculum.",
        "keywords": "",
        "released": 2010,
        "link": "https://dl.acm.org/doi/10.5555/1734797.1734824"
    },
    {
        "title": "EdUCAS: An in-house CI/CD platform with cloud FPGAs for agilely conducting computer systems course projects",
        "abstract": "In recent years, there has been a rapidly growing recognition of the importance of conducting hands-on HW-SW co-design labs with real hardware (e.g., programmable logic chips named FPGAs) while studying computing curricula, especially the computer systems (CSys) courses. However, using FPGA is quite atime-consuming and error-prone process for students, and manipulating FPGA development tools and boards also distracts students and instructors. To overcome these obstacles and improve agility, we introduce an in-house platform named EdUCAS, in combination with the previously designed cloud FPGA servers for students to automatically conduct computer systems course projects. EdUCAS aims at enabling students to concentrate on their logic designs using hardware description language (e.g., Verilog HDL), without wasting useless time in FPGA tools and experimental environment.",
        "keywords": "course labs; computer systems course; FPGA development; CI/CD",
        "released": 2021,
        "link": "https://doi.org/10.1145/3456565.3460060"
    },
    {
        "title": "Seaweed: A web application for designing economic games",
        "abstract": "Seaweed is a web application for experimental economists with no programming background to design two-player symmetric games in a visual-oriented interface. Games are automatically published to the web where players can play against each other remotely and game play is logged so that the game’s designer can analyze the data. The design and implementation challenge in Seaweed is to provide an end user programming environment that creates games responsive to events and controlled by logic without the designer understanding programming concepts such as events and synchronization, or being burdened by specifying low-level programming detail. Seaweed achieves this by providing high-level visual representations for variables, control flow, and logic, and by automating behaviors for event handling, synchronization, and function evaluation. Seaweed’s evaluation demonstrates that Amazon’s Mechanical Turk (MTurk) is a viable platform for forming partnerships between people and paying them to perform cooperative tasks in real-time, cheaply and with high throughput",
        "keywords": "mechanical Turk; experimental economics; end-user programming",
        "released": 2009,
        "link": "https://doi.org/10.1145/1600150.1600162"
    },
    {
        "title": "Lively groups: Shared behavior in a world of objects without classes or prototypes",
        "abstract": "Development environments which aim to provide short feedback loops to developers must strike a balance between immediacy and the ability to abstract and reuse behavioral modules. The Lively Kernel, a self-supporting, browser-based environment for explorative development supports standard object-oriented programming with classes or prototypes, but also a more immediate, object-centric approach for modifying and programming visible objects directly. This allows users to quickly create graphical prototypes with concrete objects. However, when developing with the object-centric approach, sharing behavior between similar objects becomes cumbersome. Developers must choose to either abstract behavior into classes, scatter code across collaborating objects, or to manually copy code between multiple objects. That is, they must choose between less concrete development, reduced maintainability, or code duplication. In this paper, we propose Lively Groups, an extension to the object-centric development tools of Lively to work on multiple concrete objects. In our approach, developers may dynamically group live objects that share behavior using tags. They can then modify and program such groups as if they were single objects. Our approach scales the Lively Kernel’s explorative development approach from one to many objects, while preserving the maintainability of abstractions and the immediacy of concrete objects.",
        "keywords": "Web Applications; Lively Kernel; Interactive Systems; Explorative Development",
        "released": 2015,
        "link": "https://doi.org/10.1145/2846656.2846659"
    },
    {
        "title": "SageTalk: Designing a tool for designing successful web-based social agents",
        "abstract": "In this paper, we briefly describe a programming environment and platform for creating successful (engaging and useful) web- based social agents, and offer some general recommendations for others interested in generating programming and presentation environments that support the development of successful social agents.",
        "keywords": "social agents; design methodologies; conversational agents; agent tools",
        "released": 2001,
        "link": "https://doi.org/10.1145/375735.376094"
    },
    {
        "title": "Scratch-ed: An online community for scratch educators",
        "abstract": "Scratch is a programming environment that enables users to easily construct a wide variety of interactive projects - and share these creations with an online community. A main goal of Scratch is to enable young people to engage in construction-oriented acts of personal expression. From community narratives to role-playing games to mathematical simulations to consciousness-raising presentations, the potential for creative production with Scratch is boundless. However, for those who are primarily concerned with assisting others’ Scratch learning, there is a disconnect between what individuals want to do and the resources that are presently available. In response, we have developed Scratch-Ed, an online environment for educators. Using the lens of situated learning, Scratch-Ed has been designed to enable users to organize a community of practice for Scratch around the processes of mutual engagement, joint enterprise, and shared repertoire by sharing stories, exchanging resources, facilitating discussions, and establishing relationships.",
        "keywords": "",
        "released": 2009,
        "link": "https://dl.acm.org/doi/10.5555/1599503.1599529"
    },
    {
        "title": "Educational nonlinear stories with twine",
        "abstract": "Multiple studies have hinted at the positive effects of educational games on learner engagement. However, some games, if they exist, may not be readily usable for some lessons even though the same topics are covered. In this workshop, the participants will be introduced to Twine, an open-source development environment for nonlinear stories that requires little to no coding. Tips and tricks to making engaging stories that target desired learning outcomes derived from existing research will be shared. The participants will have the opportunity to apply these insights through a group activity where they create their stories for a lesson. They will then individually create games for their stories and share their works to the rest of the group. An online community will be created after the workshop for the participants to continue exchanging ideas or creations afterwards.",
        "keywords": "serious games; nonlinear stories; interactive storytelling; interactive narrative; interactive learning environment; gamification; educational games; branching narrative; Twine",
        "released": 2022,
        "link": "https://doi.org/10.1145/3491140.3528287"
    },
    {
        "title": "Hera presentation generator",
        "abstract": "Semantic Web Information Systems (SWIS) are Web Information Systems that use Semantic Web technologies. Hera is a model-driven design methodology for SWIS. In Hera, models are represented in RDFS and model instances in RDF. The Hera Presentation Generator (HPG) is an integrated development environment that supports the presentation generation layer of the Hera methodology. The HPG is based on a pipeline of data transformations driven by different Hera models.",
        "keywords": "semantic web; design environment; WIS; SWIS; RDF(S)",
        "released": 2005,
        "link": "https://doi.org/10.1145/1062745.1062814"
    },
    {
        "title": "Eclipse technology eXchange (ETX) workshop",
        "abstract": "The Eclipse platform (http://www.eclipse.org) is designed for building integrated development environments (IDEs) for object-oriented application development. Building on the success of the Eclipse Technology eXchange workshops at OOPSLA 2003, 2004, and 2005, we invite original papers that describe potential new uses of Eclipse and how the core Eclipse technology can be leveraged, improved and/or extended for research and teaching projects. Accepted papers will be presented at the workshop. Due to the popularity of this workshop in the past, this year’s ETX will be a 1.5 day event. Workshop topics include (but are not limited to) the use of Eclipse for: IDEs, supporting the software development process, debugging or testing, design requirements/specification, modeling environments or frameworks, aspect-oriented programming, program analysis and transformation, such as for refactoring, optimization, or obfuscation, computer-based learning, software engineering education, teaching foundations of object-oriented programming courseware, teaching an introductory undergraduate programming course, web service applications, rich client application.",
        "keywords": "",
        "released": 2006,
        "link": "https://doi.org/10.1145/1176617.1176635"
    },
    {
        "title": "Web application orchestration using excel",
        "abstract": "Form-based Web applications described in HTML can be easily used by end-users. In order to enable end-users to define a series of tasks by combining multiple Web resources, it is necessary to provide an orchestration environment for Web applications. A spreadsheet is one of the most popular applications for office workers. It provides an enduser programming environment. In this paper, we propose a spreadsheet-based environment for end-users to orchestrate multiple Web applications. First, we provide a method for embedding various Web resources in spreadsheet cells as visual components in order to reuse them on the spreadsheet. Second, we propose an access method for embedded components using the special function in the formula language. Our approach enables users to define the complex coordination of multiple Web applications on the spreadsheet using the formula language.",
        "keywords": "",
        "released": 2007,
        "link": "https://dl.acm.org/doi/10.5555/1331740.1331817"
    },
    {
        "title": "Construction of business english writing corpus based on data management system",
        "abstract": "A corpus is an electronic collection of texts representing a variant or text category of a language, according to certain sampling criteria. A parallel corpus is made up of the original text and its parallel counterpart in translation, and is most closely related to translation teaching and practice, providing a wealth of teaching material and a convenient means of translation. Business English writing is increasingly important as a language skill and a communicative skill. In order to give full play to the role of information technology, this paper constructs a parallel corpus of business English writing and proposes strategies to improve business English writing skills. The corpus is built on the SSH2 architecture, using IntelliJ IDEA Ultimate integrated development tool, Oracle as the database management system, Python and Java for programming, and Apache Tomcat as the web server, reflecting the advancement of the art technology.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1145/3510858.3510997"
    },
    {
        "title": "Introductory programming concepts with processing.js",
        "abstract": "Khan Academy recently started teaching introductory Computer Science topics with the Processing.js language and an interactive, web-based code editor. At UNC Asheville, we have been using a similar pedagogical approach for over a year. Specifically, we have integrated Processing.js into our introductory course for non-majors by building a web-based editor that makes it easy for students to edit, save and share their Processing.js sketches. This workshop offers a hands-on introduction to Processing.js and our editor. Participants will also be given an overview of the programming module in Creative Computing, our recently re-imagined CS0 course. Curious individuals with a laptop, a modern web-browser and some basic programming experience are welcome.",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2535418.2535449"
    },
    {
        "title": "Introducing computer science through animation and virtual worlds",
        "abstract": "We describe a course for non-majors that teaches computer science concepts and programming by creating simple animations and building 2D and 3D virtual worlds. Students work with scripting languages, an interactive programming environment, a programmable modeling environment, and finish with a simple programming language. Students work in pairs on computers during class. Each student creates a web portfolio to display their work.",
        "keywords": "",
        "released": 2002,
        "link": "https://doi.org/10.1145/563340.563411"
    },
    {
        "title": "EarSketch: A web-based environment for teaching introductory computer science through music remixing",
        "abstract": "EarSketch (http://earsketch.gatech.edu) is a free integrated curriculum, software toolset, audio loop library, and social sharing site that teaches computing principles through digital music composition and remixing. EarSketch students write code in either Python or JavaScript to make music, with a focus on popular genres such as hip hop and dubstep, while learning computing concepts such as variables, iteration, conditionals, strings, lists, functions, and recursion. Attendees to this demonstration session will be introduced to a new web-based version of EarSketch that integrates a code editor, digital audio workstation (DAW) music production interface, curriculum browser, and sharing service into a single integrated browser-based learning environment. This demo is of interest to secondary and early post secondary CS educators and to computing education researchers interested in STEAM and/or broadening participation. No prior musical knowledge or experience is expected and no prior programming experience with Python or JavaScript is required.",
        "keywords": "broadening participation; computer science principles; education; music composition; music production; remixing; steam",
        "released": 2015,
        "link": "https://doi.org/10.1145/2676723.2691869"
    },
    {
        "title": "Supporting dynamic, third-party code customizations in JavaScript using aspects",
        "abstract": "Web sites and web browsers have recently evolved into platforms on top of which entire applications are delivered dynamically, mostly as JavaScript source code. This delivery format has sparked extremely enthusiastic efforts to customize both individual web sites and entire browsers in ways the original authors never expected or accommodated. Such customizations take the form of yet more script dynamically injected into the application, and the current idioms to do so exploit arcane JavaScript features and are extremely brittle. In this work, we accept the popularity of extensions and seek better linguistic mechanisms to support them.We suggest adding to JavaScript aspect-oriented features that allow straightforward and declarative ways for customization code to modify the targeted application. Compared to most prior aspect-related research, our work has a different motivation and a different target programming environment, both of which lead to novel design and implementation techniques. Our aspect weaving is entirely integrated into a new dynamic JIT compiler, which lets us properly handle advice to first-class functions in the presence of arbitrary aliasing, without resorting to whole-program code transformations. Our prototype demonstrates that an aspect-oriented approach to web-application customization is often more efficient than current idioms while simplifying the entire process.",
        "keywords": "JavaScript; aspects; extensions",
        "released": 2010,
        "link": "https://doi.org/10.1145/1869459.1869490"
    },
    {
        "title": "App lab: A powerful JavaScript IDE for rapid prototyping of small data-backed web applications (abstract only)",
        "abstract": "App Lab (https://code.org/applab) is Code.org’s rapid-prototyping environment for creating HTML, CSS, and JavaScript-powered web applications. It was created as part of a rich set of instructional resources designed for teachers of the new AP Computer Science Principles (CSP) course. Yet, App Lab far exceeds the needs of CSP, and would be an appropriate learning environment for students in any CS0/CS1 class, even at the university level. App Lab gives novice programmers access to capabilities previously reserved for courses that require sophisticated tech setup and knowledge of both front and backend web development, server-side scripting, databases, etc. This demonstration aims to give a brief overview of App Lab and its purpose and then move quickly into demonstrating the more advanced features of App Lab that few people know are even there! The audience should come away with knowledge and access to exemplars that highlight App lab’s possibilities, and see some of its richer features in action. Finally we will end with a discussion about how best to integrate App Lab into existing courses.App Lab was developed as part of collaboration between Code.org and David Bau (Google), creator of PencilCode.net.",
        "keywords": "IDE; Javascript; K12; app lab; database; education; web applications",
        "released": 2017,
        "link": "https://doi.org/10.1145/3017680.3022382"
    },
    {
        "title": "Enriching the internet by acting and reacting",
        "abstract": "A recent trend in application development for the web is a move towards rich internet applications (RIAs). As more and more of the application logic is moved to the client, RIAs can benefit from concurrency in order to increase overall performance as well as responsiveness of the application. Additionally, RIAs are often written in an event-driven style of programming to react to incoming events of a multitude of services that are integrated within the application. In this paper we argue that, while individual technologies exist to tackle both concerns, these technologies cannot easily be integrated in an ad hoc way. To increase the modularisability and composability of RIAs we propose a new programming model based on actors and reactors that encapsulate different parts of the application. We show that our model is able to exploit some of the available concurrency while reducing the required amount of event-driven code. Both actors and reactors are modular components that can be glued together via a unified communication mechanism. We evaluate our approach by means of a motivating example of a collaborative code editor.",
        "keywords": "Actors; Distributed programming; JavaScript; Reactive programming; Reactors; Rich internet applications",
        "released": 2017,
        "link": "https://doi.org/10.1145/3079368.3079407"
    },
    {
        "title": "Nonprogrammer web application development",
        "abstract": "We propose to investigate the feasibility of nonprogrammer web application development. The main target audience for this research is webmasters without programming experience - a group likely to be interested in building web applications. We choose a subset of web applications as the target for our analysis: basic web-based data collection, storage &amp; retrieval applications. We propose to study the mental models of our target audience, collect requirements for a sufficiently powerful end-user programming tool, evaluate new programming paradigms, and implement a proof-of-concept prototype using participatory design techniques.",
        "keywords": "end-user programming; web application development; web engineering",
        "released": 2004,
        "link": "https://doi.org/10.1145/985921.985976"
    },
    {
        "title": "A qualitative study of animation programming in the wild",
        "abstract": "Scratch is the latest iteration in a series of animation tools aimed at teaching programming skills. Scratch, in particular, aims not only to teach technical skills, but also skills related to collaboration and code reuse. In order to assess the strengths and weaknesses of Scratch relative to these goals, we have performed an empirical field study of Scratch animations and associated user comments from the online animation repository. Overall, we found that Scratch represents substantial progress toward its designers’ goals, though we also identified several opportunities for significant improvement. In particular, many Scratch programs revealed significant technical mastery of the programming environment by programmers, and some animations even demonstrated design patterns. On the other hand, while the Scratch repository has successfully served as a supportive environment for generating constructive feedback among users, we did not find any occasions within our sample where this interaction led to online collaboration. In addition, we found low levels of code reuse, in terms of both frequency and success. Based on these results, we identify implications for improving the design of animation tools, for using these tools to teach programming skills, and for fostering successful collaboration and code reuse among end-user programmers.",
        "keywords": "animation; collaboration; end-user programming; repositories",
        "released": 2010,
        "link": "https://doi.org/10.1145/1852786.1852825"
    },
    {
        "title": "Animated transitions between user interface views",
        "abstract": "User interface development life cycle often involve several different views of the user interface over time either at the same level of abstraction or at different levels of abstraction. The relationship between these different views is often supported by tiling coordinated windows containing these related views simultaneously, thus leaving the developer with the responsibility to effectively and efficiently link the corresponding elements of these different views. This paper attempts to overcome the shortcomings posed by the coordinated visualization of multiple views by providing UsiView, a user interface rendering engine in which one single window ensures an animated transition between these different user interface views dynamically an internal view, an external view, and a conceptual view. Examples include the following cases: an authoring environment ensures an animated transition between an internal view (e.g., HTML5) and its external view (e. g., a web page), an Integrated Development Environment ensures an animated transition between its conceptual view and its external view; a model-driven engineering environment ensures an animated transition between the conceptual view at different levels of abstraction, e.g., from task to abstract user interface to concrete user interface until final user interface. The paper discusses the potential advantages of using animated transitions between user interface views during the development life cycle.",
        "keywords": "animated transition; animation; model evolution animation; user interface development method; user interface view",
        "released": 2012,
        "link": "https://doi.org/10.1145/2254556.2254623"
    },
    {
        "title": "Modeling the HTML DOM and browser API in static analysis of JavaScript web applications",
        "abstract": "Developers of JavaScript web applications have little tool support for catching errors early in development. In comparison, an abundance of tools exist for statically typed languages, including sophisticated integrated development environments and specialized static analyses. Transferring such technologies to the domain of JavaScript web applications is challenging. In this paper, we discuss the challenges, which include the dynamic aspects of JavaScript and the complex interactions between JavaScript, HTML, and the browser. From this, we present the first static analysis that is capable of reasoning about the flow of control and data in modern JavaScript applications that interact with the HTML DOM and browser API.One application of such a static analysis is to detect type-related and dataflow-related programming errors. We report on experiments with a range of modern web applications, including Chrome Experiments and IE Test Drive applications, to measure the precision and performance of the technique. The experiments indicate that the analysis is able to show absence of errors related to missing object properties and to identify dead and unreachable code. By measuring the precision of the types inferred for object properties, the analysis is precise enough to show that most expressions have unique types. By also producing precise call graphs, the analysis additionally shows that most invocations in the programs are monomorphic. We furthermore study the usefulness of the analysis to detect spelling errors in the code. Despite the encouraging results, not all problems are solved and some of the experiments indicate a potential for improvement, which allows us to identify central remaining challenges and outline directions for future work.",
        "keywords": "program analysis; scripting languages",
        "released": 2011,
        "link": "https://doi.org/10.1145/2025113.2025125"
    },
    {
        "title": "Efficient GPU sharing for serverless workflows",
        "abstract": "Serverless computing has emerged as a new cloud computing paradigm, where an application consists of individual functions that can be separately managed and executed. However, the function development environment of all serverless computing frameworks at present is CPU-based. In this paper, we propose to extend the open-sourced KNIX high-performance serverless framework so that it can execute functions on shared GPU cluster resources. We have evaluated the performance impacts on the extended KNIX system by measuring overheads and penalties incurred using different deep learning frameworks.",
        "keywords": "deep learning; gpu; image processing; neural networks; serverless",
        "released": 2021,
        "link": "https://doi.org/10.1145/3452413.3464785"
    },
    {
        "title": "Course management with TrucStudio",
        "abstract": "Ever growing expectations from students, university management and other stakeholders make course preparation increasingly time-consuming. Setting up a course from scratch requires producing many supporting documents such as syllabi, schedules, and course web sites listing the concepts being taught. This can be a considerable effort, taking time away from tasks with a more immediate pedagogical value, such as answering student questions and refining the concepts themselves.The TrucStudio course development framework supports a systematic approach to these necessary but arduous tasks. TrucStudio is organized like a modern programming environment, but its elements of discourse, rather than software modules, are units of knowledge such as notions, Trucs and clusters.In addition to course development, applications of TrucStudio include checking sound coverage of topics and comparing courses on an objective basis. This presentation focuses on two novel features of TrucStudio: version management of knowledge units and course information; and generation of output documents in various formats from knowledge units and other material managed by TrucStudio.",
        "keywords": "course design; curriculum design; knowledge modeling; output generation; versioning",
        "released": 2008,
        "link": "https://doi.org/10.1145/1384271.1384341"
    },
    {
        "title": "Automatic support for testing web-based enterprise applications",
        "abstract": "In this paper we consider the problem of automatically generating test suites associated with web-based enterprise systems. In particular, we discuss the construction of a tool deployed as a plugin for the popular open source Integrated Development Environment (IDE) Eclipse. Our tool allows developers to automatically generate and reuse test classes, test data, as well as manually define test data. Once these components are in place, developers can launch so-called \"in-container\" test suites, and gather information about the results by using the also popular (and open source) JUnit framework. All features are provided to the developer through a wizard-like graphical user interface embedded in the IDE. Our tool is available from &lt;u&gt;sourceforge.net&lt;/u&gt; under \"strutstest\".",
        "keywords": "Eclipse); Struts); applications - web-based systems (J2EE; methods and tools - testing tools (JUnit; software testing - automation",
        "released": 2006,
        "link": "https://doi.org/10.1145/1185448.1185521"
    },
    {
        "title": "External memory algorithms and data structures: Dealing with massive data",
        "abstract": "Data sets in large applications are often too massive to fit completely inside the computers internal memory. The resulting input/output communication (or I/O) between fast internal memory and slower external memory (such as disks) can be a major performance bottleneck. In this article we survey the state of the art in the design and analysis of external memory (or EM) algorithms and data structures, where the goal is to exploit locality in order to reduce the I/O costs. We consider a variety of EM paradigms for solving batched and online problems efficiently in external memory. For the batched problem of sorting and related problems such as permuting and fast Fourier transform, the key paradigms include distribution and merging. The paradigm of disk striping offers an elegant way to use multiple disks in parallel. For sorting, however, disk striping can be nonoptimal with respect to I/O, so to gain further improvements we discuss distribution and merging techniques for using the disks independently. We also consider useful techniques for batched EM problems involving matrices (such as matrix multiplication and transposition), geometric data (such as finding intersections and constructing convex hulls), and graphs (such as list ranking, connected components, topological sorting, and shortest paths). In the online domain, canonical EM applications include dictionary lookup and range searching. The two important classes of indexed data structures are based upon extendible hashing and B-trees. The paradigms of filtering and bootstrapping provide a convenient means in online data structures to make effective use of the data accessed from disk. We also reexamine some of the above EM problems in slightly different settings, such as when the data items are moving, when the data items are variable-length (e.g., text strings), or when the allocated amount of internal memory can change dynamically. Programming tools and environments are available for simplifying the EM programming task. During the course of the survey, we report on some experiments in the domain of spatial databases using the TPIE system (transparent parallel I/O programming environment). The newly developed EM algorithms and data structures that incorporate the paradigms we discuss are significantly faster than methods currently used in practice.",
        "keywords": "B-tree; I/O; batched; block; disk; dynamic; extendible hashing; external memory; hierarchical memory; multidimensional access methods; multilevel memory; online; out-of-core; secondary storage; sorting",
        "released": 2001,
        "link": "https://doi.org/10.1145/384192.384193"
    },
    {
        "title": "A semantic workflow authoring tool for programming grids",
        "abstract": "Workflows have an increasing role in scientific applications programming and business environment development because they are an effective technology to define composition of different pieces of knowledge, both in the application domain and in the business context. However, workflows are addressed in a number of different perspectives and no consensus has been reached yet on the language, modelling, and systems, to adopt in advanced contexts like Grid or semantic Web. In this paper, we describe a graphical tool for supporting different kinds of users in authoring workflows running on next generation Grids. The tool, named Semantic Workflow Programming Tool, is based on a reference workflow model that has been developed to provide advanced functionality with respect to the currently available workflow description. Design and functionality of the tool resulted from requirements and scenarios emerged in the EU funded NextGRID project, in whose context the tool is developed.",
        "keywords": "grid; semantics; workflow",
        "released": 2007,
        "link": "https://doi.org/10.1145/1273360.1273373"
    },
    {
        "title": "Linking sketches and diagrams to source code artifacts",
        "abstract": "Recent studies have shown that sketches and diagrams play an important role in the daily work of software developers. If these visual artifacts are archived, they are often detached from the source code they document, because there is no ad- equate tool support to assist developers in capturing, archiving, and retrieving sketches related to certain source code artifacts. This paper presents SketchLink, a tool that aims at increasing the value of sketches and diagrams created during software development by supporting developers in these tasks. Our prototype implementation provides a web application that employs the camera of smartphones and tablets to capture analog sketches, but can also be used on desktop computers to upload, for instance, computer-generated diagrams. We also implemented a plugin for a Java IDE that embeds the links in Javadoc comments and visualizes them in situ in the source code editor as graphical icons.",
        "keywords": "Diagrams; Documentation; Sketches; Source Code Artifacts",
        "released": 2014,
        "link": "https://doi.org/10.1145/2635868.2661672"
    },
    {
        "title": "Design and evaluation of \"the missing CS class,\" a student-led undergraduate course to reduce the academia-industry gap",
        "abstract": "One notable part of the academia-industry gap is the deficiency in computing ecosystem literacy, which may result in college graduates exhibiting little technical knowledge of software development tools and practices commonly used in industry. This paper presents our experience developing and teaching \"The Missing CS Class,\" the student-led 1-unit course that we created at our university to address computing ecosystem literacy. This course primarily targets lower-division students and, based on our observations as peer tutors, covers four common but crucial gaps in technical knowledge: (1) Unix-like command-line environments and tools, (2) Software testing and debugging, (3) Scripting, and (4) Version control. Based on the collected feedback from two consecutive offerings of this course during the winter and spring quarters of 2021, most surveyed students reported having increased their self-efficacy on all course topics and incorporated them into their software development workflow.To benefit the community at large, we have published all the lecture materials online at &lt;a href=\"https://missing.cs.ucdavis.edu\"&gt;https://missing.cs.ucdavis.edu&lt;/a&gt;.",
        "keywords": "academia-industry gap; computer science education; computing ecosystem literacy; student-led undergraduate course",
        "released": 2022,
        "link": "https://doi.org/10.1145/3478431.3499422"
    },
    {
        "title": "App inventor for android with studio-based learning",
        "abstract": "App Inventor for Android allows people with little or no programming experience to create smart phone applications on the Android platform. This is accomplished by using drag-and-drop UI design and blocks-oriented visual programming. We offered an experimental section during the closed beta testing of App Inventor for Android in which we used Studio-Based Learning to foster positive learning experiences. Studio-Based Learning is a pedagogical approach in which students build their own representations of their knowledge and share these, formally and informally, with both experts and peers. Our students worked in teams on several projects, with the sixteen students creating over thirty Android applications while learning fundamentals of Computer Science.In this paper, we provide the background and inspiration for this work, including a review of literature on Studio-Based Learning and a comparison of App Inventor for Android to other modern visual programming environments. An overview of our semester goals and course design are provided. From our experience and based on the literature, we conclude that App Inventor for Android and Studio-Based Learning make for a powerful combination to introduce non-CS majors to concepts of Computer Science-not just programming, but also ideas that tend not to be covered in conventional CS1 courses such as human-computer interaction, incremental and iterative design processes, collaboration, evaluation, and quality assurance. This paper complements the eponymous Web site at https://sites.google.com/site/appinventorsbl.",
        "keywords": "",
        "released": 2011,
        "link": "https://dl.acm.org/doi/10.5555/2037151.2037164"
    },
    {
        "title": "Enabling collaborative data science development with the ballet framework",
        "abstract": "While the open-source software development model has led to successful large-scale collaborations in building software systems, data science projects are frequently developed by individuals or small teams. We describe challenges to scaling data science collaborations and present a conceptual framework and ML programming model to address them. We instantiate these ideas in Ballet, the first lightweight framework for collaborative, open-source data science through a focus on feature engineering, and an accompanying cloud-based development environment. Using our framework, collaborators incrementally propose feature definitions to a repository which are each subjected to software and ML performance validation and can be automatically merged into an executable feature engineering pipeline. We leverage Ballet to conduct a case study analysis of an income prediction problem with 27 collaborators, and discuss implications for future designers of collaborative projects.",
        "keywords": "collaborative framework; data science; feature definition; feature engineering; feature validation; machine learning; mutual information; streaming feature selection",
        "released": 2021,
        "link": "https://doi.org/10.1145/3479575"
    },
    {
        "title": "Programming, problem solving, and self-awareness: Effects of explicit guidance",
        "abstract": "More people are learning to code than ever, but most learning opportunities do not explicitly teach the problem solving skills necessary to succeed at open-ended programming problems. In this paper, we present a new approach to impart these skills, consisting of: 1) explicit instruction on programming problem solving, which frames coding as a process of translating mental representations of problems and solutions into source code, 2) a method of visualizing and monitoring progression through six problem solving stages, 3) explicit, on-demand prompts for learners to reflect on their strategies when seeking help from instructors, and 4) context-sensitive help embedded in a code editor that reinforces the problem solving instruction. We experimentally evaluated the effects of our intervention across two 2-week web development summer camps with 48 high school students, finding that the intervention increased productivity, independence, programming self-efficacy, metacognitive awareness, and growth mindset. We discuss the implications of these results on learning technologies and classroom instruction.",
        "keywords": "computer science education; metacognition; problem-solving; programming",
        "released": 2016,
        "link": "https://doi.org/10.1145/2858036.2858252"
    },
    {
        "title": "End user software engineering: CHI 2007 special interest group meeting",
        "abstract": "Recently, researchers have been working to bring the benefits of rigorous software engineering methodologies to end users who find themselves in programming situations, to try to make their software more reliable. End users create software whenever they write, for instance, educational simulations, spreadsheets, or dynamic e-business web applications. Unfortunately, errors are pervasive in end-user software, and the resulting impact is sometimes enormous. This special interest group meeting has three purposes: to bring the results of a recent (February 2007) week-long \"Dagstuhl\" meeting on end-user software engineering to interested researchers at CHI; to incorporate attendees’ ideas and feedback into an emerging survey of the state of this interesting new subarea; and generally to bring together the community of researchers who are addressing this topic, with the companies that are creating end-user programming tools.",
        "keywords": "empirical studies of programmers (ESP); end users shaping effective software (EUSES); end-user software engineering (EUSE); natural programming; psychology of programming",
        "released": 2007,
        "link": "https://doi.org/10.1145/1240866.1240964"
    },
    {
        "title": "Programming web services on the cloud with node.js (abstract only)",
        "abstract": "Web services (a.k.a. web APIs) allow developers to build web and mobile applications using data from multiple online sources. This workshop is aimed at CS instructors that wish to teach how to use and write web services using Node.js on a cloud development environment. Node.js is an open source JavaScript platform that is currently used by companies like PayPal, DowJones, Walmart, Netflix, and Yahoo. Over 120 companies in the fortune 500 are not only using, but embracing Node.js in their everyday operations. Using and writing web services in Node.js is significantly easier than using other environments based on languages such as C# or Java. Because we will be using a cloud platform, all our tools are readily available through any modern web browser, thus eliminating the hassle related to installing a complete standalone development environment. Teaching web API design with Node.js on the cloud provides our students a relevant real life technical skill. Workshop participants will use the free service provided by Cloud9 IDE (https://c9.io/) to learn how to write scalable RESTful web services using Node.js, the Express web framework, MySQL, and jQuery. Participants should have a working knowledge of HTML, JavaScript, and SQL. Additional information available at: http://node.arielortiz.info/ Laptop required.",
        "keywords": "javascript; node.js; web development; web services",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2844703"
    },
    {
        "title": "The CloudScale method for software scalability, elasticity, and efficiency engineering: A tutorial",
        "abstract": "In cloud computing, software engineers design systems for virtually unlimited resources that cloud providers account on a pay-per-use basis. Elasticity management systems provision these resource autonomously to deal with changing workloads. Such workloads call for new objective metrics allowing engineers to quantify quality properties like scalability, elasticity, and efficiency. However, software engineers currently lack engineering methods that aid them in engineering their software regarding such properties. Therefore, the CloudScale project developed tools for such engineering tasks. These tools cover reverse engineering of architectural models from source code, editors for manual design/adaption of such models, as well as tools for the analysis of modeled and operating software regarding scalability, elasticity, and efficiency. All tools are interconnected via ScaleDL, a common architectural language, and the CloudScale Method that leads through the engineering process. In this tutorial, we execute our method step-by-step such that every tool and ScaleDL are briefly introduced.",
        "keywords": "cloud computing; cloudscale; efficiency; elasticity; engineering; method; metrics; scalability; software analysis; tutorial",
        "released": 2015,
        "link": "https://doi.org/10.1145/2668930.2688818"
    },
    {
        "title": "Lowering the development time of multimodal interactive application: The real-life experience of the XVR project",
        "abstract": "In this paper we present XVR, an integrated development environment for the rapid development of Virtual Reality applications. Using a modular architecture and a VR-oriented scripting language, XVR contents can be embedded on a variety of container applications. This makes it suitable to write contents ranging from web-oriented presentations to more complex VR installations involving advanced devices, such as real-time trackers, haptic interfaces, sensorized gloves and stereoscopic devices, including HMDs. Some case studies are also presented to illustrate the development processes related to XVR and its features.",
        "keywords": "3D graphics; 3D web; developer framework; virtual reality",
        "released": 2005,
        "link": "https://doi.org/10.1145/1178477.1178524"
    },
    {
        "title": "Cost-effective container orchestration using usage data",
        "abstract": "Recent cloud IDE services provide containers as development environment to users. Since users have little knowledge on specific tasks to run and computing resources required in their containers, it is difficult to decide exactly how many containers to allocate to the cloud instance. Cloud services often employ conservative managing policy to make the cloud instances to an appropriate level, and only increase the instances little by little when their services encounter resource problems. In addition, a simple container placement policy creates a situation where no more containers can be allocated, even though resources are available in some of cloud instances depending on their execution situations. To improve this, we place as many cloud instances as possible based on the predicted container usage, which is collected from the usage data of the containers on previous cloud instances. When a cloud instance has too much surplus resource, we also employ container migration to effectively manage overall cloud instances. By equipping our cloud service with an intelligent management policy, we can reduce the total number of cloud instances in use and increase the cost efficiency for our cloud service by 14.7",
        "keywords": "Container Orchestration; Docker Container; Predicted Resource Usage",
        "released": 2021,
        "link": "https://doi.org/10.1145/3426020.3426123"
    },
    {
        "title": "The fluid software metadata framework (FSM)",
        "abstract": "The Fluid Software Metadata (FSM) framework is a dynamic and flexible framework for software repository metadata generation and analysis. FSM aims to improve the setup time for the mining, analysis, and interactive visualisation of repository artefacts. FSM supports the integration of usability findings through XML-based usability reports. Viewing usability issues side-by-side with source code provides several advantages in holistic software development.",
        "keywords": "development tools; framework; metrics; software repositories; usability issues; visualisation; web interface",
        "released": 2010,
        "link": "https://doi.org/10.1145/1822018.1822074"
    },
    {
        "title": "Statically checking web API requests in JavaScript",
        "abstract": "Many JavaScript applications perform HTTP requests to web APIs, relying on the request URL, HTTP method, and request data to be constructed correctly by string operations. Traditional compile-time error checking, such as calling a non-existent method in Java, are not available for checking whether such requests comply with the requirements of a web API. In this paper, we propose an approach to statically check web API requests in JavaScript. Our approach first extracts a request’s URL string, HTTP method, and the corresponding request data using an inter-procedural string analysis, and then checks whether the request conforms to given web API specifications. We evaluated our approach by checking whether web API requests in JavaScript files mined from GitHub are consistent or inconsistent with publicly available API specifications. From the 6575 requests in scope, our approach determined whether the request’s URL and HTTP method was consistent or inconsistent with web API specifications with a precision of 96.0",
        "keywords": "JavaScript; static analysis; web APIs",
        "released": 2017,
        "link": "https://doi.org/10.1109/ICSE.2017.30"
    },
    {
        "title": "Mallard: Turn the web into a contextualized prototyping environment for machine learning",
        "abstract": "Machine learning (ML) can be hard to master, but what first trips up novices is something much more mundane: the incidental complexities of installing and configuring software development environments. Everyone has a web browser, so can we let people experiment with ML within the context of any webpage they visit? This paper’s contribution is the idea that the web can serve as a contextualized prototyping environment for ML by enabling analyses to occur within the context of data on actual webpages rather than in isolated silos. We realized this idea by building Mallard, a browser extension that scaffolds acquiring and parsing web data, prototyping with pretrained ML models, and augmenting webpages with ML-driven results and interactions. To demonstrate the versatility of Mallard, we performed a case study where we used it to prototype nine ML-based browser apps, including augmenting Amazon and Twitter websites with sentiment analysis, augmenting restaurant menu websites with OCR-based search, using real-time face tracking to control a Pac-Man game, and style transfer on Google image search results. These case studies show that Mallard is capable of supporting a diverse range of hobbyist-level ML prototyping projects.",
        "keywords": "contextualized machine learning; ml prototyping",
        "released": 2019,
        "link": "https://doi.org/10.1145/3332165.3347936"
    },
    {
        "title": "Creative computing: Introductory programming concepts with processing.js (abstract only)",
        "abstract": "Khan Academy recently announced that they will soon be teaching introductory Computer Science topics with the Processing.js language and an interactive, web-based code editor. At UNC Asheville, we have been using a similar pedagogical approach for over a year. Specifically, we have integrated Processing.js into our introductory course for non-majors by building an open-source, web-based editor which makes it easy for students to edit, save and share their Processing.js sketches. This workshop offers a hands-on introduction to Processing.js and our editor. Participants will also be given an overview of the programming module in Creative Computing, our recently re-imagined CS0 course. Curious individuals with a laptop, a modern web-browser and some basic programming experience are welcome.",
        "keywords": "computer science education; cs0; processing; processing.js",
        "released": 2013,
        "link": "https://doi.org/10.1145/2445196.2445500"
    },
    {
        "title": "TECHNOLOGY THAT EDUCATORS OF COMPUTING HAIL (TECH)using Cloud9, a powerful cloud-based IDE in the classroom",
        "abstract": "Welcome to the latest TECH column, a column that features a guest columnist, discussing technologies that educators find useful in their classrooms. The guest columnist is selected from those who have presented at a SIGCSE Technical Symposium session. This issue’s guest columnist, Jeff Solin, offers his ideas on Cloud9.",
        "keywords": "",
        "released": 2017,
        "link": "https://doi.org/10.1145/3043953"
    },
    {
        "title": "Ada+SQL—an overview",
        "abstract": "Ada+SQL is a programming environment for Ada 95 extended with basic SQL single user capabilities. It incorporates a very fast compiler and interpreter, with debugging options, library generator and browser, syntax template editors, programmer wizard, two-dimensional graphics, SQL interactive interface and hypertext documentation on the environment, Ada 95 and SQL. Several implementation aspects are discussed.",
        "keywords": "compilers; computer education; environments; interpreters; programming; relational databases",
        "released": 1999,
        "link": "https://doi.org/10.1145/319294.319319"
    },
    {
        "title": "Impact of contextual tips for auto-gradable programming exercises in MOOCs",
        "abstract": "Learners in Massive Open Online Courses offering practical programming exercises face additional challenges next to the actual course content. Beginners have to find approaches to deal with misconceptions and often struggle with the correct syntax while solving the exercises. The paper at hand presents insights from offering contextual tips in a web-based development environment used for practical programming exercises. We measured the effects of our approach in a Python course with 6,000 active students in a hidden A/B test and additionally used qualitative surveys. While a majority of learners valued the assistance, we were unable to show a direct impact on completion rates or average scores. We however noticed that users requesting tips took significantly longer and made more use of other assistance features of the platform than users in our control group. Insights from our study can be used to target beginners with more specific hints and provide additional, context-specific clues as part of the learning material.",
        "keywords": "MOOC; example; exercise; hint; programming; summary; tip",
        "released": 2021,
        "link": "https://doi.org/10.1145/3430895.3460166"
    },
    {
        "title": "Model-based automatic usability validation: A tool concept for improving web-based UIs",
        "abstract": "This paper describes an approach for improving automated usability tool support during the development of websites. Existing usability and accessibility validators only analyse the HTML code of a page when they create a report of possible problems. However, when a web engineering method is used to create a website, additional information is available in the form of models which describe the site. An automated validator can use these models to verify usability guidelines (such as \"text on the web page should be easy to understand by the target audience\") with higher accuracy. It can also perform automatic validation in situations where existent tools only output instructions for manual inspection by the developer. The paper systematically analyses existent guidelines and tools, and identifies ways in which the use of a model can improve verification quality. An extension to existing web engineering models is necessary to support automated checkers. It specifies properties of the users, the technical platform and the environment of use. A flexible approach allows the models to be used by validators running inside an integrated development environment, but also at a later time, without access to the development environment. Finally, the prototype of a model-based automatic usability validator is presented. It features verification of a number of guidelines which cannot be automated by existent validation approaches.",
        "keywords": "accessibility; automated validation; usability model; web engineering; web usability",
        "released": 2008,
        "link": "https://doi.org/10.1145/1463160.1463163"
    },
    {
        "title": "\"Is my mic on?\": Preparing SE students for collaborative remote work and hybrid team communication",
        "abstract": "Communication is essential for the success of student and professional software engineering (SE) team development projects. The projects delivered by SE courses provide valuable learning experiences for students because they teach industry-required skills such as teamwork, communication, and scheduling. Professional SE teams have adopted communication software such as Slack, Miro, Microsoft Teams, and GitHub Discussions to share files and convey information between team members. Likewise, they have distributed software development tools such as Visual Studio CodeSpaces and Jira to support productivity. In contrast, within academia, students have focused on having face-to-face meetings for team communication and communication tools for file sharing. Due to the COVID-19 pandemic, universities have been forced to switch to an online or hybrid modality abruptly, thus compelling SE students to quickly adopt communication software. This paper proposes a study on the use of communication software in industry to prepare students for remote software development positions after graduation.",
        "keywords": "SE pedagogy; collaboration; communication; hybrid teams; remote work",
        "released": 2021,
        "link": "https://doi.org/10.1109/ICSE-SEET52601.2021.00018"
    },
    {
        "title": "Incorporating accessibility in web interface development for deaf users",
        "abstract": "Initiatives about developing accessible software are important to support the construction of computational solutions that supply digital services and information for all users, including people with disabilities. Accessibility is a subcharacteristic of usability, which is a fundamental non-functional requirement for the quality of the final software product. Few efforts from the academy and industry have been spent to support developers to create web pages for deaf users. Our work intends to be a step forward in this direction by proposing a tool-supported accessibility recommendations guide. This guide helps developers in their development environment to build accessible software. A systematic, iterative and well-grounded methodology has been used to define the proposed guide. Two empirical studies were conducted to evaluate the usefulness of the guide for developing web pages for deaf users and the ease of use of the built pages. As a result, the proposed guide can contribute to incorporate accessibility in the development of web pages for deaf users, facilitating the understanding of the content available on these pages by this target audience.",
        "keywords": "accessibility; accessibility guidelines; accessible web interface; deaf; deafness",
        "released": 2021,
        "link": "https://doi.org/10.1145/3493244.3493246"
    },
    {
        "title": "SSELab: A plug-in-based framework for web-based project portals",
        "abstract": "Tools are an essential part of every software engineering project. But the number of tools that are used in all phases of the software development life-cycle and their complexity is growing continually. Consequently, the setup and maintenance of current tool chains and development environments requires much effort and consumes a lot of time. One approach to counter this, is to employ web-based systems for development tasks, because centralized systems simplify the administration and the deployment of new features. But desktop IDEs play an important role in software development projects today, and will not be replaced entirely by web-based environments in the near future. Therefore, supporting a mixture of hosted tools and tools integrated into desktop IDEs is a sensible approach.In this paper, we present the SSELab, a framework for web-based project portals that attempts to migrate more software development tools from desktop to server environments, but still allows their integration into modern desktop IDEs. It supports the deployment of tools as hosted services using plug-in systems on the server-side. Additionally, it provides access to these tools by a set of clients that can be used in different contexts, either from the command line, from within IDEs such as Eclipse, or from web pages. In the paper, we discuss the architecture and the extensibility of the SSELab framework. Furthermore, we share our experiences with creating an instance of the framework and integrating various tools for our own software development projects.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2667062.2667073"
    },
    {
        "title": "Essential components of mobile web accessibility",
        "abstract": "The Web Accessibility Initiative (WAI) of the World Wide Web Consortium (W3C) develops strategies, guidelines, and resources to make the Web accessible to people with disabilities. This includes ensuring that core web technologies such as HTML and CSS provide support for accessibility; developing complementary web specifications to support accessibility, such as WAI-ARIA and IndieUI; and maintaining a set of internationally recognized guidelines that define accessibility criteria for web authoring tools such as content management systems and code editors, for user agents such as web browsers and media players, and for web content including text, images, scripts, audio-visual media, and more. This communication paper explores the impact on these essential components of web accessibility as the Web rapidly evolves into an increasingly mobile and ubiquitous medium, and highlights opportunities for research and development to help make the Web universally accessible to all users.",
        "keywords": "design for all; mobile accessibility; people with disabilities; standards and guidelines; ubiquitous and cloud computing; universal design; web accessibility",
        "released": 2013,
        "link": "https://doi.org/10.1145/2461121.2461138"
    },
    {
        "title": "A programming language for web service development",
        "abstract": "There is now widespread acceptance of Web services and service-oriented architectures. But despite the agreement on key Web services standards there remain many challenges. Programming environments based on WSDL support go some way to facilitating Web service development. However Web services fundamentally rely on XML and Schema, not on contemporary programming language type systems such as those of Java or .NET. Moreover, Web services are based on a messaging paradigm and hence bring forward the traditional problems of messaging systems including concurrency control and message correlation. It is easy to write simple synchronous Web services using traditional programming languages; however more realistic scenarios are surprisingly difficult to implement. To alleviate these issues we propose a programming language which directly supports Web service development. The language leverages XQuery for native XML processing, supports implicit message correlation and has high level join calculus-style concurrency control. We illustrate the features of the language through a motivating example.",
        "keywords": "",
        "released": 2005,
        "link": "https://dl.acm.org/doi/10.5555/1082161.1082177"
    },
    {
        "title": "Priority-aware resource allocation algorithm for cloud computing",
        "abstract": "Cloud is an innovative model of the computing paradigm, where servers, networks, storage, development tools, and applications are enabled to the users through the Internet in the form of services. These services are provided by the cloud service providers (CSPs) by deploying virtual machines (VMs) as per the resource request received from the users. These VM requests are of various types and priorities, and therefore have varying impacts in terms of importance, criticality, accountability, and domains of applications. On the other hand, the resources/hosts are of varying sizes and assigned to the requests based on their capability, availability, and feasibility. Therefore, it is an exigent issue to map the VM requests with the hosts to maximize the allocation rate with respect to their priority. One of the recent solutions is to assign the high-priority VM requests in close proximity, and other requests can be assigned using first fit decreasing (FFD). However, this solution does not partition the hosts to discriminate the type of requests. This paper introduces a priority-aware resource allocation (PARA) algorithm to consider three types of VM requests: highly critical, critical, and normal, and partition the hosts into three levels. PARA enables the high-priority VM requests to a relatively large pool of hosts compared to low-priority requests. The proposed algorithm is simulated by considering 10000 to 100000 VM requests and 20 to 30 hosts and compared with a non-partitioned pool of hosts with FFD to show effectiveness in allocation rate and weighted score concerning the serving requests.",
        "keywords": "Cloud Computing; Cloud Service Provider; First Fit Decreasing; Resource Allocation; Resource Partitioning; Virtual Machine",
        "released": 2022,
        "link": "https://doi.org/10.1145/3549206.3549236"
    },
    {
        "title": "Programming support environments",
        "abstract": "Programming support environments are software tools that improve programmer productivity and enhance the usability of programming languages. All modern programming languages provide some programming support features, such as debugging tools. The Ada (q.v.) language project, in particular, has emphasized its programming support environment (APSE) from the start. Advanced environments can support programmers in designing, coding, debugging, testing, maintaining, browsing, documenting, project tracking, reverse engineering, and customizing software. In addition, online help and embedded instructions assist programmers learning to use programming environments. Some environments support groups of programmers who work collaboratively on large software development projects. CASE (computer-aided software engineering) tools automate aspects of the software development process and encourage the use of particular programming methodologies.",
        "keywords": "",
        "released": 2003,
        "link": "https://dl.acm.org/doi/10.5555/1074100.1074737"
    },
    {
        "title": "CRSG: A serious game for teaching code review",
        "abstract": "The application of code review in a development environment is essential, but this skill is not taught very often in an educational context despite its wide usage. To streamline the teaching process of code review, we propose a browser based \"Code Review Serious Game\" (CRSG) with high accessibility, progressive level difficulty and an evolvable foundation for prospective improvements or changes. The application is built as a serious game to reinforce the learning experience of its users by immersing them in its story and theme, helping them learn while having fun. The effectiveness of the game components are measured with a case study of 132 students of 2 software engineering courses. The promising result of this case study suggests CRSG can indeed be used effectively to teach code review. The demo video for the game can be accessed at https://youtu.be/FLnr3p4bhOg, and CRSG itself at: https://github.com/barisardic/crsg.",
        "keywords": "code review; serious games; software engineering education; teaching code review",
        "released": 2020,
        "link": "https://doi.org/10.1145/3368089.3417932"
    },
    {
        "title": "View-centric performance optimization for database-backed web applications",
        "abstract": "Web developers face the stringent task of designing informative web pages while keeping the page-load time low. This task has become increasingly challenging as most web contents are now generated by processing ever-growing amount of user data stored in back-end databases. It is difficult for developers to understand the cost of generating every web-page element, not to mention explore and pick the web design with the best trade-off between performance and functionality. In this paper, we present Panorama, a view-centric and database-aware development environment for web developers. Using database-aware program analysis and novel IDE design, Panorama provides developers with intuitive information about the cost and the performance-enhancing opportunities behind every HTML element, as well as suggesting various global code refactorings that enable developers to easily explore a wide spectrum of performance and functionality trade-offs.",
        "keywords": "",
        "released": 2019,
        "link": "https://doi.org/10.1109/ICSE.2019.00104"
    },
    {
        "title": "Online help system design based on the situated action theory",
        "abstract": "Nowadays, different forms of assistance are available in interactive computer-based systems. However, current online help systems, which correspond to the main components of online assistance, often are unsuccessful in providing support to users. The help that is offered is not well-suited to the problem the users encounter and to the particular needs they have. This paper reports on a new approach to online help system design based on the situated action theory. The approach has been implemented in a system called AIDE. The system has been evaluated with 15 subjects having to do programming tasks in C++, and compared to the online help available in the programming environment they were using and on the Web. The main results show that the assistance provided by AIDE was three times as effective as the two other forms of assistance to help in defining the problem, and twice as effective to help in resolving it. Results also show that with the AIDE system, students had much less recourse to human assistance when trying to complete their tasks.",
        "keywords": "contextual help; mixed-initiative interactions; online help; situated action",
        "released": 2005,
        "link": "https://doi.org/10.1145/1111360.1111367"
    },
    {
        "title": "Web-based platform for subtitles customization and synchronization in multi-screen scenarios",
        "abstract": "This paper presents a web-based platform that enables the customization and synchronization of subtitles on both single- and multi-screen scenarios. The platform enables the dynamic customization of the subtitles’ format (font family, size, color...) and position according to the users’ preferences and/or needs. Likewise, it allows configuring the number of subtitles lines to be presented, being able to restore the video playout position by clicking on a specific one. It also allows the simultaneous selection of various subtitle languages, and applying a delay offset to the presentation of subtitles. All these functionalities can also be available on (personal) companion devices, allowing the presentation of subtitles in a synchronized manner with the ones on the main screen and their individual customization. With all these functionalities, the platform enables personalized and immersive media consumption experiences, contributing to a better language learning, social integration and an improved Quality of Experience (QoE) in both domestic and multi-culture environments.",
        "keywords": "accessibility; ides; multi-screen scenarios; qoe; social integration; subtitles; synchronization; web",
        "released": 2017,
        "link": "https://doi.org/10.1145/3084289.3089913"
    },
    {
        "title": "Flex-ER: A platform to evaluate interaction techniques for immersive visualizations",
        "abstract": "Extended Reality (XR) systems (which encapsulate AR, VR and MR) is an emerging field which enables the development of novel visualization and interaction techniques. To develop and to assess such techniques, researchers and designers have to face choices in terms of which development tools to adopt, and with very little information about how such tools support some of the very basic tasks for information visualization, such as selecting data items, linking and navigating. As a solution, we propose Flex-ER, a flexible web-based environment that enables users to prototype, debug and share experimental conditions and results. Flex-ER enables users to quickly switch between hardware platforms and input modalities by using a JSON specification that supports both defining interaction techniques and tasks at a low cost. We demonstrate the flexibility of the environment through three task design examples: brushing, linking and navigating. A qualitative user study suggest that Flex-ER can be helpful to prototype and explore different interaction techniques for immersive analytics.",
        "keywords": "extended reality; immersive analytics; user studies",
        "released": 2020,
        "link": "https://doi.org/10.1145/3427323"
    },
    {
        "title": "Ruggedizing CS1 robotics: Tools and approaches for online teaching",
        "abstract": "First-year students benefit from robotics-based programming exercises by learning how to use sensors to gain information on the (changing) world surrounding the robot, how to model this information using data structures, and how to design algorithms for performing meaningful activities. Robotics-based exercises are naturally experiential and team-based and provide among the most memorable teachable moments of first-year programming courses. We summarize the pedagogical challenges that robotics-based exercises face, even under ideal circumstances, and how a university responded to these challenges. We report on the additional challenges faced in late 2020 at the same university as a result of the COVID pandemic, and how the course staff addressed these challenges using programming language implementation and network tools. The crucial components were (1) a custom-built web-based development environment with collaborative features including a built-in compiler, (2) a portable virtual machine, (3) collaborative editing, (4) open source protocols, and (5) peer-to-peer teleconferencing software. We report on the lessons learnt and how to further improve the resilience of robotics-based programming exercises.",
        "keywords": "educational robotics; learning tools; online robotics; teaching CS1 using robotics",
        "released": 2021,
        "link": "https://doi.org/10.1145/3484272.3484969"
    },
    {
        "title": "On-line programming examinations using web to teach",
        "abstract": "Using the automated code-checking capability of the WebToTeach system, we have built WebToTest, a system for administering on-line programming examination.The system successfully addresses many of the issues raised by recent work in on-line exams by providing reliable automatic checking of exam questions and a secure, restricted programming environment useable by the students during the exam. Its web-based character makes it amenable to distance education applications. Furthermore, because examinations may be administered on any collection of computers that provide a browser, and thus do not require reservation of the student programming labs.",
        "keywords": "distance learning; instructional technology; on-line testing",
        "released": 1999,
        "link": "https://doi.org/10.1145/305786.305835"
    },
    {
        "title": "Using camtasia to develop and enhance online learning: Tutorial presentation",
        "abstract": "Camtasia Studio is an inexpensive screen recording software that allows the user to create multi-platform video and audio recordings of anything that can be displayed or demonstrated on a computer screen, including computer labs assignments, the use of integrated development environments, PowerPoint lectures, demonstrations of Java applets, and software tutorials. Picture-in-picture video is also possible with the addition of an inexpensive web camera. With this screen recording software, a multitude of possibilities exist for developing learning objects and enhancing existing ones, which can then be easily integrated into both in class and online instruction.Camtasia Studio is a screen recording package that captures both the video and audio components of any activity that can be demonstrated or presented on a computer screen including PowerPoint lectures, demonstrations of Java applets, software tutorials, computer labs assignments, demonstrations of integrated development environments, and much more. This format appeals to both auditory and visual learners. These videos can be converted to Flash, Media Player, Real Player, QuickTime, streaming Flash videos, and even pod casts, which then can be made available for easy viewing on the Internet.Viewing by the students, as well as creating the videos, is simple. All that is needed to view these videos is the current plug-in for the video format used and an updated browser. The Camtasia Studio software package and a microphone is all that is needed to create the videos. With the addition of a web camera, picture-in-picture is possible. Recording PowerPoint lectures in video format, brings distance learners into the classroom lectures and preserves the classroom discussions for those who are absent or merely need to see or hear the content one or more time. Camtasia Studio not only records the text and images that are shown on the screen, but it also captures all animations, transitions, and any markings that the presenter may add during the lecture.Camtasia is also perfect for creating tutorials for software packages and learning management systems. When demonstrated in the classroom, the demonstrated actions are often too quick or too difficult to see. But with Camtasia, the viewer has everything directly in front of him or her, available for easy viewing and re-viewing. Likewise, many learning objects utilize written explanations and instructions in conjunction with java applets. For those who understand the concepts behind the object, it is rather easy to understand how to use the learning objects and see their educational value, but for the average student who is being directed to these learning objects through oftentimes brief demonstrations, the purpose and means of use is not so clear. Through video screen recorders such as Camtasia, instructors can record a demonstration of a learning object that walks the student through the use of the object, helps the student discover its purpose and then encourages the student to utilize it.",
        "keywords": "",
        "released": 2007,
        "link": "https://dl.acm.org/doi/10.5555/1229688.1229710"
    },
    {
        "title": "Automated feedback for \"fill in the gap\" programming exercises",
        "abstract": "Timely feedback is a vital component in the learning process. It is especially important for beginner students in Information Technology since many have not yet formed an effective internal model of a computer that they can use to construct viable knowledge. Research has shown that learning efficiency is increased if immediate feedback is provided for students. Automatic analysis of student programs has the potential to provide immediate feedback for students and to assist teaching staff in the marking process. This paper describes a \"fill in the gap\" programming analysis framework which tests students’ solutions and gives feedback on their correctness, detects logic errors and provides hints on how to fix these errors. Currently, the framework is being used with the Environment for Learning to Programming (ELP) system at Queensland University of Technology (QUT); however, the framework can be integrated into any existing online learning environment or programming Integrated Development Environment (IDE).",
        "keywords": "C#; XML; automated testing; black box; dynamic analysis; fill in the gap; instant feedback; java; white box",
        "released": 2005,
        "link": "https://dl.acm.org/doi/10.5555/1082424.1082439"
    },
    {
        "title": "Improving regression testing in continuous integration development environments (keynote)",
        "abstract": "In continuous integration development environments, software engineers frequently integrate new or changed code with the mainline codebase. Merged code is then regression tested to help ensure that the codebase remains stable and that continuing engineering efforts can be performed more reliably. Continuous integration is advantageous because it can reduce the amount of code rework that is needed in later phases of development, and speed up overall development time. From a testing standpoint, however, continuous integration raises several challenges. Chief among these challenges are the costs, in terms and time and resources, associated with handling a constant flow of requests to execute tests. To help with this, organizations often utilize farms of servers to run tests in parallel, or execute tests \"in the cloud\", but even then, test suites tend to expand to utilize all available resources, and then continue to expand beyond that. We have been investigating strategies for applying regression testing in continuous integration development environments more cost-effectively. Our strategies are based on two well-researched techniques for improving the cost-effectiveness of regression testing – regression test selection (RTS) and test case prioritization (TCP). In the continuous integration context, however, traditional RTS and TCP techniques are difficult to apply, because these techniques rely on instrumentation and analyses that cannot easily be applied to fast-arriving streams of test suites. We have thus created new forms of RTS and TCP techniques that utilize relatively lightweight analyses, that can cope with the volume of test requests. To evaluate our techniques, we have conducted an empirical study on several large data sets. In this talk, I describe our techniques and the empirical results we have obtained in studying them.",
        "keywords": "Continuous integration; large scale testing; regression testing",
        "released": 2018,
        "link": "https://doi.org/10.1145/3278186.3281454"
    },
    {
        "title": "How a remote video game coding camp improved autistic college students’ self-efficacy in communication",
        "abstract": "Communication and teamwork are essential skills for software developers. However, these skills are often difficult to learn for students with autism spectrum disorder (ASD). We designed, developed, and ran a 13-day, remote video game coding camp for incoming college first-year students with ASD. We developed instructional materials to teach computer programming, video game design, and communication and teaming skills. Students used the MakeCode Arcade development environment to build their games and Zoom to remotely collaborate with their teammates. In summative interviews, students reported improved programming skills, increased confidence in communication, and better experiences working with others. We also found that students valued the opportunity to practice teaming, such as being more vocal in expressing ideas to their peers and working out differences of opinion with their teammates. Two students reported the remote learning environment decreased their anxiety and stress, both are frequent challenges for autistic people. We plan to rerun the camp next year with materials that we have made available online.",
        "keywords": "autism; coding camp; video games",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3432516"
    },
    {
        "title": "A page-transition framework for image-oriented web programming",
        "abstract": "To develop Web applications, various integrated development environments have been used. In addition, several frameworks for efficiently developing those applications have been proposed. This paper presents the image-oriented page-transition framework that models a Web application as a set of transitions of Web pages, and using visual components, makes it easier to write processes executed when a Web page transfers to another Web page. This page-transition framework has the following novel features: (1) The developers of Web applications do not need to write any processes for receiving and analyzing submitted form data. (2) The data submitted by page transfers are stored in the appropriate variables that are automatically generated. Using these automatically generated variables, the developers can write necessary actions for each Web page from which control transfers. (3) The developers can deal with tables used inside the programs as visual components, and can use these components to design dynamic Web pages.",
        "keywords": "Web application; automatic code generation; image-oriented design; page-transition framework",
        "released": 2004,
        "link": "https://doi.org/10.1145/979743.979764"
    },
    {
        "title": "Building and programming ubiquitous social devices",
        "abstract": "Today’s mobile and embedded devices are Internet-connected, and have decent computing power, which creates a possibility for complex, cooperative multi-device platforms. Yet, from user’s perspective, it seems that we are not freed to use different technologies seamlessly and without thinking. From developer’s perspective, on the other hand, building seamlessly communicating devices requires implementing coordination process separately in an application specific fashion, and yet the devices can only communicate through these specific apps that are not aware of each other. In this paper we introduce Orchestrator.js middleware, which is a tool for readily building multi-user, and multi-device applications in heterogeneous environment. This new lightweight and agile middleware is designed to support Social Devices concept, which aims to bring people together, and increase social interactions when people are co-located. With a concrete example, we also describe the process of building and implementing Social Devices applications with embedded and mobile devices.",
        "keywords": "mobile cloud; proximity-based cooperation; social devices; ubiquitous development tools; ubiquitous multimedia",
        "released": 2014,
        "link": "https://doi.org/10.1145/2642668.2642678"
    },
    {
        "title": "The impact of social media on software engineering practices and tools",
        "abstract": "Today’s generation of software developers frequently make use of social media, either as an adjunct or integrated into a wide range of tools ranging from code editors and issue trackers, to IDEs and web-based portals. The role of social media usage in software engineering is not well understood, and yet the use of these mechanisms influences software development practices. In this position paper, we advocate for research that strives to understand the benefits, risks and limitations of using social media in software development at the team, project and community levels. Guided by the implications of current tools and social media features, we propose a set of pertinent research questions around community involvement, project coordination and management, as well as individual software development activities. Answers to these questions will guide future software engineering tool innovations and software development team practices.",
        "keywords": "social media; software engineering tools; web 2.0",
        "released": 2010,
        "link": "https://doi.org/10.1145/1882362.1882435"
    },
    {
        "title": "A dynamic hierarchical approach to modelling and orchestrating the web of things using the DOM, CSS and JavaScript",
        "abstract": "There is a lot of work in progress by the W3C and others surrounding a Web standards compliant Web of Things (WoT) which it is hoped will unify the current Internet of Things infrastructure. Our contribution to this uses the Document Object Model (DOM) to represent complex physical environments, with a CSS-like syntax for storing and controlling the state of ’things’ within it. We describe how JavaScript can be used in conjunction with these to create an approach which is familiar to Web developers and may help them to transition more smoothly into WoT development. We share our implementation and explore some of the many potential avenues for future research. These include rich WoT development tools and the possibility of content production for physical environments.",
        "keywords": "IoT; WoT; document object model; internet of things; linked data; web development; web of things",
        "released": 2019,
        "link": "https://doi.org/10.1145/3290607.3312990"
    },
    {
        "title": "A net-centric curricular focus",
        "abstract": "Many view JavaScript as merely a scripting language to support Web pages. However, when JavaScript is used more like a traditional language (Web page gimmicks aside), the Web can be used as a viable programming platform upon which to teach programming fundamentals. We describe a Net-Centric curricular revision at Lake Forest College that uses the Web as the programming environment in CS1. We discuss the relationship of the new CS1 to the existing CS0 JavaScript course, and the ramifications that using the Web as the programming platform in CS1 has on other aspects of the curriculum. In particular, our early focus on Web programming facilitates expanded coverage in upper-level courses where the Internet is a factor.",
        "keywords": "",
        "released": 2002,
        "link": "https://dl.acm.org/doi/10.5555/775742.775759"
    },
    {
        "title": "OpenUIDL, a user interface description language for runtime omni-channel user interfaces",
        "abstract": "We extend the concept of cross-device user interfaces into the new, more general, concept of omni-channel user interfaces to better reflect the technological variety offered for developing multi-target user interfaces for interactive applications. We present a model-based approach for developing runtime omni-channel user interfaces for multi-target applications, which consists of: (1) OpenUIDL, a user interface description language for describing omni-channel user interfaces with its semantics by a meta-model and its syntax based on JSON, (2) the definition of a step-wise approach for producing runtime interactive applications based onOpenUIDLwith integration into the development life cycle, (3) the development of a cloud-based, OpenUIDL compliant, Interactive Development Environment that supports the application and the enactment of the step-wise approach and its illustration on several multi-target user interfaces.",
        "keywords": "model-based user interface; multi-target user interfaces; omni-channel user interfaces; open source; user interface description language",
        "released": 2020,
        "link": "https://doi.org/10.1145/3397874"
    },
    {
        "title": "dCloud: A document link provision cloud for software extension tasks",
        "abstract": "Software reuse is commonly achieved through extension mechanisms. Those mechanisms are practiced in software extension tasks. In these tasks, application developers retrieve code examples (step 1), acquire API documents (step 2), and adapt code examples (step 3). At step 2, they spend much time in manually searching API documents, confirming the valid API document version, and re-doing the searching work. At step 3, they spend much effort in frequently switching between web browsers and the local development environment, and rebuilding the development environment on different devices. To reduce the time and effort, a document link provision cloud, named dCloud, is provided in this work. dCloud reduces the time by only providing the document links and the link history. Such links are used to directly access the API documents of their valid version. dCloud reduces the effort by providing an online development environment which is accessed through web browsers. Furthermore, dCloud brings further advantages to application developers and makes a revolutionary impact on the development environment design.",
        "keywords": "API document; cloud; document link; software extension task; software reuse",
        "released": 2013,
        "link": "https://doi.org/10.1145/2494444.2494475"
    },
    {
        "title": "Architecting serverless microservices on the cloud with AWS",
        "abstract": "A microservice architecture decomposes the entire functionally of an application into a set of services that can be deployed and scaled independently. Each service does only one job and does it well. Thus, it’s simpler to develop, test and maintain. Additionally, it has its own database and provides access to datasets and services through a well-defined application programming interface (API). Highly successful Internet companies, such as Amazon, Netflix, and Twitter, use microservice architectures to build their software. This workshop is aimed at CS instructors that wish to teach students how to design and build microservice-based applications using cloud services and products provided by the Amazon Web Services (AWS) free tier. We’ll start creating a cloud development environment with the AWS Cloud9 IDE. Afterwards, we’ll code in Python several RESTful web services using AWS Lambda functions, which are serverless cloud computing services that are executed in response to events. The advantage of going serverless is that you build and run applications and services without thinking about servers. Your application still runs on servers, but all the server management is done by AWS. Finally, we’ll demonstrate how to persist our information in a NoSQL database using the Amazon DynamoDB service. More information available at: http://microservices.arielortiz.info/ Laptop required.",
        "keywords": "cloud computing; microservices; restful api; serverless computing",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287533"
    },
    {
        "title": "Creating audio games online with a browser-based editor",
        "abstract": "Play has been identified as a fundamental human desire (see, e.g., Huizinga’s seminal work on \"Homo Ludens\"). To little surprise then, people have also used sound in play and to create games. Since the advent of the personal computer, the genre of audio games invites sighted and visually impaired people alike to play interactive computer games solely based on sound renderings. While audio games are popular, especially among blind people, there is a lack of development tools to support audio game design and to foster further growth of this genre. For this reason, we demonstrate a browser-based audio game editor that we have developed over the last year or so, drawing on the experience and needs of seven long-term audio gamers. To the best of our knowledge, it is the first application or tool of its kind. Its key features are easy usage (including instant game play and sound rendering) and open source development to increase sustainability and possible impact.",
        "keywords": "Audio Game Editor; Audio Game Engine; Audio Games; Sound Library; Web-based",
        "released": 2019,
        "link": "https://doi.org/10.1145/3356590.3356636"
    },
    {
        "title": "Low latency mobile augmented reality with flexible tracking",
        "abstract": "Jaguar is a mobile Augmented Reality (AR) framework that leverages GPU acceleration on edge cloud to push the limit of end-to-end latency for AR systems and enable accurate and large-scale object recognition based on image retrieval. It integrates the emerging AR development tools (e.g., ARCore and ARKit) into its client design for achieving flexible, robust and context-aware object tracking. Our prototype implementation of Jaguar reduces the end-to-end AR latency to  33 ms and achieves accurate six degrees of freedom (6DoF) tracking. In this demo, we will show that our Jaguar client recognizes movie posters within the camera view by offloading computation intensive tasks to edge cloud and augments these posters with their movie trailers in 3D upon receiving the recognition results.",
        "keywords": "GPU acceleration; augmented reality; mobile edge computing; object recognition; object tracking",
        "released": 2018,
        "link": "https://doi.org/10.1145/3241539.3267719"
    },
    {
        "title": "Teamscope: Scalable team evaluation via automated metric mining for communication, organization, execution, and evolution",
        "abstract": "Teaching software development teams can be difficult to scale. Based on various cloud-based software development tools, Teamscope provides automated or semi-automated metrics to improve the scalability of a course with team projects. Metrics developed in Teamscope provide a synthesized view of a student team. Our preliminary results have shown the validity of these metrics. We also present a case study of applying metrics to teaching software development course in this paper.",
        "keywords": "education; massive courses; process conformance; software engineering",
        "released": 2017,
        "link": "https://doi.org/10.1145/3051457.3053997"
    },
    {
        "title": "CS50 sandbox: Secure execution of untrusted code",
        "abstract": "We introduce CS50 Sandbox, an environment for secure execution of untrusted code. Implemented as an asynchronous HTTP server, CS50 Sandbox offers clients the ability to execute programs (both interactive and non-interactive) written in any compiled or interpreted language in a tightly controlled, resource-constrained environment. CS50 Sandbox’s HTTP-based API takes files, command lines, and standard input as inputs and returns standard output and error plus exit codes as outputs. Atop CS50 Sandbox, we have built CS50 Run, a web-based code editor that enables students to write code in a browser in any language, whether compiled or interpreted, that’s executed server-side within a sandboxed environment. And we have built CS50 Check, an autograding framework that supports black- and white-box testing of students’ code, leveraging CS50 Sandbox to run series of checks against students’ programs, no matter the language of implementation.We present in this work the pedagogical motivations for each of these tools, along with the underlying designs thereof. Each is available as open source.",
        "keywords": "sandbox",
        "released": 2013,
        "link": "https://doi.org/10.1145/2445196.2445242"
    },
    {
        "title": "How can we improve student workflow practices to better enable student success in CS1?",
        "abstract": "Recent research suggests that one-third of the students enrolled in CS1 courses typically end up failing [4]. Several studies have demonstrated how learning tools can assist struggling students [3]. We present an online, open-source, practice programming tool. BitFit was developed to (1) provide students with an environment to practice weekly material and receive support when needed; and (2) collect student usage data as students progress through programming exercises [2]. We present the core features of BitFit, as well as our qualitative and quantitative analysis of 652 students over three semesters of our CS1 course.Our findings support recent studies that suggest that at-risk students can be identified as early as two weeks into the semester [1]; the metric used in our study was able to identify over 29",
        "keywords": "cs1; educational data mining; predictors of success; programming practice tool; student study behavior",
        "released": 2016,
        "link": "https://doi.org/10.1145/2899415.2925495"
    },
    {
        "title": "A practical way to teach web programming in computer science",
        "abstract": "Nowadays, web-based applications have become more and more popular in computer-based applications. Learning and mastering web programming environment, techniques, and methods are becoming necessary for undergraduate students in computer science. Traditional curriculum in computer science usually does not include web programming course. It is a great challenge to design and implement an effective course to teach web programming so that a computer science student can learn and master necessary knowledge and skills for efficiently developing interactive web-based database-driven applications. Recently, I designed and taught a web programming course for junior and senior undergraduate students in computer science. The course mainly focused on teaching the server-side programming techniques with open source software PHP and MySQL. Considering that many students had not systematically learned the basic client-side web development techniques and software tools, the course allotted 1/3 time to review and teach XHTML, CSS, HTTP, JavaScript, and Macromedia Dreamweaver and Fireworks. This paper discusses the details of the design and implementation for the web programming course including course contents, structure, implementation, demonstration, assignments, final project, outcomes and feedback. The paper can provide some useful information and directions for other instructors teaching the same course in computer science.",
        "keywords": "",
        "released": 2006,
        "link": "https://dl.acm.org/doi/10.5555/1181811.1181841"
    },
    {
        "title": "Low-code and no-code technologies adoption: A gray literature review",
        "abstract": "Context: In the last years, the software demand has been growing fast. With the Covid-19 pandemic, companies were forced to adapt to remote work, accelerating the digitalization process. According to Gartner, the demand for software will increase five times faster than the capacity to supply them by the industry, as result of the shortage of developers. Seeking to reduce this problem, tools that abstract the programming complexity have emerged. These tools promote software development via graphical user interfaces and allow people without programming knowledge, or with little knowledge, to develop their own applications. Such tools are known as low-code and no-code tools. Problem: Although low-code and no-code tools have been gaining popularity, their benefits and limitations have not been adequately evaluated, including their impacts in terms of evolution, maintenance, and quality of the generated code. The absence of scientific works that investigate and evaluate the development and use of low-code and no-code tools is a gap that should be explored to improve such techniques. Solution: This paper presents a review of the gray literature of low-code and no-code development tools, investigating publications that discuss the topic aiming to better comprehend the challenges related to the use and development of these tools. IS Theory: The work was developed based on the Expectation Confirmation Theory. Especially, in the evaluation of expectations based on perceived performance, given the great expectation of significant productivity gains with the adoption of low-code and no-code technologies. Method: We conducted a systematic review of the gray literature through the selection and analysis of online posts on the subject, given the lack of scientific works on this topic. Results: The results demonstrate the existence of several low-code and no-code tools, covering different markets and purposes, such as web, mobile, and desktop development. The ease of use, resource savings, and fast prototyping were identified as the main benefits of these tools. On the other hand, platform dependency, limited functionality, and data security were mentioned as the main challenges. Contributions: The main contribution of this work is, through a gray literature review, to present a study of the state of the art of development and use of no-code and low-code tools, particularly their benefits and limitations.",
        "keywords": "",
        "released": 2023,
        "link": "https://doi.org/10.1145/3592813.3592929"
    },
    {
        "title": "Programming web services on the cloud with node.js: (Abstract only)",
        "abstract": "Node.js is one of the hottest open source web platforms currently available. It’s used by companies like PayPal, DowJones, Walmart, Netflix, and Yahoo. Node.js allows you to use JavaScript to write all kinds of network servers in just a few lines of code, definitely easier than using other platforms based on languages such as C++, C# or Java. If you know how to use JavaScript on the front end (i.e., the browser), it’s a breeze to use it on the back end (i.e., the server). This workshop is aimed at CS instructors that wish to teach students how to use and write RESTful web services (a.k.a. web APIs) using Node.js on a cloud platform. The only thing you need is a computer with a modern web browser and a Wi-Fi connection. Participants will use the free service provided by the Cloud9 platform (https://c9.io/) to learn how to write scalable web services using Node.js, the Express web framework, MySQL, and Ajax via jQuery. Web services allows us to build powerful web based applications using data from multiple online sources. And, by using a cloud platform, we have all our tools readily available through a web browser, thus eliminating the hassle related to installing a complete and fully functional web development environment. Participants are expected to have a working knowledge of JavaScript, SQL and HTML. Additional information available at http://node.arielortiz.info/ Laptop required.",
        "keywords": "javascript; node.js; web development; web services",
        "released": 2018,
        "link": "https://doi.org/10.1145/3159450.3162367"
    },
    {
        "title": "Docker vs vagrant: How i use docker and vagrant teach my oracle database administration class",
        "abstract": "Docker is a set of platform as a service (PaaS) products that uses OS-level virtualization to deliver software in packages called containers [1]. Vagrant is an open-source software product for building and maintaining portable virtual software development environments. It tries to simplify the software configuration management of virtualizations in order to increase development productivity. Vagrant is written in the Ruby language, but its ecosystem supports development in a few languages [2]. In the past Spring, NKU has to close down because of COVID-19. In order to convert the database class, I have to move our VMWare base Lab into virtual environment that it can be ran on students’ own pc or labtop. Docker and Vagrant based solution were considered. The workshop presenter has used Docker and Vagrant for courses in Linux server administration, Database administration, Network design, Web server administration and Web application development. The workshop will have a quick introduction to Docker and Vagrant. Participants will learn how to install and Oracle database with both Docker and Vagrant technologies. The benefits of using Docker vs Vagrant on my Oracle administration class will be discussed. The presenter and his assistance(s) will be available to help the participants with the installation of the needed software for the tutorial prior to the start of the tutorial.",
        "keywords": "",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3447286.3447299"
    },
    {
        "title": "Confluence: Visualizing social physics for interactive narrative",
        "abstract": "We introduce Confluence, a web-based social physics game framework and development tools. It seeks to combine the powers of graphical game engines with physics and animation, and social simulation of social physics engines, with convenient tools like social network visualization, strategy analysis and in-game social rule authoring. We evaluate it in developing a game with character personalities and goals that are influenced by social norms.",
        "keywords": "character personality; emergent narrative; interactive narrative; social physics; visualization",
        "released": 2016,
        "link": "https://doi.org/10.1145/2994258.2994285"
    },
    {
        "title": "A visual programming environment for device independent generation of user interfaces",
        "abstract": "The promise of information anytime, anywhere has become a reality. Today, it is possible to access information through multiple kinds of devices. However, the design of user interfaces for such devices is restricted to the use of specific adhoc programming languages that may vary from one device to the other. In this sense, the existence of generic programming languages for creating device-independent user interfaces is becoming a strong necessity. One emerging approach to device independent developments require the construction of generic vocabularies for transcoding into specific target codes for web browsers, PDAs, voice systems, mobile phones, etc. In this work, we present an authoring tool for designing generic user interfaces with automatic transcoding to multiple target languages. The tool is a visual programming environment with drag and drop generic widgets created in UIML and transcoded into VoiceXML, J2ME, HTML and WML languages. This tool takes advantage of the UIML language and visual programming paradigms for providing flexibility, consistency and decrease in development time.",
        "keywords": "J2ME; UIML; VXML; WML; XSLT; generic vocabulary; visual programming",
        "released": 2003,
        "link": "https://doi.org/10.1145/944519.944526"
    },
    {
        "title": "Hands-on: Easy microservices application development with microclimate",
        "abstract": "Microclimate is a brand-new, cloud native development environment that offers a complete, end-to-end development experience for Microservices. Since Microclimate has been designed with a focus on containerization, it can run anywhere from your local laptop, to an IBM Cloud private cluster. With Microclimate, you can create or import Java, Node.js, or Swift applications into the development environment, and using any editor of your choosing, you can quickly start development on your application in a containerized environment. Through a process called Rapid Iteration, Microclimate will quickly detect any changes that occur in your project and determine the minimal and best course of action to update your application. From there, using our integrated DevOps pipeline, you can deploy your application with Jenkins to a live ICP cluster. With these features, Microclimate offers a fully featured development experience that many other environments don’t offer today. During the hands-on workshop, we will give you an introduction to Microclimate, starting from product installation to write Microservices applications to run on Microclimate in a Docker environment. You will get hands on experiences to create new applications and import existing applications into Microclimate. For developers, a crucial part of the development cycle is the ability to quickly develop and test applications changes on a running application. The develop-deploy-test-repeat cycle must be as short as possible in order to prevent lost developer productivity due to deployment downtime. You will be given the opportunity to experience this rapid iterative development support by developing Java and JavaScript applications in this workshop. Finally, during the workshop we will introduce the integrated DevOps pipeline functions provided that allows you get into production fast with a preconfigured DevOps pipeline and deploy application to IBM Cloud Private (ICP). We will also show you the diagnostic services that helps you to do problem determination in production.",
        "keywords": "",
        "released": 2018,
        "link": "https://dl.acm.org/doi/10.5555/3291291.3291340"
    },
    {
        "title": "Using sybase WorkSpace to build service oriented architecture (SOA) applications quickly",
        "abstract": "In the past years, there is significant growth in the number of new technologies for Java developers. More recently, Web Services and Service Oriented Architectures (SOA) are becoming popular. Projects are now more complex and are becoming more challenging to complete on time. Sybase WorkSpace is a service-oriented unified design and development environment that includes the power of enterprise modeling with comprehensive tooling capabilities. This demonstration shows how enterprise modeling, database development, Web application development, services-oriented development and orchestration, and mobile development all come together to build SOA applications quickly. It demonstrates how Sybase WorkSpace integrates the most important design and development tools in an easy-to-use open-source framework.",
        "keywords": "Sybase WorkSpace; database development; eclipse; enterprise modeling; mobile development; service oriented architectures (SOA); services-oriented development and orchestration; visual drag and drop development; web application development; web services",
        "released": 2007,
        "link": "https://doi.org/10.1145/1297846.1297920"
    },
    {
        "title": "Improving cloud-based continuous integration environments",
        "abstract": "We propose a novel technique for improving the efficiency of cloud-based continuous integration development environments. Our technique identifies repetitive, expensive and time-consuming setup activities that are required to run integration and system tests in the cloud, and consolidates them into preconfigured testing virtual machines such that the overall costs of test execution are minimized. We create such testing machines by reconfiguring and opportunistically snapshotting the virtual machines already registered in the cloud.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2819009.2819172"
    },
    {
        "title": "Building a world-wide virtual machine based on web and HPCC technologies",
        "abstract": "In today’s high performance computing arena, there is a strong trend toward building virtual computers from heterogeneous resources on a network. In this paper we describe our experiences in building a world-wide virtual machine (WWVM) based on emerging Web and existing HPCC technologies. We have constructed a Web-based parallel/distributed programming environment on top of this machine demonstrating MPI and PVM message-passing programs and High Performance Fortran programs. Alternatively, the WWVM can be configured as a metacomputer for the solution of metaproblems.",
        "keywords": "HPCC; HPF; MPI; PVM; Perl; WWW; metacomputing",
        "released": 1996,
        "link": "https://doi.org/10.1145/369028.369115"
    },
    {
        "title": "OpenGL (tutorial presentation)",
        "abstract": "OpenGL is a standard for creating graphics in many different programming environments. This tutorial will show how to use OpenGL using Borland’s C++ Builder. More precisely, the GL Utility Toolkit (GLUT) will be examined. Methods of initializing your program to use GLUT, drawing pictures, creating menus, inputting information, and using the mouse will be developed. The following topics will be covered: Example programs will be given. The code will be handed out and will also be available on the web after the meeting.",
        "keywords": "",
        "released": 2001,
        "link": "https://dl.acm.org/doi/10.5555/374685.374706"
    },
    {
        "title": "Accelerating applications at cloud scale using FPGAs",
        "abstract": "The acceptance and success of cloud computing has given application developers access to computing and new customers at a scale never seen below. The inherent ability of an FPGA to reconfigure and be workload optimized is a great advantage given the fast-moving needs of cloud computing applications. In this talk we will discuss how users can develop, accelerate and deploy accelerated applications in the cloud at scale. You will learn how to get started on a turn-key OpenCL development environment in the cloud using Xilinx FPGAs.",
        "keywords": "FPGA; OpenCL; SDAccel",
        "released": 2017,
        "link": "https://doi.org/10.1145/3078155.3078179"
    },
    {
        "title": "Living semantic platform",
        "abstract": "The Living Semantic Platform (LSP) is a web-based and collaborative development environment for lightweight ontologies based on OWL2 QL. Moreover, it includes an integrated OWL2 QL reasoner which allows for efficient query answering based on SPARQL queries.",
        "keywords": "OWL2 QL; SPARQL; collaborative ontology development; query answering",
        "released": 2015,
        "link": "https://doi.org/10.1145/2814864.2814893"
    },
    {
        "title": "HPDC ’10: Proceedings of the 19th ACM international symposium on high performance distributed computing",
        "abstract": "On behalf of the organizing committee, we welcome you to the 19th ACM International Symposium on High Performance Distributed Computing (HPDC-19) and to Chicago, Illinois, a city rich in culture, history, technology, and third largest city in the United States. The HPDC Symposium is the premier venue for presenting the latest research on the design, implementation, evaluation, and use of parallel and distributed systems for high performance and high end computing. We are looking forward to lively discussions about HPDC emerging technologies, applications and their challenges. In the last two decades, we have experienced rapid advances in networks and computing, Internet technologies and services, parallel and distributed programming tools that have lead to the developed and deployment of many HPDC systems and services include Grid Computing, Cloud Computing, Pervasive Computing, just to name a few. These advances and technologies bring with them many challenges and exciting opportunities that can be addressed by the HPDC research community.This year’s technical program presents high-quality papers in HPDC Workflows, Cloud Computing and Tools, Data Centers and Virtualization, Scheduling, Storage and I/O, Communications, and Applications. We would like to thank Peter Dinda (Program Chair), Northwestern University, for his outstanding and tireless efforts in assembling an excellent program committee, managing the reviews and selection of the papers, and even addressing many other issues related to sponsorship, proceedings, finance, and more to make sure we have an excellent HPDC program for this year. We owe a great debt to Peter, whose dedications and commitments have produced another strong technical program that we all will enjoy and appreciate when we meet in Chicago.Continuing the HPDC tradition, this year’s symposium features eight workshops: Emerging Computation Methods for the Life Sciences, LSAP: Large-Scale System and Application Performance, MDQCS: Managing Data Quality for Collaborative Science, ScienceCloud: Workshop on Scientific Cloud Computing, CLADE: Challenges of Large Applications in Distributed Environments, DIDC: Data Intensive Distributed Computing, MAPREDUCE: MapReduce and its applications, and VTDC: Virtualization Technologies for Distributed Computing. We would like to acknowledge the excellent job done by Douglas Thain (Workshop Chair), University of Notre Dame, in putting together a strong workshop program.",
        "keywords": "",
        "released": 2010,
        "link": "https://dl.acm.org/doi/10.1145/1851476"
    },
    {
        "title": "Scaling up functional programming education: Under the hood of the OCaml MOOC",
        "abstract": "This article describes the key innovations used in the massive open online course “Introduction to Functional Programming using OCaml” that has run since the fall semester of 2015. A fully in-browser development environment with an integrated grader provides an exceptional level of feedback to the learners. A functional library of grading combinators greatly simplifies the notoriously complex task of writing test suites for the exercises, and provides static type-safety guarantees on the tested user code. Even the error-prone manual process of importing the course content in the learning platform has been replaced by a functional program that describes the course and statically checks its contents. A detailed statistical analysis of the data collected during and after the course assesses the effectiveness of these innovations.",
        "keywords": "MOOC; automated grading; browser based education platform; functional programming; programming education; safe program introspection",
        "released": 2017,
        "link": "https://doi.org/10.1145/3110248"
    },
    {
        "title": "Development of semantic web applications: State of art and critical review",
        "abstract": "Ontologies have recently received popularity in the area of knowledge management and knowledge sharing, especially after the evolution of the Semantic Web and its supporting technologies. An ontology defines the terms and concepts (meaning) used to describe and represent an area of knowledge. The aim of this paper is to identify the basics notions of ontologies and ontology management tools specially protégé that are freely available and the process development of semantic web notions.The Semantic Web vision have lead to a number of standards such as OWL and Web Semantic Mining. While these standards provide a technical infrastructure, developers have little guidance on how to build real-world Semantic Web applications. We will start by some definitions of Semantic Web and the common points with Web Mining. We will illustrate how these notions can be put into practice using the modern Semantic Web development tool Protege, and indicate future possibilities;",
        "keywords": "Knowledge discovery; Semantic Web; Web Mining; ontology; ontology learning",
        "released": 2018,
        "link": "https://doi.org/10.1145/3234698.3234753"
    },
    {
        "title": "Engaging in logical code reasoning with an activity-based online tool",
        "abstract": "Using freely available online automated reasoning tools, we will demonstrate a sequence of engaging reasoning activities that are suitable to introduce beginning programmers and software engineering students to reason logically and symbolically about code. The automated tools have an underlying verification engine that makes it possible for the tool to offer activities and directed logical feedback not possible with typical development environments. The tools have been used in undergraduate classrooms for multiple years by well over a thousand students. The imperative language used by the tool is integrated with the underlying verification engine, and because it closely resembles many commercial languages, it presents little barrier to student usage. A comprehensive activity-based \"Reason with Components\" tool takes 5-10 minutes of instructor introduction and allows student exploration of contracts, objects, loops, recursion, and reusable concepts. Multiple versions of \"Begin to Reason\" tools are designed to help students learn the basics of code tracing in intro CS courses \"on their own\". Students and instructors can create new activities and can fine-tune the existing activities to their specific needs.",
        "keywords": "active learning; code tracing; contracts; online tool; symbolic reasoning",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3293754"
    },
    {
        "title": "Teach real-time embedded system online with real hands-on labs",
        "abstract": "In recent years, embedded systems are becoming increasingly important due to their wide applications in every aspect of our society. By the year 2010, it is forecasted that 90",
        "keywords": "MCU; embedded; engineering; portable; real time",
        "released": 2009,
        "link": "https://doi.org/10.1145/1562877.1563009"
    },
    {
        "title": "Teaching accessibility: A design exploration of faculty professional development at scale",
        "abstract": "Most CS students learn little about accessibility in higher education; this is partly because most CS faculty know little about accessibility. Unfortunately, higher education CS faculty lack a model of professional development for learning to teach new topics. Therefore, we investigated the feasibility of a \"micro\" professional development model for teaching accessibility in CS courses that could be used at scale. We conducted 18 semi-structured interviews with U.S. CS faculty, asking them to explore a prototype of a web-based professional development tool that linked accessibility topics to CS topics. We found that many organizational factors limited faculty’s autonomy to integrate accessibility in many of their courses. We also found that individual values and knowledge constrained faculty’s ability and willingness to both learn and integrate accessibility topics into their courses. However, many faculty expressed desire to teach accessibility in their courses if they had access to even basic accessibility content and materials to use in their courses.",
        "keywords": "accessibility; higher education; professional development",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287399"
    },
    {
        "title": "psc2code: Denoising code extraction from programming screencasts",
        "abstract": "Programming screencasts have become a pervasive resource on the Internet, which help developers learn new programming technologies or skills. The source code in programming screencasts is an important and valuable information for developers. But the streaming nature of programming screencasts (i.e., a sequence of screen-captured images) limits the ways that developers can interact with the source code in the screencasts. Many studies use the Optical Character Recognition (OCR) technique to convert screen images (also referred to as video frames) into textual content, which can then be indexed and searched easily. However, noisy screen images significantly affect the quality of source code extracted by OCR, for example, no-code frames (e.g., PowerPoint slides, web pages of API specification), non-code regions (e.g., Package Explorer view, Console view), and noisy code regions with code in completion suggestion popups. Furthermore, due to the code characteristics (e.g., long compound identifiers like ItemListener), even professional OCR tools cannot extract source code without errors from screen images. The noisy OCRed source code will negatively affect the downstream applications, such as the effective search and navigation of the source code content in programming screencasts.In this article, we propose an approach named psc2code to denoise the process of extracting source code from programming screencasts. First, psc2code leverages the Convolutional Neural Network (CNN) based image classification to remove non-code and noisy-code frames. Then, psc2code performs edge detection and clustering-based image segmentation to detect sub-windows in a code frame, and based on the detected sub-windows, it identifies and crops the screen region that is most likely to be a code editor. Finally, psc2code calls the API of a professional OCR tool to extract source code from the cropped code regions and leverages the OCRed cross-frame information in the programming screencast and the statistical language model of a large corpus of source code to correct errors in the OCRed source code.We conduct an experiment on 1,142 programming screencasts from YouTube. We find that our CNN-based image classification technique can effectively remove the non-code and noisy-code frames, which achieves an F1-score of 0.95 on the valid code frames. We also find that psc2code can significantly improve the quality of the OCRed source code by truly correcting about half of incorrectly OCRed words. Based on the source code denoised by psc2code, we implement two applications: (1) a programming screencast search engine; (2) an interaction-enhanced programming screencast watching tool. Based on the source code extracted from the 1,142 collected programming screencasts, our experiments show that our programming screencast search engine achieves the precision@5, 10, and 20 of 0.93, 0.81, and 0.63, respectively. We also conduct a user study of our interaction-enhanced programming screencast watching tool with 10 participants. This user study shows that our interaction-enhanced watching tool can help participants learn the knowledge in the programming video more efficiently and effectively.",
        "keywords": "Programming videos; code search; deep learning",
        "released": 2020,
        "link": "https://doi.org/10.1145/3392093"
    },
    {
        "title": "A brief survey of creating semantic web content with protégé",
        "abstract": "An ontology development tool is often the first thing that people get to see when they venture into the Semantic Web field. Ontology editors and visualization tools therefore carry a special responsibility for the success of the Semantic Web community. At the same time, the user communities around such tools serve as melting pots which can be exploited to collect feedback on the overall design of the language and associated systems.Protégé is one of the most used development platforms for ontology-based systems. This paper report on the experiences of using Protégé with OWL. The intention of the Protégé and specially Protégé Plugin is to make Semantic Web technology available to a broad group of developers and users, and to promote best practices and design patterns. In this document we walk through a selection of these issues and suggest directions for future work and standardization efforts.",
        "keywords": "OWL; Ontology; Protégé; Semantic Web",
        "released": 2018,
        "link": "https://doi.org/10.1145/3234698.3234704"
    },
    {
        "title": "Towards providing on-demand expert support for software developers",
        "abstract": "Software development is an expert task that requires complex reasoning and the ability to recall language or API-specific details. In practice, developers often seek support from IDE tools, Web resources, or other developers to help fill in gaps in their knowledge on-demand. In this paper, we present two studies that seek to inform the design of future systems that use remote experts to support developers on demand. The first explores what types of questions developers would ask a hypothetical assistant capable of answering any question they pose. The second study explores the interactions between developers and remote experts in supporting roles. Our results suggest eight key system features needed for on-demand remote developer assistants to be effective, which has implications for future human-powered development tools.",
        "keywords": "crowdsourcing; intelligent assistants; pair programming",
        "released": 2016,
        "link": "https://doi.org/10.1145/2858036.2858512"
    },
    {
        "title": "Codelets: Linking interactive documentation and example code in the editor",
        "abstract": "Programmers frequently use instructive code examples found on the Web to overcome cognitive barriers while programming. These examples couple the concrete functionality of code with rich contextual information about how the code works. However, using these examples necessitates understanding, configuring, and integrating the code, all of which typically take place after the example enters the user’s code and has been removed from its original instructive context. In short, a user’s interaction with an example continues well after the code is pasted. This paper investigates whether treating examples as \"first-class\" objects in the code editor - rather than simply as strings of text - will allow programmers to use examples more effectively. We explore this through the creation and evaluation of Codelets. A Codelet is presented inline with the user’s code, and consists of a block of example code and an interactive helper widget that assists the user in understanding and integrating the example. The Codelet persists throughout the example’s lifecycle, remaining accessible even after configuration and integration is done. A comparative laboratory study with 20 participants found that programmers were able to complete tasks involving examples an average of 43",
        "keywords": "documentation; example; programming; structured editing",
        "released": 2012,
        "link": "https://doi.org/10.1145/2207676.2208664"
    },
    {
        "title": "Investigating the use of tags in collaborative development environments: A replicated study",
        "abstract": "Modern collaborative development environments have recently introduced tagging as a new feature in order to let developers annotate software artifacts with free keywords. Since tagging has the potential to have an impact on task management in software development processes, there is a need to understand how developers use tagging in projects supported by collaborative development environments and how developers’ behavior differ from collaborative tagging in the Social Web.We have conducted an independent replication of an empirical study, which first investigated how tags are used in a large software project. In our replication, we have analyzed two further projects coordinated through two different collaborative development environments, Jazz and Trac. The findings from our replicated study extend the initial contribution of the original study by (1) showing evidence of differences in tag usage between the two collaborative development environments, and (2) providing a clear understanding that tags used in such environments significantly differs from those used in traditional collaborative tagging systems.",
        "keywords": "collaborative development environments; empirical study; replication; tagging",
        "released": 2010,
        "link": "https://doi.org/10.1145/1852786.1852818"
    },
    {
        "title": "Understanding learning curves and trajectories in CSS layout",
        "abstract": "Web development is a learning context with the potential to support rich computational thinking. Large-scale analysis of compilation and runtime errors have been used in introductory programming courses and similar approaches can be used to understand learning in web development environments. We investigated activity logs of a novel web coding game to uncover learning trajectories and what people struggle with when learning flexible box (flexbox), a collection of new CSS layout features. We designed a game called Flexbox Froggy, in which learners solve challenges by writing a few lines of CSS code, moving from simple levels that require knowledge of one flexbox property, to complex levels combining multiple properties. We investigate learning curves based on the changes in syntactic and semantic errors learners make as they complete the game. Our findings show that people performed better encountering a single new property than combined with properties they had already practiced. Clusters of learners at different levels did not demonstrate expected error rates based on learning curve theory. Also unexpectedly, advanced groups that mastered syntax had higher semantic error rates than the beginner group, especially when attempting new properties or complex use cases. We conclude with implications for designing and developing introductory web programming games and other instructional materials.",
        "keywords": "clustering; css layout; educational game; learning analytics; learning curve analysis; web development",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287387"
    },
    {
        "title": "CodePilot: Scaffolding end-to-end collaborative software development for novice programmers",
        "abstract": "Novice programmers often have trouble installing, configuring, and managing disparate tools (e.g., version control systems, testing infrastructure, bug trackers) that are required to become productive in a modern collaborative software development environment. To lower the barriers to entry into software development, we created a prototype IDE for novices called CodePilot, which is, to our knowledge, the first attempt to integrate coding, testing, bug reporting, and version control management into a real-time collaborative system. CodePilot enables multiple users to connect to a web-based programming session and work together on several major phases of software development. An eight-subject exploratory user study found that first-time users of CodePilot spontaneously used it to assume roles such as developer/tester and developer/assistant when creating a web application together in pairs. Users felt that CodePilot could aid in scaffolding for novices, situational awareness, and lowering barriers to impromptu collaboration.",
        "keywords": "collaborative ide; novice programmers; pair programming",
        "released": 2017,
        "link": "https://doi.org/10.1145/3025453.3025876"
    },
    {
        "title": "Web-based laboratories in the introductory curriculum enhance formal methods",
        "abstract": "In order to be effective, the content of the introductory curriculum must strike a proper balance between the highly motivating (i.e. \"fun\") aspects of programming and the development of sound scientific background and analytical thinking. As part of an NSF-funded Education Infrastructure project at Oberlin College, we have developed a curriculum that maintains a high level of scientific rigor, while making use of the new technology of HTML and the World Wide Web to instruct and motivate. We provide our students with an integrated experience which includes web-based guided-study laboratory materials, an interactive programming environment and a syllabus which emphasizes the interplay between abstract and formal concepts on the one hand, and concrete implementations and experimental investigations on the other. Scheme is used as the primary programming environment, to illustrate the salient features of the imperative and the object-oriented paradigms, along with the functional paradigm with which it is usually associated. We believe that our approach: 1) revitalizes the material for students who expect a more modern presentation; 2) provides a balanced view of competing perspectives on programming style and methodology; and 3) provides a well-balanced mixture of formal analysis and experimental measurement.In order to produce laboratory materials without the overhead entailed by creating them directly in HTML, we have developed a tool capable of abstracting the functionality and style of HTML documents; thus we can engage both faculty and student authors in the development of laboratories with a uniform style. The very tools used to develop the online materials are themselves an excellent illustration of the empowerment which results from a thorough understanding of the principles of abstraction.",
        "keywords": "",
        "released": 1996,
        "link": "https://doi.org/10.1145/236452.236531"
    },
    {
        "title": "AB-EUIDE: An approach to the design of ergonomic user interfaces for cloud computing",
        "abstract": "Cloud computing is a rapidly growing technology for many organizations with dynamic scalability and services as virtual through the internet. The design of ergonomic user interface for cloud computing environment using the Multi-agent system for user well-being is required. In this paper, the usage of multi-agent system in designing of Agent-Based Ergonomic User Interface Development Environment for cloud computing is presented. The work is aimed for social, environment, human, personality and ICT developments.",
        "keywords": "AB EUIDE; Abstract user interface Model (AUI); Cloud Computing; Concrete user interface (CUI) Model; Domain Model (DM); Transformation model",
        "released": 2016,
        "link": "https://doi.org/10.1145/2905055.2905056"
    },
    {
        "title": "FPGA-based acceleration of time series similarity prediction: From cloud to edge",
        "abstract": "With the proliferation of low-cost sensors and the Internet of Things, the rate of producing data far exceeds the compute and storage capabilities of today’s infrastructure. Much of this data takes the form of time series, and in response, there has been increasing interest in the creation of time series archives in the past decade, along with the development and deployment of novel analysis methods to process the data. The general strategy has been to apply a plurality of similarity search mechanisms to various subsets and subsequences of time series data to identify repeated patterns and anomalies; however, the computational demands of these approaches renders them incompatible with today’s power-constrained embedded CPUs.To address this challenge, we present FA-LAMP, an FPGA-accelerated implementation of the Learned Approximate Matrix Profile (LAMP) algorithm, which predicts the correlation between streaming data sampled in real-time and a representative time series dataset used for training. FA-LAMP lends itself as a real-time solution for time series analysis problems such as classification. We present the implementation of FA-LAMP on both edge- and cloud-based prototypes. On the edge devices, FA-LAMP integrates accelerated computation as close as possible to IoT sensors, thereby eliminating the need to transmit and store data in the cloud for posterior analysis. On the cloud-based accelerators, FA-LAMP can execute multiple LAMP models on the same board, allowing simultaneous processing of incoming data from multiple data sources across a network.LAMP employs a Convolutional Neural Network (CNN) for prediction. This work investigates the challenges and limitations of deploying CNNs on FPGAs using the Xilinx Deep Learning Processor Unit (DPU) and the Vitis AI development environment. We expose several technical limitations of the DPU, while providing a mechanism to overcome them by attaching custom IP block accelerators to the architecture. We evaluate FA-LAMP using a low-cost Xilinx Ultra96-V2 FPGA as well as a cloud-based Xilinx Alveo U280 accelerator card and measure their performance against a prototypical LAMP deployment running on a Raspberry Pi 3, an Edge TPU, a GPU, a desktop CPU, and a server-class CPU. In the edge scenario, the Ultra96-V2 FPGA improved performance and energy consumption compared to the Raspberry Pi; in the cloud scenario, the server CPU and GPU outperformed the Alveo U280 accelerator card, while the desktop CPU achieved comparable performance; however, the Alveo card offered an order of magnitude lower energy consumption compared to the other four platforms. Our implementation is publicly available at https://github.com/aminiok1/lamp-alveo.",
        "keywords": "Field-programmable gate array (FPGA); time series; Matrix Profile",
        "released": 2022,
        "link": "https://doi.org/10.1145/3555810"
    },
    {
        "title": "End-user programming and blended-user programming",
        "abstract": "End-User Programming has not lived up to expectations: today’s computer world is dominated by \"fatware\" programs with hundreds of features, not simple applications built by the users themselves. Yet a strange convergence is taking place between the roles of programmers and end-users. Professional programmers are now end users of complex IDEs (Integrated Development Environments) similar to tools for non-programmers. On the other end of the scale, end users of major applications are gradually eased into real programming by extensive customization, macro recorders, \"wizards\", and GUI builders. In between are the informally-trained software professionals we call \"blended-user programmers\" who configure computers and networks, control industrial machines, and build active Web pages and business applications. Like conventional programmers, they are paid to program full-time, and develop skills in a variety of tools. Like end-users, their knowledge is applied and experimental rather than theoretical. Many started as end users, but moved into these software careers instead of becoming \"gurus\" or \"gardeners\" [1] who help other users.",
        "keywords": "blended-user programming; end-user computing; end-user programming; psychology of programming; sociology of programming",
        "released": 1999,
        "link": "https://doi.org/10.1145/632716.632824"
    },
    {
        "title": "Online mob programming: Effective collaborative project-based learning",
        "abstract": "This work presents a new paradigm for collaborative project-based computer science education called Online Mob Programming (OMP). OMP is adapted from the industrial practice of Mob Programming, where groups of developers work on the same problem, at the same time, in the same place. OMP was designed and implemented as a technique where a group of 4-6 students collaborate online through a structured process for solving programming tasks. In OMP, students rotate through clearly defined roles to collectively contribute towards a solution to a programming challenge. These roles require students to brainstorm potential solutions, decide on a path forward, and implement the correct course of action respectively. OMP was investigated in the context of a 6-week free online course on Cloud Computing. During the course, students participated in four intelligent conversational agent-coordinated OMP sessions. By instrumenting the online development environment, all student code revisions and chat logs were collected in addition to qualitative data from questionnaires. Analyses show evidence of success in terms of students following the structure of OMP and further investigations into differences in mob behavior based on the size, and problem outcome provide pedagogically valuable insights and a path toward building OMP into the computer science education curriculum.",
        "keywords": "collaborative learning; computer-supported collaborative learning; mob programming; online mob programming; project-based learning",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3293709"
    },
    {
        "title": "Varis: IDE support for embedded client code in PHP web applications",
        "abstract": "In software development, IDE services such as syntax highlighting, code completion, and \"jump to declaration\" are used to assist developers in programming tasks. In dynamic web applications, however, since the client-side code is dynamically generated from the server-side code and is embedded in the server-side program as string literals, providing IDE services for such embedded code is challenging. In this work, we introduce Varis, a tool that provides editor services on the client-side code of a PHP-based web application, while it is still embedded within server-side code. Technically, we first perform symbolic execution on a PHP program to approximate all possible variations of the generated client-side code and subsequently parse this client code into a VarDOM that compactly represents all its variations. Finally, using the VarDOM, we implement various types of IDE services for embedded client code including syntax highlighting, code completion, and \"jump to declaration\". The video demonstration for Varis is available at http://www.youtube.com/watch?v=w1TECeRXGrg.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2819009.2819140"
    },
    {
        "title": "Jaguar: Low latency mobile augmented reality with flexible tracking",
        "abstract": "In this paper, we present the design, implementation and evaluation of Jaguar, a mobile Augmented Reality (AR) system that features accurate, low-latency, and large-scale object recognition and flexible, robust, and context-aware tracking. Jaguar pushes the limit of mobile AR’s end-to-end latency by leveraging hardware acceleration with GPUs on edge cloud. Another distinctive aspect of Jaguar is that it seamlessly integrates marker-less object tracking offered by the recently released AR development tools (e.g., ARCore and ARKit) into its design. Indeed, some approaches used in Jaguar have been studied before in a standalone manner, e.g., it is known that cloud offloading can significantly decrease the computational latency of AR. However, the question of whether the combination of marker-less tracking, cloud offloading and GPU acceleration would satisfy the desired end-to-end latency of mobile AR (i.e., the interval of camera frames) has not been eloquently addressed yet. We demonstrate via a prototype implementation of our proposed holistic solution that Jaguar reduces the end-to-end latency to  33 ms. It also achieves accurate six degrees of freedom tracking and 97",
        "keywords": "augmented reality; gpu acceleration; mobile edge computing; object recognition; object tracking",
        "released": 2018,
        "link": "https://doi.org/10.1145/3240508.3240561"
    },
    {
        "title": "SqueakJS: A modern and practical smalltalk that runs in any browser",
        "abstract": "We report our experience in implementing SqueakJS, a bit-compatible implementation of Squeak/Smalltalk written in pure JavaScript. SqueakJS runs entirely in the Web browser with a virtual filesystem that can be directed to a server or client-side storage. Our implementation is notable for simplicity and performance gained through adaptation to the host object memory and deployment leverage gained through the Lively Web development environment. We present several novel techniques as well as performance measurements for the resulting virtual machine. Much of this experience is potentially relevant to preserving other dynamic language systems and making them available in a browser-based environment.",
        "keywords": "javascript; languages; performance; smalltalk; squeak; virtual machines; web browsers",
        "released": 2014,
        "link": "https://doi.org/10.1145/2661088.2661100"
    },
    {
        "title": "Feature driven browsing",
        "abstract": "Development environments typically present the software engineer with a structural perspective of an object-oriented system in terms of packages, classes and methods. From a structural perspective it is difficult to gain an understanding of how source entities participate in a system’s features at runtime, especially when using dynamic languages such as Smalltalk. In this paper we evaluate the usefulness of offering an alternative, complementary feature-centric perspective of a software system when performing maintenance activities. We present a feature-centric environment combining interactive visual representations of features with a source code browser displaying only the classes and methods participating in a feature under investigation. To validate the usefulness of our feature-centric view, we conducted a controlled empirical experiment where we measured and compared the performance of subjects when correcting two defects in an unfamiliar software system with a traditional development environment and with our feature-centric environment. We evaluate both quantitative and qualitative data to draw conclusions about the usefulness of a feature-centric perspective to support program comprehension during maintenance activities.",
        "keywords": "",
        "released": 2007,
        "link": "https://doi.org/10.1145/1352678.1352684"
    },
    {
        "title": "Booting into AI: Startup instructions for teaching artificial intelligence",
        "abstract": "This tutorial will provide a foundation for faculty members either teaching a course in artificial intelligence for the first time or renewing a course that has been dormant. The growing ubiquity of AI and machine learning dictates that departments offer a course in this area, regardless of whether any such expertise exists locally. Furthermore, there are many possible approaches, from a general overview to a tight focus on a particular application area, either as a single elective or a specialization area within an undergraduate degree. An increasingly wide range of resources is available, but intelligent selection from the plethora of information can be a challenge, particularly in smaller programs where no local expertise is available. The tutorial is in two parts. Part 1 focuses on background knowledge, discussing major divisions within the broad field of AI, research trends and application areas, and commonly used tools. Part 2 addresses classroom implementation, assessment, textbook options, and online resources including code libraries, free-to-use data sets, development environments, and visualization tools. Participants will have the opportunity to brainstorm and discuss options for course focus. Sample syllabi using differing course approaches, sample exams and assignments, and a non-exhaustive list of useful resources will be provided.",
        "keywords": "artificial intelligence; course design; curriculum; machine learning",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287547"
    },
    {
        "title": "EasyApp: A cross-platform mobile applications development environment based on OSGi",
        "abstract": "*** The rapid development of mobile internet abstracts many non-professional persons to creating mobile applications. Traditional development process cannot meet their needs. In this paper, we present a cross-platform mobile development environment based on OSGi framework, EasyApp. It provides a highly-integrated, UI-friendly and easily-operating environment. Applications are comprehensively developed with web techniques. Users could create mobile applications with draggable widgets. Native APIs of mobile phone can be invoked with abundant plugins. After designing, users could package and download applications of multiple platforms. ***",
        "keywords": "End-user development; Mobile application; OSGi; Widgets communication",
        "released": 2016,
        "link": "https://doi.org/10.1145/2934872.2959074"
    },
    {
        "title": "Special projects grants awarded",
        "abstract": "SIGCSE received 15 Special Projects grant proposals for the May 2012 funding cycle. The Special Projects Committee is pleased to announce that the following four grants have been awarded:Anthony Allevato and Steve Edwards, Virginia Tech, \"Pythy—A Cloud-Based IDE for Novice Python Programmers\" (http://pythy.cs.vt.edu/). This project will develop a Web-based environment in which novice programmers can write and run Python programs and access documentation and tutorials. This environment reduces the barriers students often face if they have to install development tools on their own computers.",
        "keywords": "",
        "released": 2012,
        "link": "https://doi.org/10.1145/2350216.2350222"
    },
    {
        "title": "Multimodal programming for dyslexic students",
        "abstract": "As the Web’s role in society increases, so to does the need for its universality. Access to the Web by all, including people with disabilities has become a requirement of Web sites as can be seen by the passing of the Americans with Disabilities Act in 1990. This universality has spilled over into other disciplines, e.g. screen readers for Web browsing; however Computer Science has not yet made significant efforts to do the same. The main focus of this research is to provide this universal access in the development of virtual learning environments, more specifically in computer programming. To facilitate this access, research into the features of dyslexia is required: what it is, how it affects a person’s thought process and what changes are necessary to facilitate these effects. Also, a complete understanding of the thought process in the creation of a complete computer program is necessary.Dyslexia has been diagnosed as affecting the left side of the brain. The left side of the brain processes information in a linear, sequential manner. It is also responsible for processing symbols, which include letters, words and mathematical notations. Thus dyslexics have problems with the code generation, analysis and implementation steps in the creation of a computer program. Potential solutions to this problem include a multimodal programming environment.This multimodal environment will be interactive, providing multimodal assistance to the user as they generate, analyze and implement code. This assistance will include the ability to add functions and loops via voice and receiving a spoken description of a code segment that has been selected by the cursor.",
        "keywords": "",
        "released": 2004,
        "link": "https://doi.org/10.1145/1027933.1028001"
    },
    {
        "title": "Evolution of mobile software development from platform-specific to web-based multiplatform paradigm",
        "abstract": "In this paper, we outline a projection on the trend of using web technologies for creating end-user applications in mobile devices. Following a paradigm shift in the software industry, from only-binary applications to dynamic web applications, mobile web development tools evolve to offer an integral native solution that allows to simplify the soft-ware process and broad its scope to a true, single cross-platform development effort. Soon, mobile web development tools will be preferred by designers and programmers thanks to their versatility, economy and usefulness, less dependent on specific platforms and SDKs, while fully functional and reliable in comparison to their binary counterparts.",
        "keywords": "",
        "released": 2012,
        "link": "https://doi.org/10.1145/2048237.2157457"
    },
    {
        "title": "Debugging OWL ontologies",
        "abstract": "As an increasingly large number of OWL ontologies become available on the Semantic Web and the descriptions in the ontologies become more complicated, finding the cause of errors becomes an extremely hard task even for experts. Existing ontology development environments provide some limited support, in conjunction with a reasoner, for detecting and diagnosing errors in OWL ontologies. Typically these are restricted to the mere detection of, for example, unsatisfiable concepts. We have integrated a number of simple debugging cues generated from our description logic reasoner, Pellet, in our hypertextual ontology development environment, Swoop. These cues, in conjunction with extensive undo/redo and Annotea based collaboration support in Swoop, significantly improve the OWL debugging experience, and point the way to more general improvements in the presentation of an ontology to new users.",
        "keywords": "OWL; explanation; ontology engineering; semantic Web",
        "released": 2005,
        "link": "https://doi.org/10.1145/1060745.1060837"
    },
    {
        "title": "Exploring the benefits and barriers of using computational notebooks for collaborative programming assignments",
        "abstract": "Programming assignments in computer science courses are often processed in pairs or groups of students. While working together, students face several shortcomings in today’s software: The lack of real-time collaboration capabilities, the setup time of the development environment, and the use of different devices or operating systems can hamper students when working together on assignments. Text processing platforms like Google Docs solve these problems for the writing process of prose text, and computational notebooks like Google Colaboratory for data analysis tasks. However, none of these platforms allows users to implement interactive applications. We deployed a web-based literate programming system for three months during an introductory course on application development to explore how collaborative programming practices unfold and how the structure of computational notebooks affect the development. During the course, pairs of students solved weekly programming assignments. We analyzed data from weekly questionnaires, three focus groups with students and teaching assistants, and keystroke-level log data to facilitate the understanding of the subtleties of collaborative programming with computational notebooks. Findings reveal that there are distinct collaboration patterns; the preferred collaboration pattern varied between pairs and even varied within pairs over the course of three months. Recognizing these distinct collaboration patterns can help to design future computational notebooks for collaborative programming assignments.",
        "keywords": "application development; collaborative programming; computational notebooks; programming assignments",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3366887"
    },
    {
        "title": "Profile-based detection of layered bottlenecks",
        "abstract": "Detection of software bottlenecks which hinder utilizing hardware resources is a classic but complex problem due to the layered structures of the software bottlenecks. However, model-based approaches require a performance model given, which is impractical to maintain under today’s agile development environment, and profile-based approaches do not handle the layered structures of the software bottlenecks.This paper proposes a novel approach of taking the best of both worlds which extracts a performance model from execution profiles of the target application to detect the layered bottlenecks. We collect a wake-up profile of threads, which samples an event that one thread wakes up another thread, and build a thread dependency graph to detect the layered bottlenecks.We implement our approach of profile-based detection of layered bottlenecks in the Go programming language. We demonstrate that our method can detect software bottlenecks limiting scalability and throughput of state-of-the-art middleware such as a web application server and a permissioned blockchain network, with small amount of the runtime overhead for profile collection.",
        "keywords": "layered bottlenecks; thread dependency graph; wake-up profile",
        "released": 2019,
        "link": "https://doi.org/10.1145/3297663.3310296"
    },
    {
        "title": "On designing of an intro to web development course for non-majors with modern frameworks and tools",
        "abstract": "Mobile web development is one of the fast growing fields in IT. New and powerful front-end development technologies and tools are available to help users with limited experience build mobile-friendly responsive websites. However, these recent technologies, such as responsive web design frameworks, are rarely covered in intro-level web development courses, especially to students with no programming background. We present our experience in the redesign of an introduction course to web front-end development that integrates the recently released W3.CSS responsive framework and other development tools commonly used in industry. The previous HTML + CSS structure of the course is replaced by HTML + CSS + W3.CSS Framework along with the usage of various tools. The goal is to help students gain experience with modern web development, boost their confidence in mastering new technologies and develop transferable skills in problem solving. The initial evaluation shows very positive response from non-major students.",
        "keywords": "",
        "released": 2017,
        "link": "https://dl.acm.org/doi/10.5555/3069658.3069666"
    },
    {
        "title": "Demystifying the soft and hardened memory systems of modern FPGAs for software programmers through microbenchmarking",
        "abstract": "Both modern datacenter and embedded Field Programmable Gate Arrays (FPGAs) provide great opportunities for high-performance and high-energy-efficiency computing. With the growing public availability of FPGAs from major cloud service providers such as AWS, Alibaba, and Nimbix, as well as uniform hardware accelerator development tools (such as Xilinx Vitis and Intel oneAPI) for software programmers, hardware and software developers can now easily access FPGA platforms. However, it is nontrivial to develop efficient FPGA accelerators, especially for software programmers who use high-level synthesis (HLS).The major goal of this article is to figure out how to efficiently access the memory system of modern datacenter and embedded FPGAs in HLS-based accelerator designs. This is especially important for memory-bound applications; for example, a naive accelerator design only utilizes less than 5",
        "keywords": "Datacenter FPGAs; embedded FPGAs; memory system; HLS; benchmarking",
        "released": 2022,
        "link": "https://doi.org/10.1145/3517131"
    },
    {
        "title": "Can social screencasting help developers learn new tools?",
        "abstract": "An effective way to learn about software development tools is by directly observing peers’ workflows. However, these tool knowledge transfer events happen infrequently because developers must be both colocated and available. We explore an online social screencasting system that removes the dependencies of colocation and availability while maintaining the beneficial tool knowledge transfer of peer observation. Our results from a formative study indicate these online observations happen more frequently than in-person observations, but their effects are only temporary. We conclude that while peer observation facilitates online knowledge transfer, it is not the only component — other social factors may be involved.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2819321.2819345"
    },
    {
        "title": "Practical guide to using the YFCC100M and MMCOMMONS on a budget",
        "abstract": "The Yahoo-Flickr Creative Commons 100 Million (YFCC100M), the largest freely usable multimedia dataset to have been released so far, is widely used by students, researchers and engineers on topics in multimedia that range from computer vision to machine learning. However, its sheer volume, one of the traits that make the dataset unique and valuable, can pose a barrier to those who do not have access to powerful computing resources. In this article, we introduce useful information and tools to boost the usability and accessibility of the YFCC100M, including the supplemental material provided by the Multimedia Commons (MMCOMMONS) community. In particular, we provide a practical guide on how to set up a feasible and cost effective research and development environment locally or in the cloud that can access the data without having to download it first.",
        "keywords": "",
        "released": 2017,
        "link": "https://doi.org/10.1145/3173058.3173063"
    },
    {
        "title": "Euclase: A live development environment with constraints and FSMs",
        "abstract": "Euclase is a live development environment focused on creating interactive web applications. It uses a programming model that combines constraints and finite state machines to specify interactive behaviors. Euclase is \"live\" in the sense that while the user is developing code, their program is always executing. Changes made to the source of the program are reflected immediately in the running program. We identify some of the implementation and design challenges of making our development environment live, including performance issues, ensuring predictability, dealing with errors in the source, and handling edge cases such as the removal of code that is currently running. We also discuss how Euclase’s use of finite state machines and constraints can help alleviate these difficulties.",
        "keywords": "constraints; finite state machines; interaction design; interactive applications; live development",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2662726.2662731"
    },
    {
        "title": "Students’ understanding of basic computational concepts in an introduction to mobile development course",
        "abstract": "Building basic computational thinking skills is an important goal in courses that introduce computing to students with limited programming background. Among choices of tools and platforms, MIT App Inventor is a popular mobile app development environment particularly suitable for engaging novice learners. Users are able to create their own mobile apps with real-world usefulness without having to deal with difficult language syntax. However, a study of computational thinking assessment showed students had difficulties in learning abstract concepts such as procedure and flow control using App Inventor [1]. Meanwhile, non-CS major students demonstrated a lack of continuous growth in computational thinking skills compared to CS major students [1]. In another recent study [2], students reported increased interests in computing after being exposed to modern responsive web development, but it is unclear if having an HTML/CSS background makes it more effective in learning abstract computational concepts when using App Inventor.",
        "keywords": "",
        "released": 2018,
        "link": "https://dl.acm.org/doi/10.5555/3205191.3205223"
    },
    {
        "title": "DDFP ’13: Proceedings of the 2013 workshop on data driven functional programming",
        "abstract": "Functional programming techniques are becoming increasingly important in data-centric programming: languages like Haskell, Scala and C# draw heavily on a range of functional techniques and find application in numerous data-driven domains; functional paradigms like map/reduce and its extensions lie at the core of modern scalable data processing; and \"information-rich\" languages like Ur, F# and Gosu use metaprogramming to integrate type-safe queries, web-based APIs and scalable data sources along with associated semantically-rich metadata into the programming language. In principle, the expressiveness, strong typing and core functional paradigm of these languages make them an ideal choice for expressing robust and scalable data-centric programming.However, many challenges remain. We live in an information rich world. Programming languages are not designed for this. On the programming side, as the world moves into ubiquitous computing with devices and services, it is vital that developers can productively integrate information at internet-scale into their everyday programming environment. On the information side, as the web continues to grow with linked data and open data resources being made available more broadly by government agencies (e.g. World Bank) and communities (e.g. Freebase) it becomes even more important to have the tools and mechanisms to make sense of the data.The goal of the Data Driven Functional Programming Workshop 2013 is to discuss, promote, and advance the use of functional programming in information-rich data spaces — including the development of new programming and data-manipulation systems and the extension of existing ones. By devising methods for handling data from the programming level, we can promote the research and development of better functional programming technologies as a whole, as well as facilitate the shift towards both principled and effective data-centric computing.The papers included in the proceedings explore the area of data-centric programming in the light of today’s data challenges, particularly with a view to the application of functional programming and metaprogramming techniques. Research projects and short papers explore the following topics: Formal systems that capture the essential theoretical elements of data-centric programmingExperimental systems that demonstrate novel data-centric programming techniquesTechnology that demonstrate correctness, scalability, productivity, robustness or maintainability of data-centric programsSchema evolution, schema-type mapping, query languages, probabilistic programming, networkconnected programming or semi-structured dataProgramming-related aspects of knowledge representation techniques including the database theory, ontology techniques and linked data.New views and opinions, coming from the functional programming and semantic web communities, address some of the following questions: How to effectively explore, navigate, understand, analyze and present data to the developerWhat are the necessary tools and language features needed to help streamline the developer experienceHow to easily access and query linked dataHow to seamlessly integrate and manipulate diverse datasetsHow to help humans make sense of semantically-rich dataHow to address schema evolution, schema-type mapping, query languages, probabilistic programming?In addition, the program includes a keynote, a tutorial on Information-rich Programming and a panel on Next Generation Data-Driven Programming. We hope that these proceedings will help promote the discussion among the data-driven research and the functional programming communities.",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.1145/2429376"
    },
    {
        "title": "f3.js: A parametric design tool for physical computing devices for both interaction designers and end-users",
        "abstract": "Although the exploration of design alternatives is crucial for interaction designers and customization is required for end-users, the current development tools for physical computing devices have focused on single versions of an artifact. We propose the parametric design of devices including their enclosure layouts and programs to address this issue. A Web-based design tool called f3.js is presented as an example implementation, which allows devices assembled from laser-cut panels with sensors and actuator modules to be parametrically created and customized. It enables interaction designers to write code with dedicated APIs, declare parameters, and interactively tune them to produce the enclosure layouts and programs. It also provides a separate user interface for end-users that allows parameter tuning and dynamically generates instructions for device assembly. The parametric design approach and the tool were evaluated through two user studies with interaction designers, university students, and end-users.",
        "keywords": "integrated development environment; parametric design; personal fabrication; physical computing",
        "released": 2017,
        "link": "https://doi.org/10.1145/3064663.3064681"
    },
    {
        "title": "TouchDevelop: Create rich mobile apps on touch devices (tutorial)",
        "abstract": "We are experiencing a technology shift: Powerful and easy-to-use mobile devices like smartphones and tablets are becoming more prevalent than traditional PCs and laptops. Mobile devices are going to be the first and, in less developed countries, possibly the only computing devices which virtually all people will own and carry with them at all times. In this tutorial, participants will learn about developing software directly on their mobile devices. The tutorial is based on TouchDevelop, a modern software development environment that embraces this new reality, treating mobile devices as first-class software development machines, instead of relying on legacy development models built around PC. TouchDevelop comes with typed, structured programming language that is built around the idea of only using a touchscreen as the input device to author code. Access to the cloud, flexible user interfaces, and access to sensors such as accelerometer and GPS are available as a first-class citizens in the programming language. TouchDevelop is available as a web app on Windows tablets, iOS, Android, Windows PCs and Macs, and as a native app on Windows Phone.",
        "keywords": "Web IDE; mobile devices; smart phone; tablet; touch-based entry",
        "released": 2014,
        "link": "https://doi.org/10.1145/2593902.2593903"
    },
    {
        "title": "Integrating segmentation and paging protection for safe, efficient and transparent software extensions",
        "abstract": "The trend towards extensible software architectures and component-based software development demands safe, efficient, and easy-to-use extension mechanisms to enforce protection boundaries among software modules residing in the same address space. This paper describes the design, implementation, and evaluation of a novel intra-address space protection mechanism called Palladium, which exploits the segmentation and paging hardware in the Intel X86 architecture and efficiently supports safe kernel-level and user-level extensions in a way that is largely transparent to programmers and existing programming tools. Based on the considerations on ease of extension programming and systems implementation complexity, Palladium uses different approaches to support user-level and kernel-level extension mechanisms. To demonstrate the effectiveness of the Palladium architecture, we built a Web server that exploits the user-level extension mechanism to invoke CGI scripts as local function calls in a safe way, and we constructed a compiled network packet filter that exploits the kernel-level extension mechanism to run packet-filtering binaries safely inside the kernel at native speed. The current Palladium prototype implementation demonstrates that a protected procedure call and return costs 142 CPU cycles on a Pentium 200MHz machine running Linux.",
        "keywords": "",
        "released": 1999,
        "link": "https://doi.org/10.1145/319151.319161"
    },
    {
        "title": "Introducing CandleWeb and å (awe), bringing animation power to the world wide web",
        "abstract": "The World Wide Web has limited interactive capabilities, and does not support animated graphics well. To allow real-time interaction and animated graphics that are both pedagogically and commercially motivating, we must extend the Web. A new tool called CandleWeb is presented. CandleWeb works together with standard HTML browsers, and uses the hypertext transport protocol (HTTP). The tool has been implemented for X11, and interprets a language called Å (awe) which combines a simple C-like syntax with standardized graphics objects to provide a programming environment in which presentations including animation can be produced efficiently. An authoring tool called Å (awe) Composer allows programmers to save considerable time in implementing animated presentations, compared to text-based programming, using graphics libraries. The CandleWeb client for X11 V1.0beta and the Å (awe) language are openly available on the Internet at the site http://www.oslonett.no/ candle/.",
        "keywords": "advertising; animation; awe; authoring; browser; C; CandleWeb; client; commercial; composer; education; graphics; HTML; HTTP; interactive; interpretation; language; programming; realtime; tool; world wide web; Å",
        "released": 1995,
        "link": "https://doi.org/10.1145/3592626.3592659"
    },
    {
        "title": "Managing APL public code for an in-house APL system (before and after LOGOS)",
        "abstract": "This paper will present APL Public Library management concepts used in a large in-house APL system development environment and describe a number of tools developed for this purpose. Public libraries, workspaces, functions and variables are discussed as well as documentation, reporting of changes, audit records, backup versions, and test versions. User tools discussed include functions for describing APL public files, libraries, workspaces, functions and variables, locating these objects, keyword searches, and a glossary of terms. Other user facilities include a NEWS system and an online system for submitting problem reports and requests for enhancements. Further maintenance tools include automatic generation of WSDOC listings when changes are made and automatically generated reports providing a variety of information such as libraries or workspaces lacking descriptions, lists of APL public workspaces and files with their status, function source verification, and exception reporting of workspace changes.A discussion of LOGOS, a programming environment for APL offered by IP Sharp Associates, is also presented and how it enhances the capabilities previously described.",
        "keywords": "",
        "released": 1987,
        "link": "https://doi.org/10.1145/28315.28341"
    },
    {
        "title": "End-user personalization of context-dependent applications in AAL scenarios",
        "abstract": "The design and development of flexible applications able to match the many possible user needs and provide high quality user experience is still a major issue. In ambient-assisted living scenarios there is the need of giving adequate support to elderly so that they can independently live at home. Thus, providing personalized assistance is particularly critical because ageing people often have different ranges of individual needs, requirements and disabilities. In this position paper we introduce a solution based on an End-User Development environment that allows patients and caregivers to tailor the context-dependent behaviour of their Web applications in order to facilitate patients’ life. This is done through the specification of trigger-action rules to support application customization.",
        "keywords": "AAL; end-user development; personalization",
        "released": 2016,
        "link": "https://doi.org/10.1145/2957265.2965005"
    },
    {
        "title": "Crossfire: Multiprocess, cross-browser, open-web debugging protocol",
        "abstract": "We present Crossfire, a system and protocol designed to enable debugging of Web pages in another process or machine. Issues specific to any one Web browser are abstracted by the protocol and implementation, allowing a new generation of Open Web development tools to be implemented. We discuss the major refactoring of Firebug, the open source Web debugging tool to use Crossfire and the interplay between goals and resources that such an effort requires. In addition to the cross-browser focus of the protocol, we also discuss support for extensions which themselves will be cross-browser and client-server.",
        "keywords": "distributed debugging; open source; source-level debugging",
        "released": 2011,
        "link": "https://doi.org/10.1145/2048147.2048185"
    },
    {
        "title": "Design insights for a mobile based sensor application framework: For aiding platform independent algorithm design",
        "abstract": "Modern day smart phones are powerful connected sensory and computation nodes for crowd-sensing, urban-sensing and personal-sensing applications. We have developed an Internet of Things (IoT) platform that can seamlessly handle data from the wide variety of sensors available on mobile phones. It can store and run aggregated analysis on the data in real-time. However, mobile phones themselves are a very heterogeneous set of devices. Each phone comes with a different array of sensors with varying sensitivity and control functions. Also, there are multiple development environments and programming languages. A final problem is seamless prototyping of applications offline and then seamless partitioning of the algorithm between phone and the cloud. In this paper we present early design elements of a framework aimed at addressing these issues.",
        "keywords": "frameworks; middle-ware; mobile sensing; system design",
        "released": 2015,
        "link": "https://doi.org/10.1145/2737095.2737149"
    },
    {
        "title": "AnDrone: Virtual drone computing in the cloud",
        "abstract": "With the continued proliferation of drones, unmanned aerial vehicles, additional uses for them are growing and the demand for their services is on the rise. We present AnDrone, a drone-as-a-service solution that makes drones accessible in the cloud. AnDrone pairs a cloud service with the first drone virtualization architecture. This enables a physical drone to run multiple virtual drones simultaneously in an isolated and secure manner at little additional cost, as computational costs are cheap compared to the operational and energy costs of putting a drone in the air. AnDrone virtualizes drones using a novel Linux container architecture. Android Things virtual drone containers provide a familiar user and development environment that can run existing Android apps. A real-time Linux flight controller container supports existing drone flight software and provides virtual drones with geofenced flight control. A device container transparently multiplexes access from virtual drones to a full range of drone hardware devices, including cameras and other sensors. Upon flight completion, virtual drones and their data can be uploaded to the cloud for offline access. We have implemented an AnDrone prototype based on Raspberry Pi 3 drone hardware. We demonstrate that it incurs minimal runtime performance and energy overhead, supports real-time virtual drone flight control, and runs untrusted third-party software in virtual drones in a secure manner while ensuring that the service provider maintains control of the drone hardware.",
        "keywords": "cloud computing; containers; drones; real-time; unmanned aerial vehicles; virtualization",
        "released": 2019,
        "link": "https://doi.org/10.1145/3302424.3303969"
    },
    {
        "title": "Using the xbox kinect™ sensor for gesture recognition",
        "abstract": "The Kinect sensor was introduced in November 2010 by Microsoft as an accessory for the Xbox 360 video game system. Shortly after the product release, multiple software frameworks became available that allows a personal computer to capture output from a stand-alone Kinect [1,2].The Kinect contains a RGB camera and a depth sensor using an IR light source that allows the unit to output three dimensional positional data in real time. The Kinect data is organized as a stream of two 640 x 480 images acquired at a rate of 30 frames per second (fps). One of these is an ordinary 24-bit RGB video image. The other is an 11-bit depth image from which (x, y, z) positional data may be calculated. Students are well aware of the Kinect as an input device for the Xbox 360 system which makes it an ideal venue for student experimentation and independent study projects using a personal computer platform.As part of the OpenNI framework [2], middleware (NITE [3]) is available that allows the Kinect to recognize gestures. The gestures include focus (getting the Kinect’s attention), wave, swipe (up, down, left or right) and circle. The gestures may be used to control user interfaces with gesture’s as well as being the foundation for gaming activities.The tutorial presentation will provide attendees with detailed information on the use of the NITE middleware in the C++ development environments for the Kinect. In this tutorial we will present:• Hardware and software requirements for the development environment.• Detailed instructions for downloading of device drivers, OpenNI framework and NITE middleware and associated libraries.• \"Hello World\" examples for checking the functionality of the NITE middleware with Kinect unit.• An overview of the NITE middleware capabilities including functionality and limitations.• A summary of the library structure of the OpenNI and NITE frameworks.• Several simple examples of the devices capabilities including player tracking and the use of gesture recognition.• A summary of research opportunities that are student accessible.All software and materials presented during the tutorial will be provided on the author’s web site so that users may quickly get their Kinect applications up and running without significant configuration issues and start-up problems.",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2458569.2458617"
    },
    {
        "title": "Web and mobile ticketing and service tracking for customer engagement of a small accounting firm",
        "abstract": "The abundance of free technology tools that can be used to communicate of today’s businesses are in way creating more confusion and redundant tasks which is not good for a striving small business. The study aims to serve as a single platform of communication tool for a small accounting firm, a website and mobile application were developed which are the capable of providing an online ticketing which can respond to customer concerns, a service tracking, and a tool that can aggregate reports of the firm’s performance in providing services in the form of charts. Web Development Life Cycle (WDLC) was used as the process model in the development of the website and mobile application. Interview validated the business processes and supported the design of web and mobile applications. Development tools used for website and mobile application are Cascading Style Sheets (CSS), Hypertext Preprocessor (PHP), Android and MySQL for database. In order to evaluate the performance of the developed system, a usability evaluation was conducted with the customers and employees of the accounting firm using the criteria: communication, transaction, aesthetics, ease of use, information and maintainability. Evaluation result shows that majority of customers strongly agree on the efficiency of communication and transaction functionalities of the developed system with the need in the improvement of image and text. Meanwhile, the evaluation of website’s back-end shows promising result as well with mostly strongly agreement except for the transaction criterion wherein the employees who used the developed system had difficulty in using the system. Overall, the visual components, management of tickets, management of service tracking and viewing of the aggregate reports in the form of charts are all beneficial to a small business so that they could focus on their core business and use the developed website and application in customer engagement.",
        "keywords": "Communication Tool; Customer Engagement; Mobile Application; Online Ticketing; Service Tracking; Website",
        "released": 2019,
        "link": "https://doi.org/10.1145/3332324.3332327"
    },
    {
        "title": "IDVE: An integrated development and verification environment for JavaScript",
        "abstract": "Program verifiers statically check programs based on source code annotations such as invariants, pre- and postconditions. These annotations can be more precise than simple types. For example, a sorting routine might be annotated with a postcondition stating that its result is sorted.However, the verification process for these annotations can become complex. Therefore, simple error messages may not be sufficient to help the programmer resolve verification issues. In order to improve the programming experience for verified programming, this paper presents IDVE, an integrated development and verification environment that lets users interactively inspect and debug verification issues. The goal of IDVE is to provide a development tool that assists users with program verification analogous to how interactive step-by-step debugging avoids manual \"printf debugging\". IDVE enables programmers to interactively manipulate assumptions and assertions of verification conditions with a novel verification inspector, and IDVE automatically generates tests that serve as executable and debuggable counterexamples.In addition to presenting the approach and implementation of the integrated development and verification environment, we also conducted a user study with 18 participants to evaluate how the proposed features of the environment are perceived. Participants with and without prior experience with program verifiers had to solve a series of simple programming and verification tasks and answer an online survey. Features of IDVE were generally seen as helpful or potentially helpful but user interface design is an essential factor for their utility.",
        "keywords": "JavaScript; interactive debugging; program verification; programming environments; test generation",
        "released": 2019,
        "link": "https://doi.org/10.1145/3328433.3328453"
    },
    {
        "title": "Evaluating the use of a MOOC within higher education professional development training",
        "abstract": "This paper evaluates the effectiveness of a massive open online course (MOOC) as a professional development tool in higher education. The transition from the MOOC’s initial intended use as a low cost way for students to access education and aid their studies has evolved to facilitate continuing professional development (CPD), particularly within the commercial sector [1]. Findings from this study indicate there is an increase in participation and satisfaction amongst higher education staff who undertook a MOOC compared to attending traditional staff development days. Recommendations from this study?s findings highlight that staff were keen to engage with the MOOC format, but felt they needed face-to-face meetings as well to reinforce, contextualize and discuss the key messages of the MOOC. In addition to this, time allocation within workloads should be considered for any future inclusion of MOOCs for staff development.",
        "keywords": "cpd; higher education; mooc; professional development; staff development",
        "released": 2016,
        "link": "https://doi.org/10.1145/2872518.2890577"
    },
    {
        "title": "Java-based user interface development",
        "abstract": "This tutorial provide attendees with an understanding of the possibilities provided by the World Wide Web for application development and a more detailed understanding of the issues involved in developing user interfaces for the Web in Java.",
        "keywords": "Java; applets; development tools; user interfaces; world wide web",
        "released": 1997,
        "link": "https://doi.org/10.1145/1120212.1120342"
    },
    {
        "title": "Exploring the use of video reflection as a professional development tool",
        "abstract": "The use of video recording in the classroom has the potential to improve pre- and in-service teacher practice. This poster explores the use of video as a virtual-visit and professional development tool for computer science educators at the high school level. The Mobile Computer Science Principles (CSP) program offers a rigorous professional development (PD) and curriculum for new and experienced computer science teachers. With support from the National Science Foundation, the program was able offer a stipend to teachers who completed the research requirements, which for the online program included recording, reflecting on, and submitting a 10-minute unedited video of educators implementing a chosen lesson in their course. In addition to the video submission and reflection, teachers reviewed and commented on others videos in a protected online environment. Researchers have begun examining the teacher reflections and the comments. This poster presents preliminary common themes and findings from teacher video reflections, video comments, focus group data, and an end of course survey. Trends surrounding student engagement, teacher confidence, and teacher views of effective pedagogical strategies such as growth mindset and pair programming have emerged. Results show that while computer science educators can often feel isolated in their school environment, video serves as a powerful tool for promoting connectedness and individual reflection. Creating a space where teachers can reflect on their own teaching is an important professional development opportunity. Results show that while computer science educators can often feel isolated in their school environment, video serves as a powerful tool for promoting connectedness and individual reflection. The use of video helps teachers to how to develop and implement best teaching practices and pedagogical strategies effectively into their classroom.",
        "keywords": "best practices; computer science principles; k-12; pedagogy; professional development; video reflection",
        "released": 2019,
        "link": "https://doi.org/10.1145/3291279.3341213"
    },
    {
        "title": "From java to c# a workshop on the how, what, and why",
        "abstract": "The .NET platform is incredibly rich, allowing you to build a variety of applications with a multitude of languages. Using a common development environment, students can program in languages such as C#, VB, C++, F#, and Python, creating software with a range of interfaces (console, GUI and web) and functionality (scientific, database, distributed, service-oriented, game and robotic). Microsoft’s flagship development environment, Visual Studio 2008, is freely-available to students via Microsoft’s DreamSpark program, along with Windows, SQL Server, and Expression Studio. These same tools are available for a nominal fee to institutional departments through Microsoft’s MSDN Academic Alliance. If you prefer, you can work outside of Visual Studio with command-line compilers, editors, and 3rd-party IDEs, or step off the Windows platform entirely and work with .NET on Linux, OS X or BSD using Mono.",
        "keywords": "",
        "released": 2009,
        "link": "https://dl.acm.org/doi/10.5555/1619221.1619224"
    },
    {
        "title": "Do biases related to geographical location influence work-related decisions in GitHub?",
        "abstract": "Visible demographic characteristics are seen as elements of bias in offline work environments. In this study, we investigate the influence of the geographical location on the evaluation of pull requests in GitHub – the most popular online collaborative code development environment. We use a mixed-methods approach and present analyses of 70,000+ pull requests and 2,500+ survey responses. Quantitative analysis of GitHub projects’ data suggests that the geographical location significantly explains the pull request acceptance decisions. These observations are in agreement with the perceptions of submitters based on their experiences with bias. Integrators feel that it is easy to work with contributors from the same geographical location and that they encourage contributors from the same geographical location. However, integrators do not feel that contributors from some countries are better at writing pull requests compared to others.",
        "keywords": "empirical software engineering; empirical studies; software process",
        "released": 2016,
        "link": "https://doi.org/10.1145/2889160.2891035"
    },
    {
        "title": "The IDE as a scriptable information system",
        "abstract": "Software engineering is extremely information-intensive. Every day developers work with source code, version repositories, issue trackers, documentation, web-based and other information resources. However, three key aspects of information work lack good support: (i) combining information from different sources; (ii) flexibly presenting collected information to enable easier comprehension; and (iii) automatically acting on collected information, for example to perform a refactoring. Poor support for these activities makes many common development tasks time-consuming and error-prone. We propose an approach that directly addresses these three issues by integrating a flexible query mechanism into the development environment. Our approach enables diverse ways to process and visualize information and can be extended via scripts. We demonstrate how an implementation of the approach can be used to rapidly write queries that meet a wide range of information needs.",
        "keywords": "code queries; refactoring; software visualization",
        "released": 2016,
        "link": "https://doi.org/10.1145/2970276.2970329"
    },
    {
        "title": "Incremental model synchronization in model driven development environments",
        "abstract": "Most modern model driven software development environments rely heavily on model transformations for generating various software design artifacts and eventually even source code. However, during development, maintenance and evolution activities, these software artifacts are subject to updates and refactoring operations. In such model driven development environments, these software artifacts need to be re-synchronized every time one of them is altered, so that they all remain consistent according to some specific rules, relations and domain constraints. Until now, the standard approach to model synchronization has been the re-application of all transformation rules, aiming thus for the complete re-generation of all artifacts in all models involved. This complete re-application is a safe yet computationally expensive way to ensure consistency among models. In this paper, we present a method for re-synchronizing software models in an incremental fashion by utilizing an indexing model. In this respect, using the proposed methodology, the time required for maintaining global model consistency is proportional to the size of the changes and not that of the models involved. The proposed approach has been applied for the incremental re-synchronization of large and complex models in the Eclipse Web Tools Platform (WTP). Results indicate that this solution can significantly reduce the time required to re-synchronize models in such comprehensive development environments as WTP.",
        "keywords": "",
        "released": 2009,
        "link": "https://doi.org/10.1145/1723028.1723053"
    },
    {
        "title": "Cloud-based support for global software engineering: Potentials, risks, and gaps",
        "abstract": "Global Software Engineering (GSE) aims at utilizing global expertise and reducing time-to-market and costs for software development. However, GSE faces serious challenges related to the communication, coordination and provision of development environments for geographically distributed GSE sites, resulting in increased costs. Nowadays, cloud computing offers a cost-effective and a handy solution to provide computing support for global business. In particularly, it provides potential and viable solutions to address concerns and challenges in GSE. We have reviewed the relevant literature on cloud-based support for GSE and identified a set of pros and cons for supporting GSE with cloud services. We also present some recommendations to increase the trustworthiness and productivity with cloud-based support for GSE. This paper outlines the potential benefits and risks of cloud computing to GSE and identifies some gaps that need to be addressed by cloud-based support towards more trustworthy and productive work environment for GSE. This will open windows of opportunities for tailoring the solution utilizing cloud-based support for GSE.",
        "keywords": "Cloud Computing; Global Software Engineering (GSE)",
        "released": 2014,
        "link": "https://doi.org/10.1145/2666581.2666583"
    },
    {
        "title": "MoodView: An advanced graphical user interface for OODBMSs",
        "abstract": "OODBMSs need more than declarative query languages and programming languages as their interfaces since they are designed and implemented for complex applications requiring more advanced and easy to use visual interfaces. We have developed a complete programming environment for this purpose, called MoodView. MoodView translates all the user actions performed through its graphical interface to SQL statements and therefore it can be ported onto any object-oriented database systems using SQL.MoodView provides the database programmer with tools and functionalities for every phase of object oriented database application development. Current version of MoodView allows a database user to design, browse, and modify database schema interactively and to display class inheritance hierarchy as a directed acyclic graph. MoodView can automatically generate graphical displays for complex and multimedia database objects which can be updated through the object browser. Furthermore, a database administration tool, a full screen text-editor, a SQL based query manager, and a graphical indexing tool for the spatial data, i.e., R Trees are also implemented.",
        "keywords": "graphical user interfaces; object-oriented databases",
        "released": 1993,
        "link": "https://doi.org/10.1145/166635.166643"
    },
    {
        "title": "Cracking the monolith: Challenges in data transitioning to cloud native architectures",
        "abstract": "Application modernization is the process of transforming a monolithic application to cloud native. This involves gradually building a new application consisting of microservices, and running it in conjunction with the monolithic application. Over a period of time, the functionality of the monolith shrinks drastically or transforms into yet another microservice. Solution architects are often faced with the task of ensuring this smooth transition - from monolith to cloud native. For large and complex monoliths, this task is non-trivial as the code base grows non-linearly over a period of time, thus posing multiple challenges.The complexity of a monolith is moved to the interconnections between microservices, leading to multiple points of failure. This also has implications on scalability and the need for replication. One of the biggest challenges is to maintain data consistency and statefulness across the services and enable a smooth transition of the data. Tracing performance issues also becomes complex as a single transaction can encompass multiple service calls, along with increased operational complexity due to increased demand of managing services.In this paper, we envision an automated approach that will enable a smooth transition from the monolith to microservices, thus alleviating the complexities faced by a solution architect. Our system leverages the existing data schema along with details obtained using profiling tools (in production or development environment), to understand the data flow and access patterns and use this information to to propose functional modules (microservices).",
        "keywords": "SLA; architecture; cloud native; monolith",
        "released": 2018,
        "link": "https://doi.org/10.1145/3241403.3241440"
    },
    {
        "title": "Towards serverless NFV for 5G media applications",
        "abstract": "The advent of virtualization and IaaS have revolutionized the telecom industry via SDN/NFV. A new wave of cloud-native PaaS promises to further improve SDN/NFV performance, portability, and cost-efficiency. In this poster, we highlight a work in progress being done in the 5G-MEDIA project [2], which pioneers the application of the serverless paradigm to NFV in the context of media intensive applications in 5G networks. Motivational use cases include tele-immersive gaming, mobile journalism and UHD content distribution. For example, consider a next-gen e-sport, in which bouts between gamers last only a few minutes. FaaS offers a clear cost-efficiency benefit for hosting such applications. An architecture is shown in Fig. 1. It includes i) an Application/Service Development Kit (SDK) to enable access to media applications development tools; ii) a Service Virtualization Platform (SVP) to run the ETSI MANO framework, the Media Service MAPE optimization component and the VIM and WIM plugins to enable NFVIs integration; iii) different NFVIs to execute media-specific VNFs. FaaS VIM is implemented for integration of FaaS with the rest of the MANO stack. It allows mixing FaaS and \"regular\" VNFs within the same media forwarding graph. For reference implementation, Apache OpenWhisk [1] and Kubernetes are used. The main challenge is extending the programming model to support groups of actions communicating over a network, while retaining the simplicity of FaaS. The project is supported by EU H2020 R&amp;I program (Grant Agreement No 761699).",
        "keywords": "",
        "released": 2018,
        "link": "https://doi.org/10.1145/3211890.3211916"
    },
    {
        "title": "A transparent framework based on accessing bridge and mobile app for protecting database privacy with PKI",
        "abstract": "With the popularity of cloud computing, database outsourcing has been adopted by many companies. However, database owners may not 100",
        "keywords": "PKI; database accessing middleware; database privacy; mobile app",
        "released": 2016,
        "link": "https://doi.org/10.1145/2940343.2940350"
    },
    {
        "title": "Improving the developer experience with a low-code process modelling language",
        "abstract": "Context: The OutSystems Platform is a development environment composed of several DSLs, used to specify, quickly build and validate web and mobile applications. The DSLs allow users to model different perspectives such as interfaces and data models, define custom business logic and construct process models. Problem: The DSL for process modelling (Business Process Technology (BPT)), has a low adoption rate and is perceived as having usability problems hampering its adoption. This is problematic given the language maintenance costs. Method: We used a combination of interviews, a critical review of BPT using the \"Physics of Notation\" and empirical evaluations of BPT using the System Usability Scale (SUS) and the NASA Task Load indeX (TLX), to develop a new version of BPT, taking these inputs and Outsystems’ engineers culture into account. Results: Evaluations conducted with 25 professional software engineers showed an increase of the semantic transparency on the new version, from 31",
        "keywords": "Developer Experience; Low-Code Languages",
        "released": 2018,
        "link": "https://doi.org/10.1145/3239372.3239387"
    },
    {
        "title": "Seahawk: Stack overflow in the IDE",
        "abstract": "Services, such as Stack Overflow, offer a web platform to programmers for discussing technical issues, in form of Question and Answers (Q&amp;A). Since Q&amp;A services store the discussions, the generated crowd knowledge can be accessed and consumed by a large audience for a long time. Nevertheless, Q&amp;A services are detached from the development environments used by programmers: Developers have to tap into this crowd knowledge through web browsers and cannot smoothly integrate it into their workflow. This situation hinders part of the benefits of Q&amp;A services. To better leverage the crowd knowledge of Q&amp;A services, we created Seahawk, an Eclipse plugin that supports an integrated and largely automated approach to assist programmers using Stack Overflow. Seahawk formulates queries automatically from the active context in the IDE, presents a ranked and interactive list of results, lets users import code samples in discussions through drag &amp; drop and link Stack Overflow discussions and source code persistently as a support for team work. Video Demo URL: http://youtu.be/DkqhiU9FYPI",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2486788.2486988"
    },
    {
        "title": "Implementing a massive open online course (MOOC)",
        "abstract": "Distance education is by no means new. Indeed, long before the Internet came along were universities making educational content available to students off campus via VHS, CD-ROM, and other media.But what is new is the scale on which universities and, in some cases, individual faculty are now operating. Massive open online courses (otherwise known as MOOCs) from non-profits like edX and for-profits like Coursera and Udacity have repeatedly drawn upwards of 100,000 registrants from all over the world. How to teach so many students effectively, though, is non-obvious. How to disseminate content to so many students, particularly large videos, is technically challenging (if not expensive). And how to collect, evaluate, and return work to so many students is a feat unto itself.Even so, we set out in Fall 2012 to tackle each of those challenges and more. We present in this tutorial how to implement (and how not to implement) a MOOC, based on lessons learned while designing and implementing CS50x: Harvard University’s Introduction to Computer Science I, edX’s largest fall course with 120,000 registered students. We present what we did, how we did it, why we did it, and what we would and wouldn’t do again so that others might build upon our own experience.In particular,• we present how to capture and encode content (e.g., faculty on video) using commodity hardware and open-source tools like FFmpeg;• we present how to choose among YouTube, iTunes U, Amazon Web Services, and the like for delivery of content;• we present CS50 Check, an open-source autograding framework that we developed for CS50x (with other courses in mind) that supports behavioral testing of programs written in any interpreted or compiled language;• we present CS50 Run, an open-source, web-based code editor that we developed for CS50x (with other courses in mind) that enables students to write, within a browser, code in any language, execution of which happens server-side;• and we present the pedagogy behind CS50x itself and the accompanying challenges of scale, among them logistics discussions among students, issues of academic dishonesty, and hidden costs in time.In addition, we explore in this tutorial the research potential that MOOCs’ scale offers, including opportunities for A/B testing and more.Ultimately, this tutorial’s attendees will exit with an understanding of the time, costs, opportunities, and challenges involved in offering a course on scale.",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2460156.2460182"
    },
    {
        "title": "A web-based environment for developing and utilizing teaching languages for novice computer science students (abstract only)",
        "abstract": "First year Computer Science students must face the dual challenge of learning to think algorithmically while simultaneously assimilating the complex and often unintuitive syntax of their first programming language. Mitigating this problem has been an active research area for decades, spawning a number of programming languages intended for students. While some such teaching languages have achieved a measure of popularity, both in the classroom and for general purpose programming, none has achieved ubiquity, which suggests there is no silver bullet. To this end, we present a suite of open source software including (1) a web-based toolkit for developing and modifying teaching languages using parsing expression grammars, (2) C Spot Run, a simple imperative teaching language built with the toolkit and informed by empirical research in intuitive syntax, and (3) a web-based development environment enabling the student to complete programming assignments directly from a web browser, eliminating complicated compiler installation and configuration. These artifacts are the first steps in an ongoing project intended to serve not only as a classroom tool, but also as a platform for the observational and experimental study of programming languages in classroom settings. By analyzing source code and metadata, common syntactic obstacles may be exposed and empirical studies of syntax can be verified in the classroom.",
        "keywords": "cs1; language design; open source; parsing expression grammars; peg; peg.js; teaching languages",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2850577"
    },
    {
        "title": "A common data manipulation language for nested data in heterogeneous environments",
        "abstract": "One key aspect of data-centric applications is the manipu- lation of persistent data repositories, which is moving fast from querying a centralized relational database to the ad- hoc combination of constellations of data sources. Query languages are being typefuly integrated in host, general purpose, languages in order to increase reasoning and optimizing capabilities of interpreters and compilers. However, not much is being done to integrate and orches- trate different and separate sources of data. We present a common data manipulation language, that abstracts the nature and localization of the data-sources. We define its semantics and a type directed compilation, query optimization, and query orchestration mechanism to be used in development tools for heterogeneous environments. We provide type safety and language integration. Our approach is also suitable for an interactive query construction environment by rich user interfaces that pro- vide immediate feedback on data manipulation operations. This approach is currently the base for the data layer of a development platform for mobile and web applications.",
        "keywords": "data query languages; distributed and heterogeneous queries; programming languages; type systems",
        "released": 2015,
        "link": "https://doi.org/10.1145/2815072.2815074"
    },
    {
        "title": "3rd international workshop on developing tools as plug-ins (TOPI 2013)",
        "abstract": "TOPI (http://se.inf.ethz.ch/events/topi2013/) is a workshop started in 2011 to address research questions involving plug-ins: software components designed and written to execute within an extensible platform. Most such software components are tools meant to be used within a development environment for constructing software. Other environments are middle-ware platforms and web browsers. Research on plug-ins encompasses the characteristics that differentiate them from other types of software, their interactions with each other, and the platforms they extend.",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2486788.2487081"
    },
    {
        "title": "Real-time collaborative scala development with clide",
        "abstract": "We present Clide, a real-time collaborative development environment. Clide offers a new approach to tool integration which complements the way resources are shifted to the cloud today. We achieve this by introducing the novel concept of universal collaboration, which drops the distinction between human and non-human participants (so-called assistants) and enables innovative ways of interaction.Clide has a highly flexible and distributed architecture based on Akka. Despite the complexity of the synchronisation of distributed document states, implementing assistants is pleasantly simple. To demonstrate the versatility and usability of the platform we implement a simple wrapper turning the Scala compiler into a collaborator, offering content assistance to other developers and tools.",
        "keywords": "computer-supported cooperative work; distributed programming environments; interactive programming environments; universal collaboration",
        "released": 2014,
        "link": "https://doi.org/10.1145/2637647.2637652"
    },
    {
        "title": "Performance evaluation of user-created open-web games",
        "abstract": "The rise of HTML5 and Web browsers’ execution performance has led to the emergence of several open-Web games developed by professional developers but not by end users. To create their games, end users require higher level development environments and domain-specific languages which impose execution performance overhead. This overhead becomes a critical factor in determining whether the Web can be used as a hosting platform for end-user programming of computer games. In this article we present the performance evaluation results of user-created games developed using AgentWeb, an open-Web game design environment for non-programmers. Our findings show that Web is a hospitable environment for executing games built using high-level game design environments.",
        "keywords": "HTML5; end-user programming; high-level languages; performance evaluation",
        "released": 2012,
        "link": "https://doi.org/10.1145/2245276.2245414"
    },
    {
        "title": "CodeBuddy (collaborative software development environment): In- and out-class practice for remote pair-programming with monitoring coding students’ progress",
        "abstract": "Pair-programming is an Agile technique in Extreme Programming (XP) where traditionally two programmers need to be collocated and work together at one workstation. Previous research has shown that pair-programming is very beneficial in software engineering education. However, learning and practicing pair-programming are mostly limited in a class where students can only learn to collaboratively program with another student in controlled or laboratory settings. Although nowadays there exist some collaborative tools, such as CodePilot, Google Colaboratory and Git, they are not specifically pair-programming-oriented. This impedes a pairing’s ability to discuss effective strategies in problem solving, to form productive or mutually learning pairs, and to predict pair compatibility. To encourage students in out-class practice of pair-programming, we present a demonstration of a novel web-based software development environment, called CodeBuddy, for remote pair-programming. CodeBuddy provides instructors and students with several features for managing laboratory classes and practicing pair-programming. Examples of CodeBuddy’s features include: coding screen mirroring between a pair, output terminal to show compiled results, face-to-face like communication channels (i.e., video calling and instant text messaging), automatic and manual role switching, code quality analysis for monitoring coding students’ progress and recommending a pair with targeted pairing goals, implicit code reviews using face detection for tracking a reviewer’s engagement, line-by-line code commenting, etc. The demonstration consists of a walkthrough of two use-case scenarios: an instructor assigns a problem-solving task and two students remotely work together in a pair using CodeBuddy on two different workstations to solve it.",
        "keywords": "agile software development; pair programming; remote collaboration and learning; software engineering",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3293750"
    },
    {
        "title": "Continuous social screencasting to facilitate software tool discovery",
        "abstract": "The wide variety of software development tools available today have a great potential to improve the way developers make software, but that potential goes unfulfilled when developers are not aware of useful tools. In this paper, I introduce the idea of emphcontinuous social screencasting, a novel mechanism to help developers gain awareness of relevant tools by enabling them to learn remotely and asychronously from their peers. The idea builds on the strength of several existing techniques that developers already use for discovering new tools, including screencasts and online social networks.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2337223.2337406"
    },
    {
        "title": "Test-driven roles for pair programming",
        "abstract": "The driver/navigator model of pair programming needs to be revised. We propose a model of programming in pairs where roles are based on test-driven development. Each programmer uses a different view of a shared development environment. One member of the pair writes tests, while the other implements the system. The programmers can cooperate as needed and move between different collaboration modalities. As part of a user-centered design process, we built a prototype web-based collaborative development environment for test-driven pair programming and ran a user study with professional software developers to evaluate the idea and identify research challenges. We used existing vocabularies and developed two novel visualizations to analyze the data, and found that the approach is feasible.",
        "keywords": "pair programming; test-driven development; visualizations",
        "released": 2010,
        "link": "https://doi.org/10.1145/1833310.1833313"
    },
    {
        "title": "Reflective debugging in spinoza V3.0",
        "abstract": "In this paper we present an online IDE (Spinoza 3.0) for teaching Python programming in which the students are (sometimes) required to verbally reflect on their error messages and unit test failures before being allowed to modify their code. This system was designed to be used in large synchronous in-person, remote, or hybrid classes for either in-class problem solving or out-of-class homework problems. For each student and problem, the system makes a random choice about whether to require reflection on all debugging steps. If the student/problem pair required reflection, then after each time the student ran the program and received feedback as an error message or a set of unit test results, they were required to type in a description of the bug and a plan for how to modify the program to eliminate the bug. The main result is that the number of debugging steps to reach a correct solution was statistically significantly less for problems where the students were required to reflect on each debugging step. We suggest that future developers of pedagogical IDEs consider adding features which require students to reflect frequently during the debugging process.",
        "keywords": "Spinoza; introductory programming classes; learning analytics; novice programmers; online IDE; reflective debugging",
        "released": 2021,
        "link": "https://doi.org/10.1145/3441636.3442313"
    },
    {
        "title": "Crowd-based programming for reactive systems",
        "abstract": "End-user applications aimed at the public in general (mobile and web applications, games, etc.) are usually developed with feedback from only a tiny fraction of the millions of intended users, and are thus built under significant uncertainty. The developer cannot really tell a priori which features the users will like, which they will dislike, and which ones will help create the desired outcome, such as high usage or increased revenue. In these cases, providing adaptive capabilities can be the key factor in the application’s success. Existing self-adaptive techniques can provide some of the needed capabilities, but they too must be planned, and leave the developers, and much of the development process, \"out of the loop\". We propose a development environment that allows the wisdom of the crowd to influence the very structure and flow of the program being created, by voting upon behavioral choices as they are observed in early versions of the working program. The approach still allows the developers to retain known desired behaviors, and to enforce constraints on crowd-driven changes. The developers can also react to ongoing crowd-programmed feedback throughout the entire lifetime of the application.",
        "keywords": "MDE; incremental development; reactive systems; scenario-based programming; software engineering",
        "released": 2017,
        "link": "https://doi.org/10.1109/CSI-SE.2017.3"
    },
    {
        "title": "Towards a taxonomy of errors in HTML and CSS",
        "abstract": "As part of a larger research agenda to explore web development as a context for learning computational literacy skills, we investigate errors people make while writing code in HTML and CSS. We report on a lab-based study in which 20 participants were video recorded as they completed coding tasks. We have applied the skills-rules-knowledge framework to segment this data by the cognitive causes of errors they made, and present a taxonomy of these errors. Our findings demonstrate how the skills-rules-framework can be used to analyze coding errors, provide insight about the origins of these errors, and suggest ways that the design of web development tools can be improved to support learning and practice with HTML and CSS.",
        "keywords": "computing education; errors; web development",
        "released": 2013,
        "link": "https://doi.org/10.1145/2493394.2493405"
    },
    {
        "title": "Flexible development of variable software features for mobile business applications",
        "abstract": "With recent advances in development and deployment of mobile business applications (MBAs) based on the hybrid Web approach (hybrid MBAs) enterprises around the world well recognize new potentials to mobilize their business processes (BPs). Variability has a natural appearance in complex environments of different enterprises, where even similar BPs can have varying facets on the cross-enterprise scale. Yet, despite this fact current development tools for hybrid MBAs are lacking systematic variability management. Further, the literature on this particular technological landscape is scarce. We highlight in this paper emerging importance of this research field and describe its context and a research methodology. We propose an SPL-based approach to tackle considerable variabilities of hybrid MBAs.",
        "keywords": "hybrid web; mobile business applications; software product lines; variability modeling",
        "released": 2013,
        "link": "https://doi.org/10.1145/2499777.2500712"
    },
    {
        "title": "Reverb: Recommending code-related web pages",
        "abstract": "The web is an important source of development-related resources, such as code examples, tutorials, and API documentation. Yet existing development environments are largely disconnected from these resources. In this work, we explore how to provide useful web page recommendations to developers by focusing on the problem of refinding web pages that a developer has previously used. We present the results of a study about developer browsing activity in which we found that 13.7",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2486788.2486895"
    },
    {
        "title": "Infusing visual programming and interactive learning to teach an introductory programming course with positive learning outcomes: (Abstract only)",
        "abstract": "A core challenge in introductory programming courses during the freshmen year is getting students to understand how a static textual representation (source code) maps to a highly dynamic process (program execution). Most students nowadays are visual learners who learn programming concept better through web-based visual and interactive learning instead of learning from traditional black board lecturing styles. This presentation will report our experience with positive learning outcomes in teaching an introductory programming course in Python by using a dynamic visual programming development environment based on flow-charts (RAPTOR) and active learning with an interactive eBook (zyBook). In this study, eleven sections of COSC 111 were included over three semesters as control and experimental groups. Analysis showed a marginally significant difference (F (1,5) = 5.87; p = 0.060) between sections taught via the traditional method and sections taught with the proposed pedagogical innovation. We also found that there are statistically significant positive correlations in between uses of the interactive book (eBook) and performances of students in tests. To add to our understanding of what students were experiencing, we also administered a survey to students at the end of the course. Regarding learning styles and tools, survey result showed that the eBook was helpful in understanding programming concepts (71.5",
        "keywords": "computational thinking; ebook; interactive learning; introductory programming; visual programming",
        "released": 2018,
        "link": "https://doi.org/10.1145/3159450.3162303"
    },
    {
        "title": "Graphics programming in elm develops math knowledge &amp; social cohesion",
        "abstract": "At McMaster University, we have developed a framework for teaching computer science, including curricula and tools (iPad apps: Image 2 Bits and ElmJr; an open-source library GraphicSVG; and a web-based development environment). ElmJr is a projectional editor for Elm, with knowledge of our graphics library. Using ElmJr, children transform programs through contextual menus. As a result, they never see syntax or type errors. Children as young as 10 years old, who have just started learning about syntax in English, can be productive programmers. We will explain how ElmJr is designed to make programming simple for beginners, and how strong typing in Elm and our graphics library is key to making the list of program transformations manageable. We will explain the design and findings of a study of children in 14 classes (grade 4 and 5) in the Hamilton-Wentworth District School Board, who received 12 hours of instruction over eight weeks in ElmJr with the aim of improving their mathematics knowledge. In parallel, another eight grade 6 to 8 classes received at least two hours of instruction in Elm using our web-IDE, culminating in a Wordathon. The Wordathon is designed to reconcile the power of social computing with the need to protect children’s privacy. The intermediate classes were challenged to create animations in Elm of assigned words identified by teachers as K-4 core reading vocabulary. Joining the intermediate students in this activity, two high school classes were taught how to create interactive applications in Elm and were challenged to create a reading game using the word animations created by the intermediate children. In all, four games incorporating 408 animations were created, and some of the intermediate students presented the games to primary grades in their schools. Unlike typical network effects, we get a multiplier effect: more word animations make game development more attractive, and more games make animations more attractive. Having a critical mass then attracts the attention of other educators, including in this case the team implementing the board-wide reading strategy. All of this can be accomplished without any identifying information leaving the classroom.",
        "keywords": "algebraic thinking; computational thinking; graphics programming; math education; projectional editor; social computing",
        "released": 2018,
        "link": "https://dl.acm.org/doi/10.5555/3291291.3291308"
    },
    {
        "title": "Yet another DSL for cross-platforms mobile development",
        "abstract": "With the growing success of mobility, mobile platforms (iOS, Android, WindowsPhone, etc.) multiply, each requiring specific development skills. Given this situation, it becomes very difficult for software developers to duplicate their apps accordingly. Meanwhile, web-based applications have evolved to be \"mobile-friendly\" but it appears that this is not a silver bullet: the user experience and the overall quality is still better with native applications. Of course, cross-platform mobile development tools have emerged in recent years. This paper provides a survey of these tools and points out that a full-fledged language for mobile development is highly desirable. Consequently, we present a preliminary work on Xmob, a technology-neutral DSL intended to be cross-compiled to produce native code for a variety of platforms.",
        "keywords": "DSL; MDA; cross-platform; mobile",
        "released": 2013,
        "link": "https://doi.org/10.1145/2489812.2489819"
    },
    {
        "title": "COMMA: A result-oriented composite autocompletion method for e-marketplaces",
        "abstract": "Autocompletion systems support users in the formulation of queries in different computer systems, from development environments to the web. In this paper we describe Composite Match Autocompletion (COMMA), a lightweight approach to the introduction of semantics in the realization of a semi-structured data auto completion matching algorithm. The approach is formally described, then it is applied and evaluated with specific reference to the e-commerce context. The semantic extension to the matching algorithm exploits available information about product categories and distinguishing features of products to enhance the elaboration of exploratory queries. COMMA supports a seamless management of both targeted/precise queries and exploratory/vague ones, combining different filtering and scoring techniques. The algorithm is evaluated with respect both to effectiveness and efficiency in a real-world scenario: the achieved improvement is significant and not associated to a sensible increase of computational costs.",
        "keywords": "autocompletion systems; semantic approaches",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2457524.2457644"
    },
    {
        "title": "An ADA reuse support system for windows 95/NT",
        "abstract": "This paper describes a software resource that is being developed as part of the graduation requirement for the Master in Software Engineering degree at the University of Scranton. This project evolved from a series of experiments that were performed in undergraduate and graduate courses at the University. A basic editor was developed as part of an undergraduate course in rapid prototyping. Several students used that project as the basis for undergraduate Senior Projects. All undergraduates are required to complete a project as a degree requirement. This basic editor was handed over to a graduate course in Software Generation and Maintenance and used as the starting point for the construction of various software project management features. The system was constructed to support Ada source code development. However, the system could be readily modified to support source code management in other languages, notably C++. This paper describes the construction of resources that encourage the use of reusable software. Subsequent sections describe the overall framework of the system and selected details that carry out features that make reuse attractive. The system is called ReUSE (the Reuse University of Scranton Environment).ReUSE is an Ada programming environment which facilitates and promotes code reuse by individual developers or teams of developers. It provides centralized storage of project files, a package browser, automatic function and procedure call creation, a compiler interface, interactive error processing, multiple simultaneous editors, standard windows tools (menus, toolbars, etc.), and other features to help the developer write and reuse Ada code efficiently.ReUSE was developed in Microsoft Visual Basic 4.0 (32-bit) for the Windows 95 / NT operating systems.",
        "keywords": "",
        "released": 1998,
        "link": "https://doi.org/10.1145/280495.280502"
    },
    {
        "title": "Supporting user-centric business processes with WADE",
        "abstract": "In this paper we present the latest developments of WADE (Workflows and Agents Development Environment) that provide concrete support for a better realization of the innovative paradigm of agent-based BPM (Business Process Management). We discuss the new functionality that WADE offers to enable the rapid and effective realization of user-centric business processes, i.e., business processes that are tightly integrated with the work of users and that are mainly driven by user interactions. Such processes are met frequently in practice and WADE seamlessly accommodates Web and Android users by means of dedicated views.",
        "keywords": "WADE; agent-based business process management; user-centric business processes",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2343896.2344047"
    },
    {
        "title": "GameSoup: A two-stage game development environment",
        "abstract": "Designing an end-user development environment seems to require making a trade-off between ease of use and expressiveness. GameSoup is an online game development platform that attempts to satisfy these two design requirements by splitting development into two distinct stages. One stage requires programming experience and is highly expressive; the other stage is very easy to use.",
        "keywords": "end-user development",
        "released": 2010,
        "link": "https://doi.org/10.1145/1920778.1920822"
    },
    {
        "title": "Towards a measurement framework for tools’ ceiling and threshold",
        "abstract": "Software development tools are not catching up with the requirements of increasingly complex interactive software products and services. Successful tools are claimed to either be low-threshold/low-ceiling or high-threshold/high-ceiling, however no research to date addressed how to define and measure these concepts. This is increasingly important as these tools undergo an evaluation and adoption process by end-users. Here we hypothesized that the evaluation and adoption of tools is associated with the threshold (learnability). To assess this we conducted a learnability and usability study using three commercial Platform-as-a-Service tools. In this study we used an augmented think-aloud protocol with question asking where ten subjects were asked to create a simple web application. Our data shows that most learnability issues fall into two categories: understanding or locating. No evidence was found that usability defects correlate with the tools learnability score. Though we found an inverse correlation between the amount of issues and the learnability score.",
        "keywords": "case tools; ceiling; learnability; paas; threshold",
        "released": 2014,
        "link": "https://doi.org/10.1145/2607023.2610269"
    },
    {
        "title": "TOPI ’11: Proceedings of the 1st workshop on developing tools as plug-ins",
        "abstract": "We would like to welcome you to this, the first workshop on Developing Tools as Plug-Ins (TOPI 2011). Tools and environments to increase software quality and productivity have always been an important aspect of software engineering. There are two major ways for programmers to communicate with the computer - programming languages and tools. Through languages, programmers encode decisions, actions and algorithms, while tools have the added advantage of providing analysis, synthesis and visualization.At the same time, software development environments have grown in power: today’s environments, such as Visual Studio, Eclipse or an Emacs configuration, bear little resemblance to those of two decades ago. Syntactic and documentation support, recommendations for fixes and re-factorings, relatively seamless integration with version control and debugging tools, and more, are not only available, but are expected by modern programmers. Plug-ins are the modern approach towards incrementally adding new tools into these rich environments. Proving for plug-ins is necessary because it is at best very hard to get programmers to try a new tool without integrating it into an existing environment.Indeed, our knowledge of how to solve software engineering problems is increasingly being encapsulated in tools. These tools are at their strongest when they operate in a pre-existing development environment. This approach allows integration with existing elements such as compilers, debuggers, profilers, visualizers as well as numerous other development and, often, runtime tools. However, building tools as plug-ins can be challenging. How do they interact with the core environment? How do they interact with one another - especially since each developer may choose a different set of plug-ins? How can we share tools across different, and future, core development environments? These are all questions that will be addressed during TOPI 2011.The workshop received 32 submissions from 21 countries. They attested to the interest in the topic and to the diversity of IDEs currently in use today, including Visual Studio 2010, Eclipse and MonoDevelop. Each paper was reviewed by three member of the PC, and then there followed a vigorous online meeting. From this, we selected 14 full papers and 8 short papers, giving an acceptance rate of 68",
        "keywords": "",
        "released": 2011,
        "link": "https://dl.acm.org/doi/10.1145/1984708"
    },
    {
        "title": "Early lessons from the development of SPOK, an end-user development environment for smart homes",
        "abstract": "This paper presents early lessons from the development of SPOK, an End-User Development Environment for smart homes. SPOK (Simple PrOgramming Kit) uses a pseudo-natural language as an end-user programming language and runs on top of an extension of OSGi/iPOJO to support the dynamic and resilient management of web services and devices from a variety of protocols including EnOcean, UPnP, and Watteco. The motivation for SPOK is to give the power back to end-users so that they can shape their own smart home at will. This paper reports lessons learned from the methods we have used to validate our hypotheses as well as a number of technical issues concerning development of this type of EUDE. A Video of SPOK in action as of October 2013 is accessible at: http://iihm.imag.fr/demos/appsgate/appsgate2013.mp4",
        "keywords": "ambient intelligence; end-user development; end-user programming; smart environment; smart home; ubiquitous computing",
        "released": 2014,
        "link": "https://doi.org/10.1145/2638728.2641559"
    },
    {
        "title": "Browsing and querying in online documentation: A study of user interfaces and the interaction process",
        "abstract": "A user interface study concerning the usage effectiveness of selected retrieval modes was conducted using an experimental text retrieval system, TeSS, giving access to online documentation of certain programming tools. Four modes of TeSS were compared: (1) browsing, (2) conventional boolean retrieval, (3) boolean retrieval based on Venn diagrams, and (4) these three combined. Further, the modes of TeSS were compared to the use of printed manuals. The subjects observed were 87 computing new to them. In the experiment the use of printed manuals is faster and provides answers of higher quality than any of the electronic modes. Therefore, claims about the effectiveness of computer-based text retrieval have to by vary in situations where printed manuals are manageable to the user. Among the modes of TeSS, browsing is the fastest and the one causing the fewest operational errors. On the same two variables, time and operational errors, the Venn diagram mode performs better than conventional boolean retrieval. The combined mode scores worst on the objective performance measures; nonetheless nearly all subject prefer this mode. Concerning the interaction process, the subjects tend to manage the complexities of the information retrieval tasks by issuing series of simple commands and exploiting the interactive capabilities of TeSS. To characterize the dynamics of the interaction process two concepts are introduced; threads and sequences of tactics. Threads in a query sequence describes the continuity during retrieval. Sequences of tactics concern the combined mode and describe how different retrieval modes succeed each other as the retrieval process evolves.",
        "keywords": "documentation; interaction process; online manuals; usage effectiveness",
        "released": 1996,
        "link": "https://doi.org/10.1145/230562.230570"
    },
    {
        "title": "Teaching CS1 with web applications and test-driven development",
        "abstract": "Teaching client/server web application development in CS1 can help increase student motivation without introducing a heavy curriculum footprint. This paper summarizes the author’s experience teaching CS1 for several years using a web application focus. The use of an appropriate web API, good development environment, and Test-Driven Development methodology helps ensure student success.",
        "keywords": "CS1; test-driven development; unit testing; web applications",
        "released": 2009,
        "link": "https://doi.org/10.1145/1595453.1595487"
    },
    {
        "title": "Cross-language support mechanisms significantly aid software development",
        "abstract": "Contemporary software systems combine many artifacts specified in various modeling and programming languages, domainspecific and general purpose as well. Since multi-language systems are so widespread, working on them calls for tools with cross-language support mechanisms such as (1) visualization, (2) static checking, (3) navigation, and (4) refactoring of cross-language relations. We investigate whether these four mechanisms indeed improve efficiency and quality of development of multi-language systems. We run a controlled experiment in which 22 participants perform typical software evolution tasks on the JTrac web application using a prototype tool implementing these mechanisms. The results speak clearly for integration of cross-language support mechanisms into software development tools, and justify research on automatic inference, manipulation and handling of cross-language relations.",
        "keywords": "",
        "released": 2012,
        "link": "https://doi.org/10.1007/978-3-642-33666-9_12"
    },
    {
        "title": "Towards tierless web development without tierless languages",
        "abstract": "Tierless programming languages enable developing the typical server, client and database tiers of a web application as a single mono-linguistic program. This development style is in stark contrast to the current practice which requires combining multiple technologies and programming languages. A myriad of tierless programming languages has already been proposed, often featuring a JavaScript-like syntax. Instead of introducing yet another, we advocate that it should be possible to develop tierless web applications in existing general-purpose languages. This not only reduces the complexity that developers are exposed to, but also precludes the need for new development tools. We concretize this novel approach to tierless programming by discussing requirements on its future instantiations. We explore the design space of the program analysis for determining and the program transformation for realizing the tier split respectively. The former corresponds to new adaptations of an old familiar, program slicing, for tier splitting. The latter includes several strategies for handling cross-tier function calls and data accesses. Using a prototype instantiation for JavaScript, we demonstrate the feasibility of our approach on an example web application. We conclude with a discussion of open questions and challenges for future research.",
        "keywords": "javascript; program slicing; tier splitting; tierless programming",
        "released": 2014,
        "link": "https://doi.org/10.1145/2661136.2661146"
    },
    {
        "title": "Developing visual interfaces for mobile devices",
        "abstract": "The popularity of mobile interfaces and application development is increasing along with the rapid expansion of the mobile electronics market and its migration from text-based applications to various multimedia applications. Real-time graphics and web applications are becoming one of the most attractive applications in mobile terminals due to their benefits for enterprise, gaming, and social media. This hands-on course will cover a comprehensive set of topics for developing mobile visual interfaces, including an overview of the mobile market, a comparison of mobile and desktop applications, and a survey of mobile development environments. We will also undertake a detailed discussion of UI development for mobiles, and graphics development for mobiles. During the course, various smartphones will be loaned to attendees for trying out several in-class exercises.",
        "keywords": "",
        "released": 2011,
        "link": "https://doi.org/10.1145/2077434.2077438"
    },
    {
        "title": "Node.fz: Fuzzing the server-side event-driven architecture",
        "abstract": "The importance of the Event-Driven Architecture (EDA) has never been greater. Web servers and the IoT alike have begun to adopt the EDA, and the popular server-side EDA framework, Node.js, boasts the world’s largest package ecosystem. While multi-threaded programming has been well studied in the literature, concurrency bug characteristics and useful development tools remain largely unexplored for server-side EDA-based applications.We present the first (to the best of our knowledge) concurrency bug characteristic study of real world open-source event-driven applications, based in Node.js. Like multithreaded programs, event-driven programs are prone to concurrency bugs like atomicity violations and order violations. Our study shows the forms that atomicity violations and ordering violations take in the EDA context, and points out the limitations of existing concurrency error detection tools developed for client-side EDA applications.Based on our bug study, we propose Node.fz, a novel testing aid for server-side event-driven programs. Node.fz is a schedule fuzzing test tool for event-driven programs, embodied for server-side Node.js programs. Node.fz randomly perturbs the execution of a Node.js program, allowing Node.js developers to explore a variety of possible schedules. Thanks to its low overhead, Node.fz enables a developer to explore a broader \"schedule space\" with the same test time budget, ensuring that applications will be stable in a wide variety of deployment conditions. We show that Node.fz can expose known bugs much more frequently than vanilla Node.js, and that it can uncover new bugs.",
        "keywords": "",
        "released": 2017,
        "link": "https://doi.org/10.1145/3064176.3064188"
    },
    {
        "title": "A comparative analysis of cross-platform development approaches for mobile applications",
        "abstract": "Nowadays, native mobile applications (mobile apps) are targeted at specific mobile platforms. This phenomenon imposes severe constraints, such as the use of different development environments, technologies, and APIs (Application Programming Interfaces) for each mobile platform, leading inevitably to a waste of development time and effort, and an increased maintenance cost.The paper focuses on the current trends in developing cross-platform mobile apps. Our analysis focuses primarily on three areas. In the first place, we clarify the cross-platform development landscape by exploring the most important cross-platform app types, which are web, hybrid, interpreted and generated apps. Secondly, key issues for each app type are presented and a comparative analysis is performed to highlight the advantages and disadvantages of each type. Thirdly, taking into account the current status in cross-platform mobile app development we identify a promising cross-platform app type and we investigate its effectiveness in practice. Finally, we draw some conclusions regarding cross-platform mobile app development approaches and make proposals for further research on the field.",
        "keywords": "HTML5; cross-platform development; generated app; hybrid app; interpreted app; mobile application; native app; smart mobile device; web app",
        "released": 2013,
        "link": "https://doi.org/10.1145/2490257.2490292"
    },
    {
        "title": "CLOUDs: Hype, problems and opportunities",
        "abstract": "The concept of CLOUD Computing has been a hot talking point for some years. However, there are as yet relatively few business applications running using CLOUDs although the use of CLOUDs for emailing, sharing office documents and social media is well-established. Cutting through the hype it is possible to classify kinds of CLOUD offerings and examine their advantages and disadvantages with respect to business requirements. These challenges and opportunities are technical, economic, legal and environmental. Two reports from expert groups convened by the European Commission under the chairmanship of the author document the state of the art, the opportunities and challenges. This leads to a roadmap for the widespread take-up and adoption of CLOUD computing. A key point of the roadmap is the provision of a systems development environment to allow flexible redeployment of applications across one or more CLOUD offerings. The PaaSage project – part-funded by the European Commission – addresses this opportunity.",
        "keywords": "",
        "released": 2013,
        "link": "https://doi.org/10.1145/2513534.2513537"
    },
    {
        "title": "A context-aware dialog model for multi-device web development",
        "abstract": "Model-Based User Interface Design (MBUID) consists of a step-wise method that structures the development of User Interfaces (UIs) based on models. According to this method, developers focus on creating a UI model, that is an abstract representation of it, and delegate the UI code generation process to automatic tools that take into account platform peculiarities. This paper explores the applicability of MBUI techniques to context-aware Service Front Ends (SFEs), i.e. UIs of web services that react to context changes. For this purpose, it introduces a context-aware dialog model that captures the adaptable behavior of a UI depending on variations of the context of use, a standard-based notation to represent it, and an open-source development environment that supports this development method.",
        "keywords": "connection-awareness; context-awareness; dialog; model-based design of user interface; navigation; scxml",
        "released": 2013,
        "link": "https://doi.org/10.1145/2494603.2480341"
    },
    {
        "title": "Greenbug: A hybrid web-inspector, debugger and design editor for greenstone",
        "abstract": "In this paper we present Greenbug: a hybrid web inspector, debugger and design editor developed for use with the open source digital library software Greenstone 3. Inspired by the web development tool Firebug, Greenbug is more tightly coupled with the underlying (digital library) server than that provided by Firebug; for example, Greenbug has a fine-grained knowledge of the connection between the underlying file system and the rendered web content, and also provides the ability to commit any changes made through the web interface back to the underlying file system. Moreover, because web page production in Greenstone 3 is the result of an XSLT processing pipeline, the necessarily well-formed hierarchical XML content can be manipulated into a graphical representation, which can then be manipulated directly through a visual interface supplied by Greenbug. We showcase the interface in use, provide a brief overview of implementation details, and conclude with a discussion on how the approach can be adapted to other XSLT transformation-based content management systems, such as DSpace.",
        "keywords": "",
        "released": 2013,
        "link": "https://doi.org/10.1145/2467696.2467788"
    },
    {
        "title": "Generating environments for programming-in-the-large",
        "abstract": "In order to provide better programming environments, language-based tools are introduced. These are tools which use knowledge of a programming language’s structure to provide special program development facilities. However, current software environment generators are geared towards generating environments which have language-based tools for programming-in-the-small only. They generate environments with language-based syntax-directed editors [1,2,3].Further improvements for programming environments could be achieved by extending the concept of providing language-based tools to include tools for programming-in-the-large [4]. To create a new environment, the designer supplies a declarative description for the target programming language objects and their interactions. The description of the programming language objects is given in a meta language based on the E-R model. The environment generator then processes and links this information together with a kernel supplied by the generator to produce a new environment. All the generated environments will have a uniform data model representing programs. A program is represented as a set of attributed entities which are linked together by a set of relations. The generated environments are a collection of integrated tools which are tailored according to the definition of the target programming language as well as tools which are standard for all environments (kernel) and do not depend on a language. Below is a brief description of these tools.Graphical Interface Manager: This tool represents the communication medium between the user and the environment. It interprets the user’s command and accordingly invokes the relevant system component which, in turn, will perform the operation requested by the user.System Manager: It contains a set of operations which allow the user to save, load, and initialize the objects of software system stored in the database. It also contains operations for executing the code generated from the information stored in the database.Entity editor: used to build and manipulate the architecture of a program. With this tool, software objects and their relationships can be added or deleted.Browser: It provides mechanisms to display information. The main feature of the Browser, is the support for displaying multiple views of a program through multiple windows. Each window is equipped with mechanisms to invoke all the tools in the environment.Information Viewer: Views are subsets of a software system graph. They contain a particular structural information. Information Viewer displays such information based on criteria set by the user.Database: It is a repository of all the information about software components and their interconnections.Parser: Extracts all entities and their relations which appear in a source code and stores them in the database.",
        "keywords": "",
        "released": 1988,
        "link": "https://doi.org/10.1145/322609.323172"
    },
    {
        "title": "Google’s go and dart: Parallelism and structured web development for better analytics and applications",
        "abstract": "Big Data – the new buzz word in the IT world – is synonymous with the concept of data-driven decision making. All across the industry, enterprises are collecting all sorts of data including client preferences, trends amongst social networks and information about competing businesses, at an unprecedented scale with the focus on making intelligent decisions. The decisions made from processing such data have a direct impact on both the businesses and its clients through higher profit margins and smarter services respectively. The combination of sophisticated analytics and data-driven decision making enables new types of solutions, from mining the human genome to deriving sentiments from social networks. This is all leveraged through consistent innovation of underlying technology, increased competition and cloud-based SaaS. Clouds are the frontiers for most business IT solutions as they idealize the \"as a service\" methodology, interoperability between services and correct billing metrics. Thus, it easily follows that most data analytic tools are designed to be run on cloud clusters rather than traditional data centres.In a world where there is an emergence of extensive use of analytics, data and fact-based decision making, spontaneous sorting of data becomes imperative. Industries like finance, pharmacy and others rely heavily on data to assess their strategies and customer requirements, and to respond quickly for the better. Hence, analytics are crucial for knowledge discovery, business growth and technological improvements. Every second, massive quantities of data are being generated and there is a need for data analytic tools that are easily integrated, scalable, and informative. While we are promisingly producing vast amounts of information, there is currently a wide gap between its potential and its realization. There are many problems with Big Data, including the heterogeneity of data, scale, readiness and complexity. The dynamic business environment requires a company to quickly adapt to newer technologies that can provide better solutions. A high throughput of services translates into improved business efficiency. It is often the case that an innocent shift in development tools can catapult a paradigm altering change. In this workshop, we discussed two emerging technologies recently launched by Google – Go and Dart; which through their advents in scalability, improved parallelism, and structured web development greatly enhanced the capacity and quality of building applications designed to work from handheld mobile devices, to data crunching frameworks such as Google’s Map Reduce, IBM’s Big Insights and others.The initiative behind Go is to create a language that allows programmers to exploit concurrency in programs by providing simple yet powerful features built into the language that do not require complex code and high maintenance. With the introduction of GPGPU’s for execution, it is essential to have concurrency dependent applications in order to improve their performance. Go provides simplicity and improvement in leveraging processing power while providing simplified features of traditional programming languages. Not following the traditional object oriented programming model, Go was initially targeted for system programming including applications for distributed systems, storage infrastructure, networking infrastructure and the RPC layer, however, its features make it an excellent language deploying application on concurrent systems. Go has higher throughput, as compared to Java or Python because of its dynamic stack- and core- focused features for speed and concurrency. Being a hybrid between C and Python, Go is type-safe and memory-safe, has fast start-ups, latency-free garbage collection, and high-speed compilation. Businesses gain the advantage of availability of services by using a language that is designed to be concurrent. Go’s \"lightweight concurrency\" allows developers to create sets of lightweight communicating processes called goroutines. The programmer doesn’t need to worry about synchronization, locking mechanisms such as semaphores and race conditions. This affects the cost of back-end and front-end instances which allows tiers to deliver more responses per instance.Moreover, Go uses significantly less memory as compared to Java which is JVM dependent. Go is predominantly used because of its easy integration with frameworks like Map Reduce. Go provides static typing and makes unit testing much easier to the languages like Java and C. Go is designed specifically to provide easy integration with Google App Engine and Google Compute Engine. Finally, Go compiles static binaries with no dependencies, so Go programs can simply be dropped onto a server and deployed.Today, the web is everywhere – from handheld mobile devices to television sets to traditional desktops. It is very easy to write a web page that is universally accessible on any device via a browser. There are no installation or update procedures, making the user experience very pleasant. JavaScript is now supported by almost every browser because of its convenient functionality. However, alongside the beauty of JavaScript is its unpleasantness in debugging, performance across browsers, and security on client devices. Dart is a new web programming language and methodology in development by Google for creating structured web applications. It is developed with the aim to encompass aspects such as simplicity, efficiency, and scalability while combining new language features with familiar language constructs into a clear, fluent syntax. The fundamental reason for its creation is to ultimately replace JavaScript because of its unstructured and inconvenient development paradigm. Dart aims to tackle these issues by providing lexical scoping, closures, and optional static typing; not to mention integrated development and debugging are also provided in the Dart Editor and SDK, which supports major common interactions such as refactoring, breakpoints, code completion, code navigation and much more. In addition, the SDK provides a standalone virtual machine, package manager, and Chromium with an embedded Dart VM. Dart can also be compiled to JavaScript, which makes it usable on all modern desktop and mobile browsers with an additional plus of being able to run on a server in a stand-alone Dart VM. Fundamentally aiming to create structure and flexibility for the web, focusing on supporting a full range of devices — including phones, tablets, laptops, and servers, and providing environmental and supportive tools to run efficiently across all major modern browsers, Go and Dart are developed specifically for a simplification of the coding paradigm and better integration with existing technology. Both Go and Dart aim to improve the modern day programming model and unstructured web source code.This full-day workshop focused on the core technologies of Go and Dart, including building and deploying applications integrated with analytic frameworks on cloud clusters. The workshop was split into three segments. In the first segment, the objective was to take a hands on approach to walk through the features of Go and Dart. The participants wrote code themselves and explored both the languages on a first hand basis. We introduced the languages and discussed their basic constructs and some advanced features.In the second half, we examined an in depth example of creating a web application using Go, Dart, Map Reduce, and Google App Engine. The goal was to demonstrate Go’s simplicity, power of concurrency, and structured web development and integration with existing API’s. In the last segment, we concluded with a discussion about the impact Go and Dart can have on different parts of the IT industry. As the shift to development for cross mobile platform web applications increases - we expose the usefulness of using Dart instead of JavaScript for building mobile web applications with frameworks like Apache Cordova and IBM Worklight. Furthermore, we discussed questions like how these languages are being used in the real world today; the learning curve, cost and complexity behind the languages; the value of the products that are produced by using such programming tools.There are many subtle challenges and opportunities associated with Big Data, which require restructuring the data management platforms to better suit the needs of businesses. When making a shift to newer technologies, there are always doubts and expectations. Hence, it is beneficial to look into the integration of emerging technologies with existing systems for the constant improvement.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2399776.2399809"
    },
    {
        "title": "Multi-tenancy cloud access and preservation: Virginia tech digital libraries platform",
        "abstract": "Virginia Tech Libraries has developed a cloud-native, microservervices-based digital libraries platform to consolidate diverse access and preservation infrastructure into a set of flexible, independent microservices in Amazon Web Services. We have been an implementer and contributor to various community digital library and repository projects including DSpace, Fedora, and Samvera3. However, the complexity and cost of maintaining disparate application stacks have reduced our capacity to build new infrastructure. Virginia Tech has a long history of participation in and contribution to community-driven Open Source projects and has, in that time, developed more than a dozen independent applications architected on these stacks. The cost of independently addressing vulnerabilities, which often requires work to mitigate incompatibilities; reworking each application to comply with developing branding guidelines; and feature development and improvement has burgeoned, threatening to overwhelm our capacity. Like many of our peers5, our maintenance obligations have made continued growth unsustainable and have pushed older applications to near abandonware. We have designed and developed the Digital Libraries Platform to address these concerns thus reducing our maintenance obligations and costs associated with feature development across digital libraries. This approach represents a departure from the monolithic architectures of our legacy systems and, as such, shares more infrastructure among individual digital library implementations. The shared infrastructure facilitates rapid inclusion of new and improved features into each digital library instance. New features can be developed independent of any digital library instance and integrated into that instance by inclusion of that feature in the React/Amplify template. Changes to the template super class, such as those necessitated by evolving branding guidelines, may be immediately inherited by the template instances that subscribe to it. The platform implements Terraform6 deployment templates, Lambda serverless functions, and other cloud assets to form a microservices architecture on which multiple template-based sites are built. Individual sites are configured in AWS DynamoDB, Amazon’s NoSQL database service, and via modification of shared template. Additional services provide digital preservation support including auditing, file fixity validation, replication to external cloud storage providers, file format characterization, and deposit to third-party preservation services. This presentation also discusses the cost of operating these services in AWS and strategies for mitigating those costs. These strategies include containerization to allow deployment of high-cost, asynchronous services to local infrastructure to take full advantage of existing infrastructure and advantageous utility pricing while allowing for local redeployment. In the past, developers worked in local, independent environments. New features and fixes were submitted to a central development environment testing and validation, which significantly slowed development. Migrating development, review, integration, and deployment processes to AWS decreased the time and resource bottlenecks for those processes. Our AWS cost accounting demonstrates an 87",
        "keywords": "cloud computing; digital libraries; digital preservation; microservice",
        "released": 2020,
        "link": "https://doi.org/10.1145/3383583.3398624"
    },
    {
        "title": "Developing microlabs using google web toolkit",
        "abstract": "Closed labs have become a common feature in computer science education because they provide hands-on experience in a supervised setting. Microlabs extend this approach into the lecture format with very short hands-on activities in the \"middle of the lecture.\" The programming microlab approach was developed for a distributed computing course that integrated all levels of parallelism (multicore, cluster, and grid). Since that time we have developed logical microlabs where students solve conceptual problems that do not involve programming. These are integrated into a Microlab Learning Cycle. We want our microlabs to be usable with a wide variety of computing devices, including tablets. After experimenting with different development environments we have adopted the Google Web Toolkit (GWT). After presenting the current status of our activities, we discuss future directions for microlab development. This work is supported, in part, by three National Science Foundation grants.",
        "keywords": "active learning; automated grading; web development",
        "released": 2012,
        "link": "https://doi.org/10.1145/2157136.2157311"
    },
    {
        "title": "Socially mediated technology awareness",
        "abstract": "New technology can reduce a developer’s work. Yet, given how fast technology changes, it is close to impossible for a developer to stay aware of technological advances that might ease his work. In this paper, we propose an approach that increases the likelihood of a developer becoming aware of technology that might help him. Our approach uses a developer’s interaction with the development environment to characterize a profile of the developer’s use. This profile can then be used to find relevant posts on social news web sites. We use the votes on the social web sites as a means to filter and rank relevant information for the developer.",
        "keywords": "context; human-centric; serendipity; social news web site; technology awareness",
        "released": 2011,
        "link": "https://doi.org/10.1145/2024645.2024655"
    },
    {
        "title": "Web based multi-platform benchmark program construction in smartphone",
        "abstract": "A benchmark program provides objective and quantitative experimental data that is used in HW architecture design and as performance criteria. For that reason, a benchmark point must be fairly calculated to make a right decision. It is difficult to benchmark with fairness in embedded systems such as smartphones since there are many HW and SW development environments. For example, iOS adopts ObjectC language and Android supports Java and C/C++ to develop applications. Therefore, it is impossible to apply the same native workload without modification to both iOS and Android platforms. Web-based benchmark programs can solve the problem of fairness. If a platform supports a browsing system, then we can run the same web benchmark program on that platform. In this paper, we construct a web-based benchmark program with JavaScript and HTML5 to evaluate an entire HW platform. The JavaScript workload has three components and the HTML5 workload has two components. Experiment shows that similar runtime characteristics are maintained between native and web workloads. Moreover, we use a compared ratio method to relieve result distortion that comes from unexpected system overheads. Finally, we run our benchmark program on the iOS and many Android platforms.",
        "keywords": "benchmark program; smartphone; web application",
        "released": 2013,
        "link": "https://doi.org/10.1145/2448556.2448625"
    },
    {
        "title": "Smalltalk debug lives in the matrix",
        "abstract": "Agile programming aware computer scientists know how much productivity they owe to their development environments, and more precisely to advanced debuggers. Indeed, debuggers are mandatory to support an optimistic do-fix-rerun approach.This development scheme does not make sense in hardware design where agile has a different meaning; it refers to reconfigurable architectures. Despite such architectures support tailoring and refactoring application circuits and promote short development cycles, the overall programing scheme still conforms to waterfall models and component based integration.This paper presents a path to offer probe-based development to hardware designers, and introduces our Red Pill environment that merges several abstraction levels ranging from C like parallel coding to hardware realization embedding debug facility. Red Pill is developed using VisualWorks and reproduces some of Cincom Smalltalk browser well known features that traditionally lack when validating circuits.",
        "keywords": "agile programming; debugging; modeling; morpheus; reconfigurable computing; software engineering; system-on-chip; testing methodology",
        "released": 2010,
        "link": "https://doi.org/10.1145/1942790.1942792"
    },
    {
        "title": "WebCrystal: Understanding and reusing examples in web authoring",
        "abstract": "Examples have been widely used in the area of web design to help web authors create web pages. However, without actually understanding how an example is constructed, people often have trouble extracting the elements they want and incorporating them into their own design. This paper introduces WebCrystal, a web development tool that helps users understand how a web page is built. WebCrystal contributes novel interaction techniques that let the user quickly access HTML and CSS information by selecting questions regarding how a selected element is designed. It provides answers using a textual description and a customized code snippet that can be copied-and-pasted to recreate the desired properties. WebCrystal also supports combining the styles and structures from multiple elements into the generated code snippet, and provides visualizations on the web page itself to explain layout relationships. Our user study shows that WebCrystal helped both novice and experienced developers complete more tasks successfully using significantly less time.",
        "keywords": "examples; web authoring",
        "released": 2012,
        "link": "https://doi.org/10.1145/2207676.2208740"
    },
    {
        "title": "Workshops of CASCON 2008",
        "abstract": "CASCON workshops provide a forum to present, discuss, and debate issues, problems, ideas, emerging technologies, work-in-progress, or directions on topics such as software best practices, software engineering, distributed and Web-based systems, data management, software development tools, electronic commerce, and user experience. Interdisciplinary workshops are particularly encouraged. The workshop format may include position papers, expert panels, hands-on exercises, and discussions.In 2008 there were 37 workshops over the course of four days.",
        "keywords": "",
        "released": 2008,
        "link": "https://doi.org/10.1145/1463788.1463821"
    },
    {
        "title": "A holistic architecture for the internet of things, sensing services and big data",
        "abstract": "Wireless Sensor Networks (WSNs) increasingly enable applications and services to interact with the physical world. Such services may be located across the Internet from the sensing network. Cloud services and big data approaches may be used to store and analyse this data to improve scalability and availability, which will be required for the billions of devices envisaged in the Internet of Things (IoT). The potential of WSNs is limited by the relatively low number deployed and the difficulties imposed by their heterogeneous nature and limited (or proprietary) development environments and interfaces. This paper proposes a set of requirements for achieving a pervasive, integrated information system of WSNs and associated services. It also presents an architecture which is termed holistic as it considers the flow of the data from sensors through to services. The architecture provides a set of abstractions for the different types of sensors and services. It has been designed for implementation on a resource constrained node and to be extensible to server environments. This paper presents a ’C’ implementation of the core architecture, including services on Linux and Contiki (using the Constrained Application Protocol (CoAP)) and a Linux service to integrate with the Hadoop HBase datastore.",
        "keywords": "big data; cloud computing; information model; protocols; tuple space; wireless sensor networks",
        "released": 2013,
        "link": "https://doi.org/10.1109/CCGrid.2013.100"
    },
    {
        "title": "Open source-style collaborative development practices in commercial projects using GitHub",
        "abstract": "Researchers are currently drawn to study projects hosted on GitHub due to its popularity, ease of obtaining data, and its distinctive built-in social features. GitHub has been found to create a transparent development environment, which together with a pull request-based workflow, provides a lightweight mechanism for committing, reviewing and managing code changes. These features impact how GitHub is used and the benefits it provides to teams’ development and collaboration. While most of the evidence we have is from GitHub’s use in open source software (oss) projects, GitHub is also used in an increasing number of commercial projects. It is unknown how GitHub supports these projects given that GitHub’s workflow model does not intuitively fit the commercial development way of working. In this paper, we report findings from an online survey and interviews with GitHub users on how GitHub is used for collaboration in commercial projects. We found that many commercial projects adopted practices that are more typical of oss projects including reduced communication, more independent work, and self-organization. We discuss how GitHub’s transparency and popular workflow can promote open collaboration, allowing organizations to increase code reuse and promote knowledge sharing across their teams.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2818754.2818825"
    },
    {
        "title": "ResEval mash: A mashup tool that speaks the language of the user",
        "abstract": "End-user development (i.e., enabling end-users without programming skills to build their own applications) is undergoing a revolution, as mashups are widely considered to be the most appealing development tool for the situational, short-span applications. Plain technology (e.g., SOAP/WSDL web services) or simple modeling languages (e.g., Yahoo! Pipes) don’t convey enough meaning to non-programmers. In this paper, we propose a domain-specific approach to mashups that speaks the language of the user\", i.e., that is aware of the terminology, concepts, rules, and conventions (the domain) the user is comfortable with. We exemplify the approach by implementing a mashup tool for a specific domain (research evaluation) and describe the respective user study. The results of a first user study confirm that domain-specific mashup tools indeed lower the entry barrier to mashup development.",
        "keywords": "domain-specific mashups; end-user development; research evaluation",
        "released": 2012,
        "link": "https://doi.org/10.1145/2212776.2223734"
    },
    {
        "title": "End-user creation of social apps by utilizing web-based social components and visual app composition",
        "abstract": "This paper presents a social component framework for the SatinII App Development Environment. The environment provides a systematic way of designing, developing and deploying personalized apps and enables end-users to develop their own apps without requiring prior knowledge of programming. A wide range of social components based on the framework have been deployed in the SatinII Editor, including components that utilize aggregated social graphs to automatically create groups or recommending/filtering information. The resulting social apps are web-based and target primarily mobile clients such as smartphones. The paper also presents a classification of social components and provides an initial user-evaluation with a small group of users. Initial results indicate that social apps can be built and deployed by end-users within 17 minutes on average after 20 to 30 minutes of being introduced to the SatinII Editor.",
        "keywords": "component-based social app development; mobile social app; social data; tools for social app development",
        "released": 2013,
        "link": "https://doi.org/10.1145/2487788.2488150"
    },
    {
        "title": "Development and application of online tourism english teaching platform",
        "abstract": "In the age of Internet+, the integration of information technology and vocational English course teaching is bound to bring about the reformation of ESP teaching. On the basis of introducing the main idea of \"flipped classroom\" teaching model reform in tourism English course, this paper mainly discusses the development and application of online tourism English teaching platform including the designing goals, framework, modules, and database design of the platform. It has been found that the tourism English teaching platform designed in this paper can offer effective learning scaffolding to college students majoring in tourism and tourism practitioners, meeting their needs of learning and practicing at anytime and anywhere. At the same time, teachers can handle the learning progress and quality of students so as to realize the \"flipped classroom\" teaching model of tourism English course.Under the background of the development of digital technology, CG (Compute Graphics) digital painting is an artistic form of expression that closely combines painting art with digital technology. CG painting digitally transforms two-dimensional or three-dimensional graphics into digital graphics by means of mathematical algorithms. Painting works can be widely used in animation, film and television, games, visual communication design and other fields. The main purpose of the design and development of teaching system is to construct a teaching support system that can meet the requirements. This research takes Python as the development environment, adopts the four-tier software framework of object-oriented program design, including application-level knowledge point modeling, communication-level curriculum application management, resource-level management design, user-level UI design and other modules.The core issues to be solved include the establishment of teaching environment, the presentation and editing of knowledge point framework modeling, the establishment of pre-basic skills and learning objectives, and then the establishment of the teaching department. The application of the system has been tentatively studied. Finally, five indicators, including student experience, learning process satisfaction, teaching effect evaluation, teaching time-consuming comparison and teaching effect, are selected to verify the effectiveness of teaching supported by the experimental teaching system of CG digital painting course. The experimental results show the superiority of the experimental teaching system proposed in this paper.",
        "keywords": "\"Flipped classroom\" teaching model; The development of online teaching platform; Tourism English",
        "released": 2019,
        "link": "https://doi.org/10.1145/3352740.3352755"
    },
    {
        "title": "An application for creating full-scale augmented reality content without 3d modeling skills",
        "abstract": "The purpose of this project is the development of a software application that enables the user to create full-scale augmented reality (AR) content without the need for specialized 3D modeling skills or software. Research has shown that of the numerous previously developed AR content development environments and applications, all requires 3D modeling skills. The experimental system described in this paper allows the creation of full-scale AR content (a rectangular parallelepiped) using captured images via a Web-based application. Twenty-two out of twenty-four individuals who tested the system were able to successfully create AR content. The author concludes that the system is am important step toward the development of a user-friendly tool for the creation of full-scale AR content. This will add a new dimention of the images on the Internet: a real life impression of size and shape.",
        "keywords": "augmented reality; communication design; full-scale; mixed reality; multi-platform",
        "released": 2011,
        "link": "https://doi.org/10.1145/2030031.2030039"
    },
    {
        "title": "The web page as a WYSIWYG end-user customizable database-backed information management application",
        "abstract": "Dido is an application (and application development environment) in a web page. It is a single web page containing rich structured data, an AJAXy interactive visualizer/editor for that data, and a \"metaeditor\" for WYSIWYG editing of the visualizer/editor. Historically, users have been limited to the data schemas, visualizations, and interactions offered by a small number of heavyweight applications. In contrast, Dido encourages and enables the end user to edit (not code) in his or her web browser a distinct ephemeral interaction \"wrapper\" for each data collection that is specifically suited to its intended use. Dido’s active document metaphor has been explored before but we show how, given today’s web infrastructure, it can be deployed in a small self-contained HTML document without touching a web client or server.",
        "keywords": "databases; end user programming; wysiwyg",
        "released": 2009,
        "link": "https://doi.org/10.1145/1622176.1622223"
    },
    {
        "title": "An empirical study of code search in intelligent coding assistant: Perceptions, expectations, and directions",
        "abstract": "Code search plays an important role in enhancing the productivity of software developers. Throughout the years, numerous code search tools have been developed and widely utilized. Many researchers have conducted empirical studies to understand the practical challenges in using web search engines, like Google and Koders, for code search. To understand the latest industrial practice, we conducted a comprehensive empirical investigation into the code search capability of TONGYI Lingma (short for Lingma), an IDE-based coding assistant recently developed by Alibaba Cloud and available to users worldwide. The investigation involved 146,893 code search events from 24,543 users who consented for recording. The quantitative analysis revealed that developers occasionally perform code search as needed, an effective tool should consistently deliver useful results in practice. To gain deeper insights into developers’ perceptions and expectations, we surveyed 53 users and interviewed 7 respondents in person. This study yielded many significant findings, such as developers’ expectations for a smarter code search tool capable of understanding their search intents within the local programming context in IDE. Based on the findings, we suggest practical directions for code search researchers and practitioners.",
        "keywords": "Code Search; Coding Assistant; Empirical Study",
        "released": 2024,
        "link": "https://doi.org/10.1145/3663529.3663848"
    },
    {
        "title": "Simplifying the development of cross-platform web user interfaces by collaborative model-based design",
        "abstract": "Ensuring responsive design of web applications requires their user interfaces to be able to adapt according to different contexts of use, which subsume the end users, the devices and platforms used to carry out the interactive tasks, and also the environment in which they occur. To address the challenges posed by responsive design, aiming to simplify their development by factoring out the common parts from the specific ones, this paper presents Quill, a web-based development environment that enables various stakeholders of a web application to collaboratively adopt a model-based design of the user interface for cross-platform deployment. The paper establishes a series of requirements for collaborative model-based design of cross-platform web user interfaces motivated by the literature, observational and situational design. It then elaborates on potential solutions that satisfy these requirements and explains the solution selected for Quill. A user survey has been conducted to determine how stakeholders appreciate model-based design user interface and how they estimate the importance of the requirements that lead to Quill.",
        "keywords": "collaborative development; cross-platform design; model-based design of user interfaces; user interface description language",
        "released": 2013,
        "link": "https://doi.org/10.1145/2507065.2507067"
    },
    {
        "title": "An authoring environment for model-driven web applications",
        "abstract": "This paper presents a development environment and framework that supports a Model Driven Development approach to Web Application Development. In this framework, the models are described through graphical diagrams that are processed by the environment. The main purpose is to ease the development of a web application using Visual Studio .Net 2005 as an IDE and Semantic Hypermedia Development Method (SHDM) as development method, allowing the application architect to focus on the application modeling. We also discuss how the meta-modeling facilities of VS .Net 2005 were extensively used.",
        "keywords": "DSL; OOHDM; SHDM; model-driven development",
        "released": 2006,
        "link": "https://doi.org/10.1145/1186595.1186598"
    },
    {
        "title": "Towards the reuse of lingware systems: A proposed approach with a practical experiment",
        "abstract": "We are going to present in this document a generic approach for lingware systems reuse. This approach is based on reverse engineering technique in order to wrap up an existing lingware system with web services. This approach permits the reuse of lingware systems regardless of programming languages, development environments and the structures of linguistic resources. In order to preserve the interoperability between the reused lingware systems, the proposed approach performs the unification and the standardization of exchanged linguistic data using the Natural Language Processing (NLP) standards and consensus. Doing so, we facilitate the integration and the composition of lingware services in order to create a new application that treats several linguistic levels. In order to consolidate the given approach, we developed the LIngware Reuse Environment (LIRE). A practical experiment was carried out using LIRE environment on an automatic application summary of Arabic texts.",
        "keywords": "input/output standardization; lingware system reuse; reverse engineering; software; web service composition",
        "released": 2010,
        "link": "https://doi.org/10.1145/1967486.1967573"
    },
    {
        "title": "Deploying an online software engineering education program in a globally distributed organization",
        "abstract": "A well-trained software engineering workforce is a key to success in a highly competitive environment. Changing tools and technologies, along with a rapidly changing development environment, make it incumbent on organizations to invest in training. In this paper, we describe our experience in deploying an online training program in a globally distributed organization. We write about the reasons behind ABB’s Software Development Improvement Program (SDIP), the requirements we established upfront, the people, processes and technologies we used, the promotion of SDIP, and metrics for measuring success. Finally, we share and describe results and lessons learned that could be applied to many organizations with similar issues. The goal of this paper is to provide a set of replicable best practices for initiating a software training program in a multi-national organization. The first SDIP online course was offered in June 2012. Since then, we have had more than 10,000 enrollments from employees in 54 countries. Today, our training library contains 89 e-learning, 17 webinar, video and virtual lab courses, and we have delivered more than 180 hosted webinars. Following each class, we ask students to evaluate the class. Ninety-eight percent are satisfied with the classes.",
        "keywords": "Training in distributed organizations; e-learnings; virtual labs; web-based training platform; webinars",
        "released": 2014,
        "link": "https://doi.org/10.1145/2591062.2591165"
    },
    {
        "title": "Proposal for a sensor network application development with ActionScript",
        "abstract": "In recent years, the research of sensor networks has advanced. They are anticipated for use in a wide variety of fields such as traceability systems of products, environmental morning, health care, etc. However, developers must develop applications to work in a sensor node and applications to make the sensor data visible. Therefore the knowledge that is necessary for development and the acquisition of the language will take time to develop. As described in this paper, we propose a development environment for sensor network application development. The environgment will be useful even by web programmers and a designers.",
        "keywords": "",
        "released": 2010,
        "link": "https://doi.org/10.1145/1869983.1870018"
    },
    {
        "title": "When it comes to e-learning",
        "abstract": "E-learning is fast becoming a major learning and skills delivery method within larger companies as a staff development tool. Survey shows that among American colleges and universities in 2002, 11",
        "keywords": "",
        "released": 2007,
        "link": "https://doi.org/10.1145/1322464.1322465"
    },
    {
        "title": "Putting in all the stops: Execution control for JavaScript",
        "abstract": "Scores of compilers produce JavaScript, enabling programmers to use many languages on the Web, reuse existing code, and even use Web IDEs. Unfortunately, most compilers inherit the browser’s compromised execution model, so long-running programs freeze the browser tab, infinite loops crash IDEs, and so on. The few compilers that avoid these problems suffer poor performance and are difficult to engineer. This paper presents Stopify, a source-to-source compiler that extends JavaScript with debugging abstractions and blocking operations, and easily integrates with existing compilers. We apply Stopify to ten programming languages and develop a Web IDE that supports stopping, single-stepping, breakpointing, and long-running computations. For nine languages, Stopify requires no or trivial compiler changes. For eight, our IDE is the first that provides these features. Two of our subject languages have compilers with similar features. Stopify’s performance is competitive with these compilers and it makes them dramatically simpler. Stopify’s abstractions rely on first-class continuations, which it provides by compiling JavaScript to JavaScript. We also identify sub-languages of JavaScript that compilers implicitly use, and exploit these to improve performance. Finally, Stopify needs to repeatedly interrupt and resume program execution. We use a sampling-based technique to estimate program speed that outperforms other systems.",
        "keywords": "IDEs; JavaScript; continuations",
        "released": 2018,
        "link": "https://doi.org/10.1145/3192366.3192370"
    },
    {
        "title": "Workshops of CASCON 2007",
        "abstract": "CASCON workshops provide a forum to present, discuss, and debate issues, problems, ideas, emerging technologies, work-in-progress, or directions on topics such as software best practices, software engineering, distributed and Web-based systems, data management, software development tools, electronic commerce, and user experience. Interdisciplinary workshops are particularly encouraged. The workshop format may include position papers, expert panels, hands-on exercises, and discussions.In 2007 there were 43 workshops over the course of four days.",
        "keywords": "",
        "released": 2007,
        "link": "https://doi.org/10.1145/1321211.1321260"
    },
    {
        "title": "COCA: Computation offload to clouds using AOP",
        "abstract": "In this paper, we describe COCA – Computation Offload to Clouds using AOP (aspect-oriented programming). COCA is a programming framework that allows smart phones application developers to offload part of the computation to servers in the cloud easily. COCA works at the source level. By harnessing the power of AOP, name inserts appropriate offloading code into the source code of the target application based on the result of static and dynamic profiling. As a proof of concept, we integrate name into the Android development environment and fully automate the new build process, making application programming and software maintenance easier. With COCA, mobile applications can now automatically offload part of the computation to the cloud, achieving better performance and longer battery life. Smart phones such as iPhone and Android phones can now easily leverage the immense computing power of the cloud to achieve tasks that were considered difficult before, such as having a more complicated artificial-intelligence engine.",
        "keywords": "Android operating system; aspect oriented programming; computation offload",
        "released": 2012,
        "link": "https://doi.org/10.1109/CCGrid.2012.98"
    },
    {
        "title": "Developing client-side mashups: Experiences, guidelines and the road ahead",
        "abstract": "Software mashups that combine content from multiple web sites to an integrated experience are a popular trend. However, methods and tools for creating mashups are still rather undeveloped, and there is little engineering support behind them. In this paper we provide insight into mashup development based on our practical experiences in implementing various sample mashup applications and tools for creating them. Unlike most commonly used mashup development tools, which are rather server-centric, we focus primarily on client-side mashup development. We have grouped our experiences into guidelines that can serve as a helpful starting point for the design of new mashups. The long-term goal of our work is to facilitate the development of robust, secure and compelling mashup applications, and more generally ease the transition towards web-based software development.",
        "keywords": "mashup development; mashups; web applications; web engineering; web-based software development",
        "released": 2010,
        "link": "https://doi.org/10.1145/1930488.1930523"
    },
    {
        "title": "Towards a monitoring feedback loop for cloud applications",
        "abstract": "Performance monitoring is fundamental to track cloud application health and service-level agreement compliance, but with the emergence of multi-cloud deployments, it may become increasingly important also to create a feedback loop between runtime operation in multi-clouds and design-time reasoning. This is because the developer needs to acquire more information on the specific performance features of a cloud platform to better leverage its specificities.To support this goal, we have developed a set of open source components that extract quality-of-service (QoS) data from a target Java application using JMX, aggregate it in a time-series database, and finally deliver it in a prototype Java dashboard that may be integrated in a development environment, such as Eclipse, to display either live or historical QoS data. The architecture is not only limited to collection, aggregation, and display of QoS data, but it also allows the evaluation of hierarchical queries expressed using the Performance Trees graphical language. It is our intention that this will provide a cloud-independent uniform interface for developers to specify monitoring queries. Initial evaluation suggests that Cube on MongoDB provides appropriate scalability for this application.",
        "keywords": "cloud computing; monitoring; performance trees; qos",
        "released": 2013,
        "link": "https://doi.org/10.1145/2462326.2462336"
    },
    {
        "title": "A delta-driven execution model for semantic computing",
        "abstract": "We demonstrate the execution model of a computing platform where computation is both incremental and data-driven. We call such an approach delta-driven. The platform is intended as a delivery vehicle for semantically integrated software, and thus lends itself to the semantic web, domain-driven development, and next-generation software development environments. Execution is transparent, versioned, and persistent. This technology - still at an early stage - is called domain/object.",
        "keywords": "adaptive functions; delta-driven execution; incremental computation; lazy memoization; relational programming",
        "released": 2005,
        "link": "https://doi.org/10.1145/1094855.1094935"
    },
    {
        "title": "AustLll’s aide — natural language legislative rulebases",
        "abstract": "Aide (“AustLII Inferencing Development Environment”) provides a quasi-natural language form of knowledge representation which is reasonably close to statutory language, but at the same time represents knowledge so that it can be used by an inferencing engine using predicate calculus.Aide also provides a supportive development environment for the user by parse tree differentiation to assist the user choosing the correct parsing of rules. The development environment and the user environment are both web-based, facilitating collaborative development of knowledgebases, and the integration of inferencing dialogues with legal source texts on the web.",
        "keywords": "",
        "released": 2001,
        "link": "https://doi.org/10.1145/383535.383564"
    },
    {
        "title": "Dandelion: A compiler and runtime for heterogeneous systems",
        "abstract": "Computer systems increasingly rely on heterogeneity to achieve greater performance, scalability and energy efficiency. Because heterogeneous systems typically comprise multiple execution contexts with different programming abstractions and runtimes, programming them remains extremely challenging.Dandelion is a system designed to address this programmability challenge for data-parallel applications. Dandelion provides a unified programming model for heterogeneous systems that span diverse execution contexts including CPUs, GPUs, FPGAs, and the cloud. It adopts the .NET LINQ (Language INtegrated Query) approach, integrating data-parallel operators into general purpose programming languages such as C# and F#. It therefore provides an expressive data model and native language integration for user-defined functions, enabling programmers to write applications using standard high-level languages and development tools.Dandelion automatically and transparently distributes data-parallel portions of a program to available computing resources, including compute clusters for distributed execution and CPU and GPU cores of individual nodes for parallel execution. To enable automatic execution of .NET code on GPUs, Dandelion cross-compiles .NET code to CUDA kernels and uses the PTask runtime [85] to manage GPU execution. This paper discusses the design and implementation of Dandelion, focusing on the distributed CPU and GPU implementation. We evaluate the system using a diverse set of workloads.",
        "keywords": "",
        "released": 2013,
        "link": "https://doi.org/10.1145/2517349.2522715"
    },
    {
        "title": "A delta-driven execution model for semantic computing",
        "abstract": "We describe (and demonstrate) the execution model of a computing platform where computation is both incremental and data-driven. We call such an approach delta-driven. The platform is intended as a delivery vehicle for semantically integrated software, and thus lends itself to the semantic web, domain-driven development, and next-generation software development environments. Execution is transparent, versioned, and persistent. This technology - still at an early stage - is called domain/object.",
        "keywords": "adaptive functions; delta-driven execution; incremental computation; lazy memoization; relational programming",
        "released": 2005,
        "link": "https://doi.org/10.1145/1094855.1094871"
    },
    {
        "title": "Advanced issue tracker in smalltalk",
        "abstract": "The system demonstrated is an advanced open source issue tracker built using Smalltalk, the continuation based web framework Seaside and an OODB called Magma.These unorthodox components enabled an uncompromised object oriented implementation and very fast development. The demonstration presents the system, its design, project experiences and the development environment used.",
        "keywords": "Ajax; ODBMS; Smalltalk; bugs; continations; forms; issue tracker; workflow",
        "released": 2006,
        "link": "https://doi.org/10.1145/1176617.1176692"
    },
    {
        "title": "Reasoning about digital artifacts with ACL2",
        "abstract": "ACL2 is both a programming language in which computing systems can be modeled and a tool to help a designer prove properties of such models. ACL2 stands for A Computational Logic for Applicative Common Lisp” and provides mechanized reasoning support for a first-order axiomatization of an extended subset of functional Common Lisp. Most often, ACL2 is used to produce operational semantic models of artifacts. Such models can be executed as functional Lisp programs and so have dual use as both pre-fabrication simulation engines and as analyzable mathematical models of intended (or at least designed) behavior.This project had its start 40 years ago in Edinburgh with the first Boyer-Moore Pure Lisp theorem prover and has evolved proofs about list concatenation and reverse to proofs about industrial models.Industrial use of theorem provers to answer design questions of critical importance is so surprising to people outside of the theorem proving community that it bears emphasis. In the 1980s, the earlier Boyer-Moore theorem prover, Nqthm, was used to verify the “Computational Logic stack” – a hardware/software stack starting with the NDL description of the netlist for a microprocessor and ascending through a machine code ISA, an assembler, linker, and loader, two compilers (for subsets of Pascal and Lisp), an operating system, and some simple applications. The system components were proved to compose so that properties proved of high-level software were guaranteed by the binary image produced by the composition. At around the same time, Nqthm was used to verify 21 of the 22 subroutines in the MC68020 binary machine code produced from the Berkeley C String Library by gcc -o, identifying bugs in the library as a result.Applications like these convinced us that (a) industrial scale formal methods was practical and (b) Nqthm’s Pure Lisp produced uncompetitive results compared to C when used for simulation engines. We therefore designed ACL2, which initially was Nqthm recoded to support applicative Common Lisp.The 1990s saw the first industrial application of ACL2, to verify the correspondence between a gate-level description of the Motorola CAP DSP and its microcode engine. The Lisp model of the microcode engine was proved to be bit- and cycle-accurate but operated several times faster than the gate-level simulator in C because of the competitive execution speed of Lisp and the higher level of trusted abstraction. Furthermore, it was used to discover previously unknown microcode hazards. An executable Lisp predicate was verified to detect all hazards and subsequently used by microcode programmers to check code. This project and a subsequent one at AMD to verify the floating point division operation on the AMD K5 microprocessor demonstrated the practicality of ACL2 but also highlighted the need to develop better Lisp system programming tools wedded to formal methods, formal modeling, proof development, and “proof maintenance” in the face of evolution of the modeled artifacts.Much ACL2 development in first decade of the 21st century was therefore dedicated to such tools and we have witnessed a cor-responding increase in the use of ACL2 to construct and reason about commercial artifacts. ACL2 has been involved in the design of all AMD desktop microprocessors since the Athlon; specifically, ACL2 is used to verify floating-point operations on those micro-processors. Centaur Technology (chipmaker for VIA Technologies) uses ACL2 extensively in verifying its media unit and other parts of its x86 designs. Researchers at Rockwell-Collins have shown that ACL2 models of microprocessors can run at 90",
        "keywords": "automatic theorem proving; hardware verification; jvm; microprocessor verification; operational semantics; software stack; virtual machine verification",
        "released": 2011,
        "link": "https://doi.org/10.1145/1929529.1929538"
    },
    {
        "title": "Interfacing a cognitive agent platform with a virtual world: A case study using second life",
        "abstract": "Online virtual worlds provide a rich platform for remote human interaction, and are increasingly being used as a simulation platform for multi-agent systems and as a way for software agents to interact with humans. It would therefore be beneficial to provide techniques allowing high-level agent development tools, especially cognitive agent platforms such as belief-desire-intention (BDI) programming frameworks, to be interfaced with virtual worlds. This is not a trivial task as it involves mapping potentially unreliable sensor readings from complex virtual environments to a domain-specific abstract logical model of observed properties and/or events. This paper investigates this problem in the context of agent interactions in a multi-agent system simulated in Second Life. We present a framework which facilitates the connection of any multi-agent platform with Second Life, and demonstrate it in conjunction with the Jason BDI interpreter.",
        "keywords": "BDI agents; Jason; Second Life; multiagent systems",
        "released": 2011,
        "link": "https://dl.acm.org/doi/10.5555/2034396.2034477"
    },
    {
        "title": "Programming for the xbox kinect™ sensor: Tutorial presentation",
        "abstract": "The Kinect sensor was introduced in November 2010 by Microsoft as an accessory for the Xbox 360 video game system. Shortly after the product release, multiple software frameworks became available that allows a personal computer to capture output from a stand-alone Kinect [1,2].The Kinect contains a RGB camera and a depth sensor utilizing an IR light source that allows the unit to output three dimensional positional data in real time. The Kinect data is organized as a stream of two 640 x 480 images acquired at a rate of 30 frames per second (fps). One of these is an ordinary 24-bit RGB video image. The other is an 11-bit depth image from which (x, y, z) positional data may be calculated. Students are well aware of the Kinect as an input device for the Xbox 360 system which makes it an ideal venue for student experimentation and independent study projects utilizing a personal computer platform.The tutorial presentation will provide attendees with detailed information on two of the available development environments for the Kinect:• OpenNI Framework - The OpenNI organization [1] is an industry-led, not-for-profit organization formed to certify and promote the compatibility and interoperability of Natural Interaction (NI) devices, applications and middleware. Contributors to the framework include PrimeSense [3], the hardware developer of the Kinect and Willow Garage [4] who develops hardware and open source software for personal robotics. The OpenNI framework provides a rich set of utilities that can be used to access and process Kinect data using C++, C# and Java.• Microsoft Kinect SDK - Microsoft [2] has released a SDK which provides access to much of the functionality available to XBox developers. Applications may be developed in a Windows 7 environment using managed or unmanaged code in a .NET 2010 environment.In this tutorial we will present:• Hardware and software requirements for the two development environments.• Detailed instructions for downloading of device drivers, device middleware and associated libraries.• \"Hello World\" examples for checking the functionality of the Kinect unit.• An overview of the Kinect’s capabilities including device resolution and limitations.• A summary of the library structure of both frameworks.• Several simple examples of the devices capabilities including player tracking the use of skeletal tracking.• A summary of research opportunities that are student accessible.• A demonstration of the Kinect software in action.All software and materials presented during the tutorial will be provided on the author’s web site so that users may quickly get their Kinect applications up and running without significant configuration issues and start up problems.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2168874.2168907"
    },
    {
        "title": "Using IBM rational application developer to develop enterprise applications with java EE, dojo server faces and interconnecting them using SOA",
        "abstract": "Motivation and Justification:Year to year, companies invest a lot of their budget in maintenance and improvement of their applications to keep on the leading edge of technologies and take advantage over their competitors. Some of the common troubles that companies are facing with are the lack of skills in their personnel to update and incorporate new technologies to existing applications and/or legacy applications that are difficult to support, as well as to process huge amounts of information; this implies a high cost to achieve such goals.In highly competitive environments, the developers do not have much time to create enterprise applications that meet with some infrastructure requirements such as: security, transaction, audit, and others, as well as the creation of fast, dynamic and easy to use Graphical User Interfaces (GUI)s that can be a very tedious and complicated process.Moreover, as applications evolve, they could require communication with other applications based in different technologies that address particular needs, and enabling the communication between different technologies is an expensive and difficult process. This is usually achieved by using glue code that is tied to the involved applications, hard to maintain, tightly coupled and not extensible at all.As response to these problems, new technologies have been created to help implement solutions for them; such as the Java™ EE technology which provides a set of common services to develop enterprise applications and is also an standardized platform that allows the IT infrastructure to be untied to a particular vendor, or Dojo Server Faces (DSF) library that provides a set of UI components so the developer can create responsive, dynamic and easy to use GUIs with much less effort than creating them from scratch, and the Service Component Architecture (SCA) technology that helps companies to interconnect applications implemented with different technologies allowing the enterprise infrastructure to change with a minimum of impact and/or effort, in a Service Oriented Architecture fashion. However, the use of these technologies can be complex and prone to human errors, since them involve handwriting metadata and other artifacts that can be hard to configure.Proposed solution.\"Rational Application Developer provides developers with smart tools that promote best practices, team productivity, innovation, and agility. This award-winning integrated development environment enables developers to quickly build, test, analyze, and publish Java EE 6, Web 2.0, and Service Oriented Architecture (SOA) applications\"Within this workshop we will create a scenario where the problems previously mentioned in this document will be exposed. We will discuss the technologies that can be involved in the solution of such scenario with a minimum of effort and also preparing the field to allow the application to grow as needed without affecting the applications already running. Then, the attendee will be guided to develop a solution for such scenario using IBM® Rational® Application Developer (RAD) and IBM® WebSphere® Application Server.The Scenario: The marketing department of a big bank has decided to open a new program to reward their customers with gifts and promotions depending on their account balance in the past months. This bank has an application already running that contains account information required to grant such rewards, but they want to create a new section in an existing web application where customers can access and check the status of their accounts to see whether they have a granted reward and in such case get specific information for claiming the reward. As part of the requirement, the application will have to run a complex algorithm to select the accounts that will be rewarded, this will have to run automatically every day.The solution: We will define the architecture within tree layers: the business logic layer, the UI layer and the data access layer using Open Services Gateway initiative (OSGi) to achieve good modularization. The business logic will be encapsulated in Plain Old Java Objects (POJO) and the task of running the complex algorithm will be handled by a Modern Batch Project using WebSphere Compute Grid (WCG). The UI will be developed using Java Server Faces (JSF) v2.0 technology with DSF library. The data access layer will be handled by Java Persistence API (JPA) in order to access an existing data base. Finally we will use SCA to interconnect the Modern Batch Project with OSGi.Within this workshop the attendee will learn how to use RAD Tools to incorporate mature technologies like Java EE6, open and emerging technologies like SCA, programming models for componentization and modularization like OSGi, and JSF to build responsive, dynamic and easy to use web UI.",
        "keywords": "",
        "released": 2011,
        "link": "https://dl.acm.org/doi/10.5555/2093889.2093955"
    },
    {
        "title": "The open source IPTV service development environment: IPTV service execution environment",
        "abstract": "HDTV will be the trend of future video entertainments, and IPTV is the most potential because true 2-way interaction bringing more new audiovisual entertainment options can only be delivered through IP networks.This paper proposes a service execution environment, ISEE (IPTV Service Execution Environment), that is an open source framework. This environment supports various needs during developing and executing IPTV services, fully presents the interaction of IPTV with the \"Service Component Platform\" design concept, and has the features that can flexible use and provide new additional service quickly. in order to let service providers to quickly deliver interactive TV services that meet subscriber demands according to the market trends and thereby to build the brand loyalty and to enhance industry competitiveness. On the other hand, the design concept of \"modularization platform\" is applied to increase the flexibility and stability to expansion or update set-top-box (STB) or video server, and thereby to bring service providers more comprehensive options for platform maintenance.ISEE service includes the programs executed on the service and client sides, that communicate with HTTP protocols. Server programs are run in the JVM (Java Virtual Machine) and Servlet/JSP container environment, using Apache Struts as the web AP framework. Client programs are run in browsers supporting Javascript/CSS.This paper also proposes the development tool—ISSE SDK based on the above targets. The ISEE SDK is the development tool for the IPTV services in ISEE. It is a freeware comply with the open source standards using licensing terms in Apache License, V2.[30] Service developers can freely modify the ISEE SDK source codes and freely use the SDK and the application services developing with it. The SDK is easy to use and allows users to quickly develop IPTV services to support various STBs.",
        "keywords": "IPTV; SDK; STB; asynchronous design; open source",
        "released": 2010,
        "link": "https://doi.org/10.1145/2108616.2108677"
    },
    {
        "title": "SIP APIs for voice and video communications on the web",
        "abstract": "Existing standard protocols for the web and Internet telephony fail to deliver real-time interactive communication from within a web browser. In particular, the client-server web protocol over reliable TCP is not always suitable for end-to-end low latency media path needed for interactive voice and video communication. To solve this, we compare the available platform options using the existing technologies such as modifying the web programming language and protocol, using an existing web browser plugin, and a separate host resident application that the web browser can talk to. We argue that using a separate application as an adaptor is a promising short term as well as long-term strategy for voice and video communications on the web.Our project aims at developing the open technology and sample implementations for web-based real-time voice and video communication applications. We describe the architecture of our project including (1) a RESTful web communication API over HTTP inspired by SIP message flows, (2) a web-friendly set of metadata for session description, and (3) an UDP-based end-to-end media path. All other telephony functions reside in the web application itself and/or in web feature servers. The adaptor approach allows us to easily add new voice and video codecs and NAT traversal technologies such as Host Identity Protocol. We want to make web-based communication accessible to millions of web developers, maximize the end user experience and security, and preserve the huge global investment in and experience from SIP systems while adhering to web standards and development tools as much as possible. We have created an open source prototype that allows you to freely use the conference application by directing a browser to the conference URL.",
        "keywords": "SIP API for web communications; browser API; real-time web communication; voice and video",
        "released": 2011,
        "link": "https://doi.org/10.1145/2124436.2124439"
    },
    {
        "title": "The lively kernel: Just for fun, let’s take JavaScript seriously",
        "abstract": "The Sun Labs Lively Kernel is a new approach to Web programming. It provides a complete platform for Web applications, including dynamic graphics, network access, and development tools, and requires nothing more than available web browsers. We call the system \"lively\" for three reasons. It comes live off a web page. There is no installation. The entire system is written in JavaScript, and it becomes active as soon as the page is loaded by a browser. It can change itself and create new content. The Lively Kernel includes a basic graphics editor that allows it to alter and create new graphical content, and also a simple IDE that allows it to alter and create new applications. It comes with a basic library of graphical and computational components, and these, as well as the kernel, can be altered and extended on the fly. It can save new artifacts, even clone itself, onto new web pages. The kernel includes WebDAV support for browsing and extending remote file systems, and thus has the ability to save its objects and \"worlds\" (applications) as new active Web pages. The Lively Kernel uses only existing Web standards. The implementation and user language is JavaScript, known by millions and supported in every browser. The graphics APIs are built upon SVG (Scalable Vector Graphics), also available in major browsers. The network protocols used are asynchronous HTTP and WebDAV. The speaker will demonstrate the Lively Kernel and discuss various aspects of JavaScript as a programming language.",
        "keywords": "",
        "released": 2008,
        "link": "https://doi.org/10.1145/1408681.1408690"
    },
    {
        "title": "Labview programming for internet-based measurements",
        "abstract": "Advances in networking technologies and the introduction of recent software development tools have made Internet-Based measurements a reality. This paper shows how LabVIEW can be used to perform data acquisition and remotely control hardware devices through the Internet. A front panel displays the real-time results and allows storage of acquired data for later processing. Applications may be monitored and controlled from any web browser, anywhere in the world.",
        "keywords": "",
        "released": 2003,
        "link": "https://dl.acm.org/doi/10.5555/767598.767613"
    },
    {
        "title": "Challenges in teaching user interface design for telephones and cell phones",
        "abstract": "Participants in this SIG will identify issues and suggest solutions for teaching user interface design for telephones and cell phones. Specifically, speech user interface development environments, implementation languages, unique problems of speech interfaces, and additional resources will be examined. Participants will include educators who teach web development, and web developers interested in developing speech applications.",
        "keywords": "",
        "released": 2003,
        "link": "https://doi.org/10.1145/765891.766038"
    },
    {
        "title": "A collaborative ontology development tool for information security managers",
        "abstract": "This paper explores the need for a collaborative development tool to allow information security experts to capture their interrelated knowledge in an ontology. Such a tool would enable organisations to make more informed security policy decisions around shared security issues. However, population of ontologies can be time-consuming and error-prone, and current collaborative ontology editing tools require a familiarity with ontology concepts. We present a Web-oriented tool which simplifies ontology population for information security experts, allowing them to develop ontology content without the need to understand ontology concepts. To understand how organisations manage information security knowledge within policies, we consulted two information security managers in large organisations. The Web-Protégé collaborative ontology editor was then modified to create a tool with an appropriate knowledge ontology structure that meets their requirements. The same information security managers then evaluated the tool, judging it to be accessible and potentially useful in policy decision-making.",
        "keywords": "information security ontology; ontology editor",
        "released": 2010,
        "link": "https://doi.org/10.1145/1873561.1873566"
    },
    {
        "title": "On the challenge of adopting standard EHR systems in developing countries",
        "abstract": "Electronic health record (EHR) systems are a popular mechanism for accessing health records in the developed world and have contributed towards improved and cost-effective health care management. However, the development of appropriate and scalable EHR systems in developing countries has been difficult to achieve because of certain limitations inherent in the technological infrastructure. In this paper, we present a comparative study of 19 EHR systems in terms of the security and usability of these systems within the context of the developing world. Our aim was to investigate whether online health services designed for developed countries can be adopted for EHR systems in developing countries. The investigation was based on a number of dimensions such as development environment, system platform, type and access control standards found in the National Institute for Standard and Technology (NIST) and Certification Commission for Health Information Technology (CCHIT). Our research indicates that all the systems evaluated require online access control decisions. Solely relying on an online access control system is limiting, particularly in developing countries where access to the server can be disrupted by a number of disastrous events.",
        "keywords": "",
        "released": 2013,
        "link": "https://doi.org/10.1145/2442882.2442911"
    },
    {
        "title": "Towards automated functional testing of converged applications",
        "abstract": "There is a growing demand for IP based multimedia services that encompass usage of multiple user interfaces including web and telephony. The complexity of such converged applications requires sophisticated development tools and techniques. While standards such as SIP and HTTP Servlets enable the application developer to develop and deploy converged applications, there is a growing need for tools and techniques that can help with functional testing of converged applications. This paper makes the following contributions - (1) identifies key challenges including concurrency and coordination in functional testing of converged applications (2) describes our solution to address these challenges and (3) describes the impact of our solution based on experience gained from its use in functional testing of a real-world converged conferencing application.",
        "keywords": "VoIP applications; converged applications; telecommunications; testing",
        "released": 2009,
        "link": "https://doi.org/10.1145/1595637.1595649"
    },
    {
        "title": "Developing a web authoring tool that promotes accessibility in children’s designs",
        "abstract": "This paper describes the development, with full involvement by children, of a web development tool which reflects truly how children view the World Wide Web. The tool was designed in such a way that it promoted the understanding and implementation of accessibility principles to the users.",
        "keywords": "children; web accessibility; web authoring",
        "released": 2003,
        "link": "https://doi.org/10.1145/953536.953542"
    },
    {
        "title": "The relationship between task difficulty and emotion in online computer programming tutoring (abstract only)",
        "abstract": "Emotion, or affect, plays a central role in learning. In particular, promoting positive emotions throughout the learning process is important for students’ motivation to pursue computer science and for retaining computer science students. Positive emotions, such as engagement or enjoyment, may be fostered by timely individualized help. Especially promising are interventions if the student is having difficulty completing a task. Recognizing when a student is facing a complex task may better inform teachers or adaptive learning environments about the students’ affective states, which in turn can inform instructional adaptations. We approach this research goal by analyzing a data set of student facial videos from computer-mediated human tutorial sessions in Java programming. Students and tutors interacted with a synchronized web-based development environment. The tutorial sessions were divided into six lessons each with subtasks, and featured corresponding learning objectives for the students. In post-hoc analysis, we identified \"difficult\" tasks by comparing the frequencies of student-tutor interaction and task behaviors such as running the program and the time to complete tasks. Nonverbal behaviors, such as gesturing or postural shifting, were then compared with task difficulty. Understanding such nonverbal behavior can inform individualized interventions, which may keep students engaged and foster greater learning gains.",
        "keywords": "affective modeling; facial detection; postural detection",
        "released": 2014,
        "link": "https://doi.org/10.1145/2538862.2544298"
    },
    {
        "title": "Supporting pair programming with JavaGrinder",
        "abstract": "JavaGrinder is a web-based platform designed to support teaching Java in introductory Computer Science classes. JavaGrinder emphasizes small bite-sized problems that can range in complexity from a few lines to the construction of multiple classes. Since the entire environment is set online in a Web 2.0 styled interface, students do not have to install or setup any special software, which greatly reduces the associated learning curve. Stripped of the development tools and onerous minutia, students can concentrate on core concepts and problem solving skills therefore focusing learning on the important aspects of Computer Science. In this paper, we describe JavaGrinder’s utilization of pair programming, a technique that pairs programmers together in complementary roles to improve each student’s learning and understanding. JavaGrinder further enables students using pair programming by managing and organizing their application of this technique. JavaGrinder can also help identify when pair programming fails and inform instructors when there are poor pairings or when inequities exist in the programming roles. The development of this system aims to increase the retention of students in Computer Science I while enabling a greater understanding of basic Computer Science concepts.",
        "keywords": "",
        "released": 2010,
        "link": "https://dl.acm.org/doi/10.5555/1858583.1858592"
    },
    {
        "title": "Massively multi-player games: Matching game design with technical design",
        "abstract": "We propose a framework model to facilitate the prototyping and refinement of Massively Multi-player Online Games (MMOG), when included in the appropriate development environment. This work-in-progress report is motivated by observations made in the video game industry about the industrial process of designing such a demanding application, and based upon the technical know-how in that domain. A major benefit of the development environment based on this framework would be to validate game-design interactions when confronted with technical feasibility. A further benefit of this tool would be to assist the rest of the development process: for a spiral life-cycle style process, the tool could provide some interesting ways for analyzing the performance of more and more accurate prototypes at each stage of the development.",
        "keywords": "",
        "released": 2004,
        "link": "https://doi.org/10.1145/1067343.1067378"
    },
    {
        "title": "Custom visual recognition model with watson studio",
        "abstract": "The explosive growth of cameras, image sensors, and computer vision as a discipline of Artificial Intelligence (AI) has garnered strong interest from researchers, developers, businesses and consumers. Image classification refers to a process to classify an image according to a model and match it to a set of classes or categories. Object detection is similar to image classification, which is a process to classify, locate and count multiple objects in an image and their respective locations within the image. Object tracking involves using object detection in each frame of a video to track the desired object through a series of image frames or video [1]. There are a number of use cases for computer vision including face recognition for application or device security, automatically counting and classifying items on a production line, and monitoring and responding to traffic conditions on busy road sections.Computer vision seeks to understand information in digital images through processing and analyzing digital images. This understanding is achieved through extracting high dimension data from images and processing them to produce usable information. Practical applications of computer vision in the context of machine learning include classification, segmentation, and tracking [2].IBM Watson Studio (https://www.ibm.com/watson) is IBM’s suite of enterprise-ready AI services, applications and tooling. As a service on IBM Cloud, IBM Watson Visual Recognition uses deep learning algorithms to analyze images for scenes, faces, and objects. This service provides built-in models and can also be used to create and train custom models for specific needs. Watson Studio provides a collaborative platform on top of IBM Cloud’s cloud computing capabilities to use existing models or train and deploy new models with minimal coding. Watson Studio has the added capability of setting up custom environments and Notebooks, allowing quick, cloud-enabled development machines that can scale as your projects scale.IBM PowerAI Vision (https://www.ibm.com/caen/marketplace/ibm-powerai-vision) is a Graphics Processing Unit (GPU) accelerated visual recognition solution running on IBM Power Systems. PowerAI Vision (https://www.ibm.com/caen/marketplace/ibm-powerai-vision) puts data science in the hands of subject matter experts. This tool simplifies building machine learning models with IBM Power Systems. As a result, users can build models and deploy them to the web without coding. The models can be accessed through an Application Program Interface (API). On the other hand, users can call the API from their own applications with a few lines of code.IBM provides developers free, open source, state-of-the-art assets for deep learning through the Model Asset Exchange (MAX) (https://developer.ibm.com/exchanges/models/) on IBM Developer. In the repository developers can find both assets for training deep learning models and pre-trained models to use in their projects.The first half of this workshop will focus on exploring the Watson Visual Recognition and Watson Machine Learning Services in IBM Cloud. We will begin by building and deploying a model on Watson Visual Recognition. We will focus on the key benefits of the service, including the ability of anyone with minimal coding experience to be able to train and deploy a computer vision model to the cloud. We will then demonstrate how easy it can be to integrate the model in any web-enabled application through a demo web application. Once this has been completed, we will give a soft introduction to Watson Machine Learning, including how to choose development environments, setting up a Jupyter notebook (https://jupyter.org/), and go over some prepared code snippets to train and analyze a model fully on the cloud. [We will then demonstrate how we can export the model and use it in our applications.In the second half of the workshop, we will demonstrate detecting and labeling objects within an image using PowerAI Vision object detection (https://github.com/IBM/powerai-vision-object-detection), based on customized training. Instead of writing code to train, deploy, and test the new model, we will only need to upload the images, and label the objects in the provided application. Once the model is deployed, we will use the PowerAI Vision user interface (UI) to test it. We will also use our application as a Representational State Transfer (REST) client to locate and count objects in an image using the provided REST API endpoint. At the end of the workshop we will briefly introduce Model Asset Exchange, we will demonstrate how to find a visual recognition model on MAX, deploy it as a microservice and test it.In summary, we will introduce some visual recognition services provided by IBM in this workshop. We together will develop an image classification model using Watson Visual Recognition service with Watson Studio. We also consume a visual recognition service from a client side. Then we discuss the features of PowerAI Vision and demonstrate object detection in PowerAI Vision. Finally, we introduce Model Asset Exchange.",
        "keywords": "IBM Watson visual recognition; IBM cloud; artificial intelligence; deep learning; machine learning; model asset exchange; powerai vision; visual recognition; watson studio",
        "released": 2019,
        "link": "https://dl.acm.org/doi/10.5555/3370272.3370324"
    },
    {
        "title": "Tiny web services for sensor device interoperability",
        "abstract": "There are many scenarios where interoperability is required for sensor devices. We demonstrate one approach to achieve interoperability: using web services. Hosting a web service challenges the battery-life, bandwidth, and processing power constraints of low power sensor nodes. We demonstrate a lightweight implementation on MSP430 based sensor nodes with 802.15.4 radios. The implementation allows standards compliant web service clients to use the sensors but minimizes code size and energy at the sensor nodes. It allows sensor nodes to enter sleep modes. We prototype an example application for a home sensor network along with two types of sensor nodes required for it. We also show how our system enables sensor nodes to be used easily from applications written in high level languages using existing development tools.",
        "keywords": "sensor web service",
        "released": 2008,
        "link": "https://doi.org/10.1109/IPSN.2008.33"
    },
    {
        "title": "vApp: A standards-based container for cloud providers",
        "abstract": "In the past decade, virtualization has swept through the x86 server landscape and caused a dramatic change in how enterprise datacenters are organized both from a physical infrastructure level and an organizational level. This has lead to a datacenter where all resources and services are virtualized, paving the way for a complete decoupling of the applications from the physical infrastructure. This is known as cloud computing or more specifically, Infrastructure as a Service (IaaS).The decoupling of the application from the deployment platform is a fundamental shift from previous generations of datacenter infrastructure. To utilize this decoupling, a well-defined interface between the application and the cloud provider must exist. We describe the core requirements for this interface and introduce a concrete implementation of such an interface, called the vApp container. The vApp container is built on top of the Open Virtualization Format. We also introduce the concept of a vService dependency that is used to decouple a vApp from infrastructure services and to support mobility between cloud providers. Finally, the paper provides several examples of vApps and service integrations and discusses how development tools can be optimized for the vApp container",
        "keywords": "IaaS; OVF; cloud; infrastructure as a service; open virtualization format; vApp; vApp container; vServices",
        "released": 2010,
        "link": "https://doi.org/10.1145/1899928.1899943"
    },
    {
        "title": "Oracle",
        "abstract": "Oracle is the market leader in database sales and the world’s second largest software maker. In addition, Oracle creates industry award-winning, Web-based corporate applications, business intelligence tools, server management tools, and development tools.",
        "keywords": "",
        "released": 2002,
        "link": "https://doi.org/10.1145/505103.505129"
    },
    {
        "title": "HALO (highly addictive, socially optimized) software engineering",
        "abstract": "In recent years, computer games have become increasingly social and collaborative in nature. Massively multiplayer online games, in which a large number of players collaborate with each other to achieve common goals in the game, have become extremely pervasive. By working together towards a common goal, players become more engrossed in the game. In everyday work environments, this sort of engagement would be beneficial, and is often sought out. We propose an approach to software engineering called HALO that builds upon the properties found in popular games, by turning work into a game environment. Our proposed approach can be viewed as a model for a family of prospective games that would support the software development process. Utilizing operant conditioning and flow theory, we create an immersive software development environment conducive to increased productivity. We describe the mechanics of HALO and how it could fit into typical software engineering processes.",
        "keywords": "flow; games; mmorpg; operant conditioning; quests; social rewards; web 2.0",
        "released": 2011,
        "link": "https://doi.org/10.1145/1984674.1984685"
    },
    {
        "title": "Towards open source authoring and presentation of multimedia content",
        "abstract": "Open source principles and methodologies allow open access to both the development process and its products. This paper describes a number of significant research issues for the creation of novel development environments that support open source authoring of multimedia content and dynamic forms of personalization during content consumption. These environments should allow an unlimited number of users to modify existing media content and post their contributions on the net. In addition, they should allow users to visualize the current state of development in each project, select a subset of the various contributions and dynamically compose, view and share with other users new content versions containing all the selected contributions. Furthermore, the paper describes a pilot web-services-based implementation for such a system developed in C# that is now freely available on the Web.",
        "keywords": "authoring paradigms; open source; personalization tools; visualization",
        "released": 2007,
        "link": "https://doi.org/10.1145/1290128.1290136"
    },
    {
        "title": "Math IDE: A platform for creating with math",
        "abstract": "To inspire student engagement in middle school math, we explore the possibility of using generative AI to enhance the creativity of math learning. We present the Math IDE, a math education environment in which students learn about math concepts by building artifacts. We aimed to create a platform in which students can engage with mathematical concepts, create an artifact that embodies the math that they are learning about, and practice their high-level specification skills. In the current iteration of the Math IDE, students can create custom web pages by describing and demonstrating understanding of the math that is involved in the web page. In this short overview, we describe our process and discuss several open questions regarding the design and application of this novel method of math education.",
        "keywords": "creating; education; generative ai; math",
        "released": 2024,
        "link": "https://doi.org/10.1145/3626253.3635572"
    },
    {
        "title": "Growing a GUI from an XML tree",
        "abstract": "Computer science faculty in the current fast-paced computing environment must be very resourceful; they must constantly learn new topics and explain them to their undergraduate students (who are familiar with the acronyms and inquisitive about their meaning), while not letting these exciting new topics overshadow the fundamentals. They must analyze these new developments to see the fundamental concepts that ultimately serve as their basis. They must then determine how to integrate these concepts into the undergraduate curriculum at the correct level for their students. This poster shows how XML (eXtensible Markup Language) and hierarchical data structures are correlated, allowing instructors to add XML concepts to the CS2 curriculum in a way that is fun for students, namely, GUI development.Students typically enjoy designing their GUIs. They find it is hard to understand how a GUI will look without the visual aid of an IDE (Integrated Development Environment). However, when using an IDE, the details of how the user interface is created are hidden from the programmers - not just the code, but the design principles as well. The programmers can become dependent on the IDE for GUI development, limiting their ability to design novel interfaces. In addition, students who do not use an IDE at all find it difficult to remember all their GUI component relationships, making GUI design a trial and error process. We seek a way for students to design GUIs that forces them to consider how GUIs are constructed, improving their design skills, while at the same time making the design process as straightforward as possible.GUIs are hierarchical in nature because they are based on containers holding GUI components, which may themselves be containers. Thus, it may be helpful to utilize the notion of a tree in the construction of a GUI, allowing development of GUIs without the dependence on a standard IDE and without many of the difficulties of GUI construction by hand. As students typically learn about trees in CS2, this is an appropriate time to introduce GUI hierarchies. Students are also often eager to be exposed to hot topics in computer science, such as XML. XML is hierarchical in nature; thus, it lends itself to GUI design. We propose integrating these ideas into an \"XML-based IDE\" that students can use in the beginning stages of development for their own GUIs. This makes students aware of the hierarchical nature of their GUIs in the design phase, enhancing their ability to develop useful and creative user interfaces. At the same time, students are exposed to basic XML concepts and syntax.Our \"XML-based IDE\" has two important parts: our markup language and our code generator. First, we developed a preliminary XML schema describing a grammar for basic GUI programs. This schema describes the XML tags and the relationships among them. Our XML tags correspond to Java nomenclature (swinggui, jframe, jpanel, jcomponent, listener, layout, etc.) as our CS2 students program in Java. After developing our schema, we implemented a Java program to translate an XML document conforming to our schema to corresponding Java source files. To build a shell of a GUI program, a student needs to write an XML document describing the interface and run our utility program to generate the Java source files. When the Java source files are compiled and executed, the student can see the resulting GUI. The student only needs to design and implement the event-handling algorithms. Our \"XML-based IDE\" demonstrates the usefulness of XML in other areas besides the World-Wide Web and is a refreshing change from the standard XML examples.We believe that our \"XML-based IDE\" is a practical and fun way to introduce XML into the introductory computer science curriculum without sacrificing fundamental concepts.",
        "keywords": "",
        "released": 2003,
        "link": "https://doi.org/10.1145/961511.961579"
    },
    {
        "title": "Systematic performance evaluation based on tailored benchmark applications",
        "abstract": "Performance (i.e., response time, throughput, resource consumption) is a key quality metric of today’s applications as it heavily affects customer satisfaction. SAP strives to identify and fix performance problems before customers face them. Therefore, performance engineering methods are applied in all stages of the software lifecycle. However, especially in the development phase continuous performance evaluations can introduce a lot of overhead for developers which hinders their broad application in practice. In order to evaluate the performance of a certain software artefact (e.g. comparing two design alternatives), a developer has to run measurements that are tailored to the software artefact under test. The use of standard benchmarks would create less overhead, but the information gain is often not sufficient to answer the specific questions of developers. In this industrial paper, we present an approach that enables exhaustive, tailored performance testing with minimal effort for developers. The approach allows to define benchmark applications through a domain-specific model and realizes the transformation of those models to benchmark applications via a generic Benchmark Framework. The application of the approach in the context of the SAP Netweaver Cloud development environment demonstrated that we can efficiently identify performance problems that would not have been detected by our existing performance test infrastructure.",
        "keywords": "benchmarking; database; java persistence api; performance",
        "released": 2013,
        "link": "https://doi.org/10.1145/2479871.2479934"
    },
    {
        "title": "Verifying and displaying move smart contract source code for the sui blockchain",
        "abstract": "Smart contract development presents additional challenges beyond traditional software workflows, e.g., locally in IDEs. For smart contract developers to understand and trust code execution, they need to write and use software libraries with a comprehensible code representation—i.e., source code. However, blockchains do not typically store the original source code of smart contracts, but a condensed bytecode representation. Thus, when developers consult smart contract source code, they need to be sure that it corresponds to the same bytecode on the blockchain. Depending on available developer tools, this process can be ad-hoc, cumbersome, or opaque. In this paper we present our design and implementation of a new tool that serves to verify Move smart contract source code against its bytecode representation on the Sui blockchain. We demonstrate the user-facing shift where developers now benefit from seeing source code in their browser instead of bytecode. We further highlight future features and research directions that verified source availability brings to smart contract developer experience.",
        "keywords": "smart contracts; source code; bytecode; compilers; program comprehension; software development; blockchain",
        "released": 2024,
        "link": "https://doi.org/10.1145/3639478.3640038"
    },
    {
        "title": "A review of web based simulation: Whither we wander?",
        "abstract": "This paper considers a variety of new technologies for discrete-event simulation software development. Environments and languages for web based simulation are reviewed. Web based applications are discussed. After proposing a summary of the review, ways of working that will have an unpredictable effect on the future of simulation modeling are proposed.",
        "keywords": "",
        "released": 2000,
        "link": "https://dl.acm.org/doi/10.5555/510378.510651"
    },
    {
        "title": "The aspect-oriented web",
        "abstract": "We examine Aspect-Oriented Programming (AOP) as it applies to web development. XHTML was designed to separate form from content, a fundamental principle of separation of concerns in AOP. Cascading Stylesheets and Javascript naturally provide support for AOP. The release of AOPHP (Aspect-Oriented PHP) provides a more traditional way to implement AOP in the LAMP (Linux, Apache, MySQL, PHP) web development environment, weaving advice code into PHP source code prior to the PHP pre-processing step.",
        "keywords": "AOP-like behavior; AOPHP; LAMP; aspect-oriented programming; separation of concerns; web development",
        "released": 2005,
        "link": "https://doi.org/10.1145/1085313.1085336"
    },
    {
        "title": "Providing session management as core business service",
        "abstract": "It is extremely hard for a global organization with services over multiple channels to capture a consistent and unified view of its data, services, and interactions. While SOA and web services are addressing integration and interoperability problems, it is painful for an operational organization with legacy systems to quickly switch to service-based methods. We need methods to combine advantages of traditional (i.e. web, desktop, or mobile) application development environments and service-based deployments.In this paper, we focus on the design and implementation of session management as a core service to support business processes and go beyond application-specific sessions and web sessions. We develop local session components for different platforms and complement them with a remote \"session service\" that is independent of applications and platforms. We aim to close the gap between the two worlds by combining their performance, availability and interoperability advantages.",
        "keywords": "data serialization; multi-channel integration; session service",
        "released": 2007,
        "link": "https://doi.org/10.1145/1242572.1242798"
    },
    {
        "title": "From cluster to cloud to appliance",
        "abstract": "We propose a client-side virtual machine (VM) as an alternative to on-campus clusters and off-campus clouds as a development environment for students in introductory courses. In Fall 2011, we deployed the CS50 Appliance, our own such VM, to 600 students on campus and, in Fall 2012, to 700 students on campus and 140,000 students online. We present in this work the results of that two-year experiment. The appliance itself is available as open source for others to adapt or adopt. Not only did the appliance enable us to provide students with simpler tools, among them a graphical editor without any latency, it also enabled us to provide more sophisticated tools too, including a web server and database server. Moreover, the appliance ensured that the course’s workload no longer required constant Internet access, particularly of students abroad. And the appliance alleviated load on the course’s servers, with execution of students’ programs now distributed across students’ own CPUs. Without the appliance (or more costly clusters or clouds), we certainly could not have accommodated as many as 140,000 students.But some students’ laptops, particularly netbooks, struggled under the appliance’s weight. Even though designed to be lean, the appliance, like any VM, still consumes resources, particularly RAM. And unforeseen technical difficulties arose in both years, most, but not all, of which we redressed with mid-semester updates and documentation.Overall we have judged our deployment of an appliance a success, superior to past years’ clusters and clouds. And we continue to refine the appliance for Fall 2013.",
        "keywords": "virtual machine; virtualization",
        "released": 2013,
        "link": "https://doi.org/10.1145/2462476.2462491"
    },
    {
        "title": "JASPER: An eclipse plug-in to facilitate software maintenance tasks",
        "abstract": "Recent research has shown that developers spend significant amounts of time navigating around code. Much of this time is spent on redundant navigations to code that the developer previously found. This is necessary today because existing development environments do not enable users to easily collect relevant information, such as web pages, textual notes, and code fragments. JASPER is a new system that allows users to collect relevant artifacts into a working set for easy reference. These artifacts are visible in a single view that represents the user’s current task and allows users to easily make each artifact visible within its context. We predict that JASPER will significantly reduce time spent on redundant navigations. In addition, JASPER will facilitate multitasking, interruption management, and sharing task information with other developers.",
        "keywords": "Eclipse; concerns; natural programming; programmer efficiency; programming environments",
        "released": 2006,
        "link": "https://doi.org/10.1145/1188835.1188849"
    },
    {
        "title": "Workshop on moving to visual basic.net",
        "abstract": "This workshop and accompanying paper will discuss and demonstrate some of the strengths and weaknesses of the new VB.Net object-oriented programming language. It is appropriate for anyone who is contemplating a course in the new language or anyone who just wants to know more about VB.Net architecture. Database connectivity and web applications will be demonstrated in addition to some fundamental navigational and Interactive Development Environment (IDE) issues. Finally, the authors will share their experiences in developing and teaching VB.Net as a second or third language to junior and senior CS/IS majors and minors at Northwest Missouri State University.",
        "keywords": "",
        "released": 2003,
        "link": "https://dl.acm.org/doi/10.5555/767598.767646"
    },
    {
        "title": "Open community development for science gateways with apache rave",
        "abstract": "Science gateways enable researchers and students to use distributed scientific computing infrastructure (cyberinfrastructure) through Web browsers and Web-enabled desktop clients. This paper describes the use of the open source, open community Apache Rave project as the basis for developing science gateways. Building on Apache Shindig (for OpenSocial Gadgets) and Apache Wookie (for W3C Widgets), Rave provides an out-of-the box deployment that can be used to host reusable social Web components. Rave is based on the Spring MVC framework and so can also be extensively customized or extended with (for example) custom database back-ends and authentication modules. In this paper we consider Rave as a development platform for science gateways and discuss how the source code may be extended through three use cases that focus on gateway security requirements. A major consideration of this paper is how to design Rave as a development environment so that developers can make local customizations and extensions freely on both a rapidly changing code base (during Rave’s initial development), and (later) between stable code bases during version upgrades. We conclude with a discussion of the implications of developing science gateways and other cyberinfrastructure software within the Apache Software Foundation and present its potential advantages.",
        "keywords": "OpenSocial; W3C widget; cloud computing; grid computing; science gateways; web computing",
        "released": 2011,
        "link": "https://doi.org/10.1145/2110486.2110491"
    },
    {
        "title": "Developing interactive web applications with the google web toolkit",
        "abstract": "Web sites such as Gmail, Facebook and other Web 2.0 applications have changed the way that we think about web functionality. These sites behave more like desktop applications than traditional document-centric sites. Developing these interactive web applications using technologies such as AJAX is tedious, error prone and difficult to optimize. Development environments and tools for such applications lag behind the more mature tools available for languages such as Java.The Google Web Toolkit is an emerging technology that facilitates the integration of the powerful tools available for the Java platform into the interactive web world. The toolkit consists of tools that compile Java code into a combination of HTML and Javascript code; since the code is being written in Java, all of the tools available for Java development can be leveraged, such as the Eclipse IDE and testing tools such as JUnit. Utilizing a compiler to generate Javascript provides an opportunity for optimization that would be difficult without the use of the toolkit.In this workshop, participants will learn about the Google Web Toolkit, including the philosophy behind the toolkit, the GUI framework that it provides, and the methods available for interaction with remote services. Participants will be walked through the development of a simple \"Stock Ticker\" application that interacts with the Yahoo stock data service. Several other sample applications will be presented, including sample assignments given to students in a class focusing on applications of the GWT.An outline of the workshop is:• Introduction to the Google Web Toolkit (30 minutes)• Presentation and discussion of several applications built using the toolkit (30 minutes)• Development of the Stock Ticker application (1 hour)• Overview of the GUI Framework and server integration techniques (30 minutes)• Overview of a course on the GWT (15 minutes)• Questions/wrap up",
        "keywords": "",
        "released": 2009,
        "link": "https://dl.acm.org/doi/10.5555/1619221.1619228"
    },
    {
        "title": "Web-based tool for automatic acceptance test execution and scripting for programmers and customers",
        "abstract": "Software testing is a software engineering practice that improves the quality of developed computer systems. It is a testing discipline strongly related to the agile software development method Extreme Programming (XP) [2], thus this paper examines acceptance tests mostly from a XP viewpoint. Nowadays, there are many online portals in which a large database of software projects can be found. If developers intent to run acceptance tests in those software, they must always have a complete development environment installed. In this paper, we present FLOAppTest, a visual online (remote) tool integrated to a collaborative environment (like Source Forge) that makes Java projects testing easy by offering a fashion to generate executable acceptance scripts with EasyAccept framework support.",
        "keywords": "WEB components; WEB systems; acceptance tests; software engineering; software testing",
        "released": 2007,
        "link": "https://doi.org/10.1145/1352694.1352752"
    },
    {
        "title": "Semi-automatic, inline and collaborative web page code curations",
        "abstract": "Software developers spend about a quarter of their workday using the web to fulfill various information needs. Searching for relevant information online can be time-consuming, yet acquired information is rarely systematically persisted for later reference. In this work, we introduce SALI, an approach for semi-automated inline linking of web pages to source code locations. SALI helps developers naturally capture high-quality, explicit links between web pages and specific source code locations by recommending links for curation within the IDE. Through two laboratory studies, we examined the developer’s ability to both curate and consume links between web pages and specific source code locations while performing software development tasks. The studies were performed with 20 subjects working on realistic software change tasks from widely-used open-source projects. Results show that developers continuously and concisely curate web pages at meaningful locations in the code with little effort. Additionally, we found that other developers could use these curations while performing new and different change tasks to speed up relevant information gathering within unfamiliar codebases by a factor of 2.4.",
        "keywords": "semi-automated link curation; knowledge management; web browsing; collaboration",
        "released": 2023,
        "link": "https://doi.org/10.1109/ICSE48619.2023.00159"
    },
    {
        "title": "Interdependent components of web accessibility",
        "abstract": "Increasingly, the Web is providing unprecedented access to information and interaction for people with disabilities. However, the Web will not be equally accessible, allowing people with disabilities to access and contribute to the Web, until:• Authoring tools and development environments (including content managements systems such as blogging applications) produce accessible Web content and have accessible interfaces;• Browsers, multimedia players and assistive technologies provide a completely usable and accessible experience;Content is designed to be accessible.Web accessibility relies on tools that are designed to work together and support the needs of the people who use them. This paper describes how Web accessibility depends on several components working together. It demonstrates the relationship between the World Wide Web Consortium (W3C) Web Accessibility Initiative (WAI) guidelines: Web Content Accessibility Guidelines (WCAG), Authoring Tool Accessibility Guidelines (ATAG), and User Agent Accessibility Guidelines (UAAG).",
        "keywords": "ATAG; UAAG; W3C; WAI; WCAG; Web content; accessibility; assistive technology; authoring tools; blog; disabilities; guidelines; technical specifications; user agents",
        "released": 2005,
        "link": "https://doi.org/10.1145/1061811.1061818"
    },
    {
        "title": "Characteristics and responsibilities involved in a phishing attack",
        "abstract": "’Phishing’ is a fraudulent activity defined as the creation of a replica of an existing Web page to fool a user into submitting personal, financial, or password data. There are security service guidelines for both software security and web site security development environments. Developers use these guidelines when planning new systems (or during re-engineering of existing systems) to ensure a secure environment. The purpose of this paper is two-fold: firstly to consider the characteristics of a phishing attack and to identify a list of issues relevant to it; and secondly, to compare the nature of a phishing attack with the security services guidelines provided and to pinpoint the weakness(es) of phishing attacks if these guidelines are adhered to.",
        "keywords": "",
        "released": 2005,
        "link": "https://dl.acm.org/doi/10.5555/1071752.1071800"
    },
    {
        "title": "Scalable multimedia content analysis on parallel platforms using python",
        "abstract": "In this new era dominated by consumer-produced media there is a high demand for web-scalable solutions to multimedia content analysis. A compelling approach to making applications scalable is to explicitly map their computation onto parallel platforms. However, developing efficient parallel implementations and fully utilizing the available resources remains a challenge due to the increased code complexity, limited portability and required low-level knowledge of the underlying hardware. In this article, we present PyCASP, a Python-based framework that automatically maps computation onto parallel platforms from Python application code to a variety of parallel platforms. PyCASP is designed using a systematic, pattern-oriented approach to offer a single software development environment for multimedia content analysis applications. Using PyCASP, applications can be prototyped in a couple hundred lines of Python code and automatically scale to modern parallel processors. Applications written with PyCASP are portable to a variety of parallel platforms and efficiently scale from a single desktop Graphics Processing Unit (GPU) to an entire cluster with a small change to application code. To illustrate our approach, we present three multimedia content analysis applications that use our framework: a state-of-the-art speaker diarization application, a content-based music recommendation system based on the Million Song Dataset, and a video event detection system for consumer-produced videos. We show that across this wide range of applications, our approach achieves the goal of automatic portability and scalability while at the same time allowing easy prototyping in a high-level language and efficient performance of low-level optimized code.",
        "keywords": "GPU; Multimedia content analysis; parallelism; rapid prototyping",
        "released": 2014,
        "link": "https://doi.org/10.1145/2517151"
    },
    {
        "title": "Profiling for detecting performance anomalies in concurrent software",
        "abstract": "Understanding and identifying performance problems is difficult for parallel applications, but is an essential part of software development for parallel systems. In addition to the same problems that exist when analysing sequential programs, software development tools for parallel systems must handle the large number of execution engines (cores) that result in different (possibly non-deterministic) schedules for different executions. Understanding where exactly a concurrent program spends its time (esp. if some aspects of the program paths depend on input data) is the first step towards improving program quality. State-of-the-art profilers, however, aid developers in performance diagnosis by providing hotness information at the level of a class or method (function) and usually report data for just a single program execution. This paper presents a profiling and analysis technique that consolidates execution information for multiple program executions. Currently, our tool’s focus is on execution time (CPU cycles) but other metrics (stall cycles for functional units, cache miss rates, etc) are possible, provided such data can be obtained from the processor’s monitoring unit. To detect the location of performance anomalies that are worth addressing, the average amount of time spent inside a code block, along with the statistical range of the minimum and maximum amount of time spent, is taken into account. The technique identifies performance bottlenecks at the fine-grained level of a basic block. It can indicate the probability of such a performance bottleneck appearing during actual program executions. The technique utilises profiling information across a range of inputs and tries to induce performance bottlenecks by delaying random memory accesses. The approach is evaluated by performing experiments on the data compression tool pbzip2, the multi-threaded download accelerator axel, the open source security scanner Nmap and Apache httpd web server. An experimental evaluation shows the tool to be effective in detecting performance bottlenecks at the level of a basic block. Modifications in the block that is identified by the tool result in performance improvement of over 2.6x in one case, compared to the original version of the program. The performance overhead incurred by the tool is a reasonable 2-7x in majority of the cases.",
        "keywords": "Dynamic binary instrumentation; Localisation; Measurement; Parallel programming; Performance bugs; Profiling; Software defects",
        "released": 2015,
        "link": "https://doi.org/10.1145/2837476.2837478"
    },
    {
        "title": "Proactive performance testing using SQL performance assurance services (SQL-PASS)",
        "abstract": "The information systems are becoming more and more complex and it is very common these days where database sizes are in hundreds of GBs. Handling of such large data volumes is creating challenges for assuring the performance of end-user applications. Applications involving database transactions are worst hit as there is no clue about the time required to fetch the relevant data from the huge database. The tools available in the market and the existing methodologies are suitable for the production environment but not effective in the development environment. This creates a gap between database application development and its deployment in the production environment. Therefore assuring the performance against high volume is an indisputable problem faced by the application developer and tester.In this paper, we discuss the work done in industry to tackle the SQL performance problem arising because of large data volumes and present SQL-PASS (SQL Performance Assurance Services), a web based service developed by TCS innovation Lab – Performance engineering, which helps to validate the SQL performance against high volumes without using actual data.We will also discuss how this service has been used in the development project to assure the performance.",
        "keywords": "SQL performance; database emulation; database statistics; explain plan; extrapolation of database statistics; query execution time forecasting; query optimization",
        "released": 2011,
        "link": "https://doi.org/10.1145/1980022.1980138"
    },
    {
        "title": "From coarse-grained components to DVE applications: A service- and component-based framework",
        "abstract": "Distributed Virtual Environments (DVEs) are distributed, simulated virtual worlds where users gather and interact within a shared space. Web-based DVE applications are attracting more and more attention. However, building DVE applications requires a significant effort, even with the modern development tools. In this paper we propose a component-based and a service-based framework for constructing DVE applications from coarse-grained components. This component-based and service-oriented architecture provides a great flexibility for building complex DVE applications. Based on the developed terminology and profile, the framework provides a high level description language for specifying user interaction tasks. The DVE developers can concentrate on the application design rather than worrying about the programming details. The framework also provides a runtime platform for coarse-grained components integration and a shared scene graph for coordinating the presentation for individual users.",
        "keywords": "coarse-grained component; distributed virtual environment; framework; interaction tasks; web 3D; web services",
        "released": 2007,
        "link": "https://doi.org/10.1145/1229390.1229411"
    },
    {
        "title": "The IDE portability problem and its solution in monto",
        "abstract": "Modern IDEs support multiple programming languages via plug-ins, but developing a high-quality language plug-in is a huge development effort and individual plug-ins are not reusable in other IDEs. We call this the IDE portability problem. In this paper, we present a solution to the IDE portability problem based on a language-independent and IDE-independent intermediate representation (IR) for editor-service products. This IR enables IDE-independent language services to provide editor services for arbitrary IDEs, using language-independent IDE plug-ins. We combine the IR with a service-oriented architecture to facilitate the modular addition of language services, the decomposition of language services into smaller interdependent services, and the use of arbitrary implementation languages for services. To evaluate the feasibility of our design, we have implemented the IR and architecture in a framework called Monto. We demonstrate the generality of our design by constructing language services for Java, JavaScript, Python, and Haskell and show that they are reusable in the Eclipse IDE and in a web-based IDE. We also evaluate the performance of Monto and show that Monto is responsive and has admissible performance overhead.",
        "keywords": "integrated development environments; reusable software",
        "released": 2016,
        "link": "https://doi.org/10.1145/2997364.2997368"
    },
    {
        "title": "Reactive extensions (rx): Curing your asynchronous programming blues",
        "abstract": "Asynchronous, event-driven \"reactive\" programming is way too hard in today’s world of development tools and frameworks. The huge amount of manual and error-prone plumbing leads to incomprehensible and hard to maintain code. As we reach out to services in the cloud, the desire for asynchronous computation is ever increasing, requiring a fresh look on the problems imposed by reactive programming. Centered around the concept of observable data sources, Rx provides a framework that takes care of the hard parts of reactive programming. Instead of focusing on the hard parts, you now can start dreaming about the endless possibilities of composing queries over asynchronous data sources, piggybacking on convenient LINQ syntax. In this session, we’ll cover the design philosophy of Rx, rooted on the deep duality between the interactive IEnumerable interface and the new reactive IObservable interface in .NET 4. From this core understanding, we’ll start looking at various combinators and operators defined over observable collections, as provided by Rx, driving concepts home by a bunch of samples. Finally, if time permits, we’ll look at the Reactive Extensions for JavaScript which allows us to take the concepts we already know from Rx and apply them to JavaScript and have deep integration with libraries such as jQuery. Democratizing asynchronous programming starts today. Don’t miss out on it!",
        "keywords": "",
        "released": 2010,
        "link": "https://doi.org/10.1145/1900160.1900173"
    },
    {
        "title": "Automated analysis of student programmer coding behavior patterns (abstract only)",
        "abstract": "Important information regarding the learning experience and relative preparedness of Computer Science students can be obtained by analyzing their coding activity at a fine-grained level, using an online IDE that records student code editing, compiling, and testing activities down to the individual keystroke. We report results from analyses of student coding patterns using such an online IDE. In particular, we gather data from a group of students performing an assigned programming lab, using the online IDE indicated to gather statistics. We extract high-level statistics from the student data, and apply supervised learning techniques to identify those that are the most salient prediction of student success as measured by later performance in the class. We use these results to make predictions of course performance for another student group, and report on the reliability of those predictions",
        "keywords": "automated evaluation; coding; educational data mining; learning analytics; online ide",
        "released": 2016,
        "link": "https://doi.org/10.1145/2839509.2850540"
    },
    {
        "title": "AnnaBot: A static verifier for java annotation usage (abstract only)",
        "abstract": "A domain-specific language has been devised for verification of correct use of Annotation-based metadata in the Java programming language. Annotations are a standard Java 5 mechanism used to attach metadata to types, methods or fields without using an external configuration file. A binary representation of the Annotation becomes part of the compiled \"class\" file, for inspection by other components at run time.Java Annotations were introduced into the Java language in 2004 and have become widely used in recent years due to their introduction in the Java Enterprise Edition (EE 5) and elsewhere. Despite that, mainstream development tools have not yet produced a widely-used verification tool to confirm correct configuration and placement of annotations external to the particular runtime component. This verification becomes especially important both as annotations become more widely adopted and as multiple implementations of standards become available, such as the use of either Hibernate or EclipseLink as a \"provider\" for the Java Persistence API.It is anticipated that this software will continue to evolve as an open-source software verification tool; the web site for this project has been established as http://www.annabot.org/.",
        "keywords": "Java; annotations; assertions",
        "released": 2009,
        "link": "https://doi.org/10.1145/1555860.1555867"
    },
    {
        "title": "Topes: Reusable abstractions for validating data",
        "abstract": "Programmers often omit input validation when inputs can appear in many different formats or when validation criteria cannot be precisely specified. To enable validation in these situations, we present a new technique that puts valid inputs into a consistent format and that identifies \"questionable\" inputs which might be valid or invalid, so that these values can be double-checked by a person or a program. Our technique relies on the concept of a \"tope\", which is an application-independent abstraction describing how to recognize and transform values in a category of data. We present our definition of topes and describe a development environment that supports the implementation and use of topes. Experiments with web application and spreadsheet data indicate that using our technique improves the accuracy and reusability of validation code and also improves the effectiveness of subsequent data cleaning such as duplicate identification.",
        "keywords": "abstraction; data; validation",
        "released": 2008,
        "link": "https://doi.org/10.1145/1368088.1368090"
    },
    {
        "title": "Web-based interactive courseware for information security",
        "abstract": "Interactive courseware encourages student participation and active learning. Prior research and teaching experience has shown that IT students prefer to learn information security in a hands-on manner. How do we offer information security as a distance learning course while give students the similar hands-on teaching and learning style as we do in a traditional classroom or lab? This paper discusses our experience in developing Web-based multimedia and interactive courseware for an undergraduate information security course. The courseware is based on a simple yet powerful software tool called MICS (Multimedia and Interactive Courseware Synthesizer), designed for generating multimedia and interactive courseware for science and engineering students. We report in this paper our experience in designing such a course development tool and in using the courseware in our IT curricula.",
        "keywords": "active learning; information security; interactivity",
        "released": 2005,
        "link": "https://doi.org/10.1145/1095714.1095760"
    },
    {
        "title": "Multiprocessor performance estimation using hybrid simulation",
        "abstract": "With the growing number of programmable processing elements in today’s Multi Processor System-on-Chip (MPSoC) designs, the synergy required for the development of the hardware architecture and the software running on them is also increasing. In MPSoC development environment, changes in the hardware architecture can bring in extensive re-partitioning or re-parallelization of the software architecture. Fast and accurate functional simulation and performance estimation techniques are needed to cope with this co-design problem at the early phases of MPSoC design space exploration. The current paper addresses this issue by introducing a framework which combines hybrid simulation, cache simulation and online trace-driven replay techniques to accurately predict performance of programmable elements in an MPSoC environment. The resulting simulation technique can easily cope with the continuous re-organizations of software architectures during an Instruction Set Simulator (ISS) based design process. Experimental results show that this framework can improve system simulation speed by 3-5 on average while achieving accuracy closely comparable to traditional ISSes.",
        "keywords": "HySim; MPSoC; address recovery; cache simulation; cross replay; hybrid simulation; performance estimation",
        "released": 2008,
        "link": "https://doi.org/10.1145/1391469.1391552"
    },
    {
        "title": "A sense of touch in online sculpting",
        "abstract": "This paper describes the work-in-progress of an online multimedia tool employing the sense of touch in exploring and learning sculpting techniques to be used over the Internet. Many game applications use haptic devices as a control mechanism, yet little has been documented on the use of this controlling procedure in an educational setting. The internet based instructional device presented here has a single modeling tool accessed by a customised interface designed with widely accessible software (Macromedia Director MX™). This will be extended to a small suite of modeling tools, in progress at this time. It makes use of a simple force-feedback joystick to control a spherical tool which makes changes to the surface of a 3D model represented onscreen. It is proposed that by using this device with Flash Web Server and the Internet, the system is able to support a collaborative environment encouraging interaction between student and tutor. It is hoped this system will become a research and development tool in online education.",
        "keywords": "3D; Internet; education; haptic; multimedia",
        "released": 2004,
        "link": "https://doi.org/10.1145/988834.988855"
    },
    {
        "title": "Cultural applications for mobile devices: Issues and requirements for authoring tools and development platforms",
        "abstract": "This paper explores requirements that authoring tools and development platforms should satisfy for the development of cultural applications tailored for deployment on Personal Digital Assistants (PDAs) and mobile phones. To effectively determine such requirements the paper reviews the use of mobile technologies in the context of cultural organizations and tourism and examines three ’real world’ case studies that focus on the use of PDAs and mobile phones for providing cultural and tourist information, keeping the visitors’ interest and attention, as well as promoting various cultural organizations and tourist facilities. This approach allows the extraction of a set of PDA and mobile phone application requirements, the implementation of which is based on the apparatus offered by authoring tools and development platforms. The paper reviews and evaluates the design and development facilities provided by state-of-the-art multimedia application development tools for PDAs and mobile phones: Macromedia Flash Lite, Navipocket, Java 2 Micro Edition and Microsoft .Net platform for the Mobile Web. The paper concludes with a set of recommendations related to the way authoring tools and development platforms should be exploited in order to gratify application and designer needs for developing cultural and tourist applications",
        "keywords": "",
        "released": 2008,
        "link": "https://doi.org/10.1145/1462141.1462145"
    },
    {
        "title": "WebODE: A scalable workbench for ontological engineering",
        "abstract": "This paper presents WebODE as a workbench for ontological engineering that not only allows the collaborative edition of ontologies at the knowledge level, but also provides a scalable architecture for the development of other ontology development tools and ontology-based applications. First, we will describe the knowledge model of WebODE, which has been mainly extracted and improved from the reference model of METHONTOLOGY’s intermediate representations. Later, we will present its architecture, together with the main functionalities of the WebODE ontology editor, such as its import/export service, translation services, ontology browser, inference engine and axiom generator, and some services that have been integrated in the workbench: WebPicker, OntoMerge and the OntoCatalogue.",
        "keywords": "WebODE; integration and merge; ontology building; ontology engineering workbench; translation",
        "released": 2001,
        "link": "https://doi.org/10.1145/500737.500743"
    },
    {
        "title": "Code generation techniques for developing light-weight XML web services for embedded devices",
        "abstract": "This paper presents specialized code generation techniques and runtime optimizations for developing light-weight XML Web services for embedded devices. The optimizations are implemented in the gSOAP Web services development environment for C and C++. The system supports the industry-standard XML-based Web services protocols that are intended to deliver universal access to any networked application that supports XML. With the standardization of the Web services protocols and the availability of toolkits such as gSOAP for developing embedded Web services, new opportunities emerge to integrate embedded systems into larger frameworks of interconnected applications and systems accessing dynamic resources on the Web ranging from hand-held and embedded devices to databases, clusters, and Grids.",
        "keywords": "Web Services; XML; embedded systems; networking",
        "released": 2004,
        "link": "https://doi.org/10.1145/967900.968075"
    },
    {
        "title": "A foundation for tool based mobility support for visually impaired web users",
        "abstract": "Users make journeys through the Web. Web travel encompasses the tasks of orientation and navigation, the environment and the purpose of the journey. The ease of travel, its mobility, varies from page to page and site to site. For visually impaired users, in particular, mobility is reduced; the objects that support travel are inaccessible or missing altogether. Web development tools need to include support to increase mobility. We present a framework for finding and classifying travel objects within Web pages. The evaluation carried out has shown that this framework supports a systematic and consistent method for assessing travel upon the Web. We propose that such a framework can provide the foundation for a semi-automated tool for the support of travel upon the Web.",
        "keywords": "mobility; mobility support tool; travel; travel objects; visual impairment",
        "released": 2003,
        "link": "https://doi.org/10.1145/775152.775212"
    },
    {
        "title": "WebAda",
        "abstract": "The Ada community has used the power of the Internet to distribute computer resources and information; and most recently the World Wide Web (WWW) makes it easier to find those resources. Now, a tool called WebAda uses the Internet and the WWW to provide an interactive capability! [For the rest of this paper, I will use the term Internet to include the World Wide Web.]WebAda is an Ada development environment accessed via the World Wide Web. You don’t download the compiler or any other software! You enter programs, set switches, compile, and see results through your favorite browser. In other words, your browser is the Graphical User Interface (GUI) to WebAda.The Lovelace Tutorial took an initial step to become interactive, providing a multiple choice quiz at the end of most tutorial pages. WebAda has taken the next step with an on-line development environment which integrates Ada tools and information.One could say WebAda is to the Internet as C is to Unix, or as Basic is to DOS. When you have Internet access, you have all of the capabilities of WebAda available.",
        "keywords": "",
        "released": 1997,
        "link": "https://doi.org/10.1145/261374.261380"
    },
    {
        "title": "The convergence of computer programming and graphic design",
        "abstract": "Traditionally, computer science curricula have focused on the algorithmic development of software, while design issues such as typography, text layout, and image manipulation have been the domain of graphic design or fine arts programs. With the emergence of the Web as a publishing and programming medium, as well as the availability of high-level development tools, the distinctions between algorithm and presentation are blurring. Today, a programmer needs to understand and apply principles of graphic design in order to develop applications that are usable and attractive to the user. Likewise, a graphic designer developing electronic media must understand and apply programming principles to control the dynamic behavior of the media. This paper addresses the convergence of programming and graphic design, from both the perspectives of a computer scientist and a graphic designer. Simple and practical design principles are presented that can be integrated into a variety of computer science courses.",
        "keywords": "",
        "released": 2006,
        "link": "https://dl.acm.org/doi/10.5555/1089182.1089205"
    },
    {
        "title": "Automatic client-server partitioning of data-driven web applications",
        "abstract": "Current application development tools provide completely different programming models for the application server (e.g., Java and J2EE) and the client web browser (e.g., JavaScript and HTML). Consequently, the application developer is forced to partition the application code between the server and client at the time of writing the application. However, the partitioning of the code between the client and server may have to be changed during the evolution of the application for performance reasons (it may be better to push more functionality to the client), for correctness reasons (data that conflicts with multiple clients cannot always be pushed to clients), and for supporting clients with different computing power (browsers on desktops vs. PDAs). Since the client and server use different programming models, moving application code from client to server (and vice versa) reduces programmer productivity and also has the potential to introduce concurrency bugs. In this demonstration, we advocate an alternative solution to this problem: we propose developing applications using a unified declarative high-level language called Hilda, and show how a Hilda compiler can automatically (and correctly) partition Hilda code between the client and the server using a real Course Management System application. We illustrate our techniques using two clients: a powerful laptop machine and a less powerful PDA.",
        "keywords": "",
        "released": 2006,
        "link": "https://doi.org/10.1145/1142473.1142580"
    },
    {
        "title": "Supercomputer applications: Helping users cope with tough programming problems",
        "abstract": "Nobody ever said that Supercomputing was easy.At SDSC our mission is to provide not only supercomputer cycles, but also supercomputer support. The level of support, of course, covers a broad range. Some users just need to learn the basics: how to get their data transferred to SDSC, how to get directory listings, how to access in-house application software, etc. Other users are involved in their own code installation and/or development and need to learn about the programming environment. Most of these users can cull enough information from online documentation and brief conversations with the consultants to get their codes up and running.For others, however, life is not so easy. These people are stretching the limits of computer technology, and often a great deal of time and effort is necessary simply to get their code running. Even more effort might be needed to squeeze maximum performance from the supercomputer hardware. Providing technical assistance to these people is an important part of SDSC’s consulting operation. A consultant’s first reaction upon encountering someone with a tough problem might be to send them away with some documentation and a wish of good luck. At SDSC, however, we feel that it is a good investment for the consultant to spend the time necessary to work with the user to solve the problem. The end result is not only a solved problem for the user, but new programming techniques that the consultant can: Teach to the original user to ease that user into the world of exotic loader options, assembly language programming, and obscure library routines.Relay to the rest of the user community by way of personal communication and newsletter articles.Use in his or her own programming projects.The following two sections trace examples of the flow of information through the consulting department at SDSC. These examples provide a glimpse into the kinds of problems SDSC users encounter and how, by solving these problems, the consulting staff can benefit not only the original user, but the user community as a whole. These examples are drawn from my own personal experience, but similar examples, of course, exist for the rest of the consulting staff.",
        "keywords": "",
        "released": 1988,
        "link": "https://doi.org/10.1145/62548.62627"
    },
    {
        "title": "Research and practice of online and offline mixed teaching mode of ideological and political course in colleges",
        "abstract": "Classroom teaching of ideological and political (ide.&amp;pol.) theory courses in colleges is the main channel of ide.&amp;pol education in colleges, and informatization teaching is the focus of the current curriculum teaching reform in Chinese universities. Effective use of online teaching methods in the classroom teaching of ide.&amp;pol. theory courses in colleges, to achieve integration of traditional classroom teaching and modern information methods, to carry out mixed teaching, to stimulate classroom vitality, and to effectively improve classroom teaching of ide.&amp;pol. theory courses effectiveness is great significance.",
        "keywords": "",
        "released": 2021,
        "link": "https://doi.org/10.1145/3482632.3483041"
    },
    {
        "title": "A toolkit for assessments in introductory programming courses",
        "abstract": "Traditional paper-based exams and LMS-provided online exams for introductory programming courses are not aligned with learning objectives that emphasize problem-solving and coding skills. In this poster, we present a cloud-based assessment solution for introductory programming courses. First, we discuss the requirements and challenges of conducting frequent assessments. We then outline the functions in our online exam toolkit that allow instructors to administer versatile assessments. Instead of relying on a traditional lockdown browser, the plagiarism and cheating detection in our toolkit allows instructors to administer exams in any modern browser for face-to-face classes.",
        "keywords": "assessment; education; web ide",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545947.3576231"
    },
    {
        "title": "Beyond the language workbench: A runtime platform for practical semantic computing",
        "abstract": "domain/object is a new software environment in the tradition of dynamic languages like Smalltalk, Lisp and Self. Like its predecessors, domain/object blurs the usual distinctions between tools, languages, operating systems, applications and databases. domain/object also adds some interesting twists to the familiar dynamic paradigm, including spreadsheet-style \"liveness\", versioned execution, transactions, full incrementality and transparency.domain/object is intended as a delivery platform for software that requires tight semantic integration between components, such as development tools and next-generation applications for the semantic web. Incrementality and liveness obviate the need for standard notification schemes such as Observer, ensuring that data and programs are synchronised automatically. Transactions and versioning allow the granularity and frequency of synchronisation to be adjusted to suit the particular application or user. Transparency means that the full structure of the executing program is available for queries, suggesting a considerably more dynamic realisation of aspect-oriented programming.",
        "keywords": "dynamic aspects; incremental computation; relational programming",
        "released": 2005,
        "link": "https://doi.org/10.1145/1094855.1094881"
    },
    {
        "title": "Towards a language server protocol infrastructure for graphical modeling",
        "abstract": "The development of modern IDEs is still a challenging and time-consuming task, which requires implementing the support for language-specific features such as syntax highlighting or validation. When the IDE targets a graphical language, its development becomes even more complex due to the rendering and manipulation of the graphical notation symbols. To simplify the development of IDEs, the Language Server Protocol (LSP) proposes a decoupled approach based on language-agnostic clients and language-specific servers. LSP clients communicate changes to LSP servers, which validate and store language instances. However, LSP only addresses textual languages (i.e., character as atomic unit) and neglects the support for graphical ones (i.e., nodes/edges as atomic units). In this paper, we present our vision to decouple graphical language IDEs discussing the alternatives for integrating LSP’s ideas in their development. Moreover, we propose a novel LSP infrastructure to simplify the development of new graphical modeling tools, in which Web technologies may be used for editor front-ends while leveraging existing modeling frameworks to build language servers.",
        "keywords": "Domain Specific Languages; Language Server Protocol; Modeling Editors",
        "released": 2018,
        "link": "https://doi.org/10.1145/3239372.3239383"
    },
    {
        "title": "Learning to program through the web",
        "abstract": "Computer-based tutoring systems which assist students in solving introductory programming problems have significant potential for improving the quality of programming education and reducing the instructor’s work load. The innovative Environment for Learning to Program (ELP) provides an interactive web-based environment for teaching programming to first year Information Technology students at Queensland University of Technology (QUT). ELP allows students to undertake programming exercises by \"filling in the gaps\" of a partial computer program presented in a web page and to receive guidance in getting their programs to compile and run. Feedback on quality and correctness is provided through a program analysis framework. Students are given the opportunity to produce working programs at the early stages of their course without the need to familiarize themselves with a complex program development environment.",
        "keywords": "computer programming; feedback; flexible delivery; online learning; tutoring system; web",
        "released": 2005,
        "link": "https://doi.org/10.1145/1067445.1067452"
    },
    {
        "title": "LTSA-WS: A tool for model-based verification of web service compositions and choreography",
        "abstract": "In this paper we describe a tool for a model-based approach to verifying compositions of web service implementations. The tool supports verification of properties created from design specifications and implementation models to confirm expected results from the viewpoints of both the designer and implementer. Scenarios are modeled in UML, in the form of Message Sequence Charts (MSCs), and then compiled into the Finite State Process (FSP) process algebra to concisely model the required behavior. BPEL4WS implementations are mechanically translated to FSP to allow an equivalence trace verification process to be performed. By providing early design verification and validation, the implementation, testing and deployment of web service compositions can be eased through the understanding of the behavior exhibited by the composition. The approach is implemented as a plug-in for the Eclipse development environment providing cooperating tools for specification, formal modeling, verification and validation of the composition process.",
        "keywords": "BPEL4WS; WS-CDL; choreography; model-checking; web service compositions",
        "released": 2006,
        "link": "https://doi.org/10.1145/1134285.1134408"
    },
    {
        "title": "Performance metrics and auditing framework for high performance computer systems",
        "abstract": "This paper describes a comprehensive auditing framework, XDMoD, for use by high performance computing centers to readily provide metrics regarding resource utilization (CPU hours, job size, wait time, etc), resource performance, and the center’s impact in terms of scholarship and research. This role-based auditing framework is designed to meet the following objectives: (1) provide the user community with an easy to use tool to oversee their allocations and optimize their use of resources, (2) provide staff with easy access to performance metrics and diagnostics to monitor and tune resource performance for the benefit of the users, (3) provide senior management with a tool to easily monitor utilization, user base, and performance of resources, and (4) help ensure that the resources are effectively enabling research and scholarship. XDMoD is initially focused on the NSF TeraGrid (TG) and follow-on XSEDE (XD) program, where it will become a key component of the TG/XSEDE User Portal. However, this auditing system is intended to have a general applicability to any HPC system or center.The XDMoD auditing system is architected using a set of modular components that facilitate the utilization of community contributed components information. It includes an active and reactive (as opposed to passive) service set accessible through a variety of endpoints such as web-based user interface, RESTful web services, and provided development tools. One component also provides a computationally lightweight and flexible application kernel auditing system that reflects best-in-class performance kernels to measure overall system performance with respect to existing applications that are actually being run by users. This allows continuous resource auditing to monitor all aspects of system performance, most critically from a completely user-centric point of view.",
        "keywords": "",
        "released": 2011,
        "link": "https://doi.org/10.1145/2016741.2016759"
    },
    {
        "title": "Using a web editor as a development platform for teaching HTML and client-side programming in the internet 101 course: Nifty tools and assignments",
        "abstract": "Traditionally most courses teaching beginning website development have students using a text editor to code native HTML. This works fine for a website with a few simple pages, but once a website begins to grow this is a cumbersome and time-consuming method. A much more efficient method is to use a web editor as the development platform for such mundane tasks as file management, establishing colors (versus looking up hex codes), finding the coordinates for image maps, etc. Since web editors \"write code\" for students, some course designers have avoided them due to worries of students learning how to a web editor but not learning how to write the code it is generating. By using two textbooks-one for the web editor, and one for HTML and it’s supporting technologies of scripting and style sheets-the students can learn the best of both worlds. This is analogous to using a calculator for math or a rapid application development tool for programming. In fact, the web editor can actually be used as a learning tool for HTML. If the student is unsure of the code then he/she can perform the task in the web editor and then observe the code that was written. This method of learning has been used quite successfully and I believe an explanation and demonstration of it would give conference attendees a useful strategy for teaching website development.",
        "keywords": "",
        "released": 2008,
        "link": "https://dl.acm.org/doi/10.5555/1409763.1409785"
    },
    {
        "title": "A document-based approach to the generation of web applications",
        "abstract": "wVIEW is an automated system for generating Web applications that relies extensively on document representations and transformations. wVIEW adopts the widely accepted hypermedia design principle that content navigation and presentation are separate concerns. Each of these aspects of the design process is controlled by separate declarative specifications. Only the first specification the content structure specification which is described using UML must be provided. However the wVIEW user is free to add extensions and customizations to both the data and navigation models in order to make the final application suit specific needs. This paper describes the wVIEW approach and the current prototype which focuses on the data and navigation modelling aspects. The paper discusses experiences in using XSLT as the primary development tool and shows examples how the enhancements planned to XSLT address some limitations of the application generation process.",
        "keywords": "XML; XSLT; cocoon; design; web applications",
        "released": 2004,
        "link": "https://doi.org/10.1145/1030397.1030406"
    },
    {
        "title": "XICL: A language for the user’s interfaces development and its components",
        "abstract": "More interactivity with better usability in Web Systems requires the development of user interface components with interaction techniques that are more powerful and popular among the users such as the WIMP style. This work presents the XICL, a markup language to describe the user interface and its components. This language defines a description format and a semantic model that standardizes components programming and increase reuse, extension and portability. We also present the XICL Studio, a development environment composed of an editor, a component library and a compiler. Our proposal is based only in recommended technologies and free software.",
        "keywords": "user interface component; user interface design; user interface languages",
        "released": 2003,
        "link": "https://doi.org/10.1145/944519.944539"
    },
    {
        "title": "HACSAW: A trusted framework for cyber situational awareness",
        "abstract": "The HPC Architecture for Cyber Situational Awareness (HACSAW) was established by the Department of Defense (DoD) High Performance Computing Modernization Program (HPCMP) to combine a rich computational environment with operationally relevant data to perform cutting-edge cybersecurity research that will increase HPCMP’s current and predictive understanding of cyberspace on the Defense Research and Engineering Network (DREN). The data repository created by this unique environment includes the collection of unclassified data sources from the edge of the network (i.e., Internet Access Points) down to the host-level, across more than one hundred (100) different DoD enclaves. Through the application of high performance computing (HPC) resources, HACSAW explores novel and innovative analytical capabilities based on a comprehensive cybersecurity dataset. The integration of HPC within the cyber workflow provides an opportunity for fusion and assessments of disparate data streams and real-time analysis using data science algorithms and machine learning (both structured and unstructured data). Our approach is designed to ultimately leverage HPC resources to significantly reduce the time to respond to changes in the cyber environment from days to minutes.Understanding the operational status of information systems, the missions (friendly and adversary) being pursued, and the threats and vulnerabilities that impact them is essential for effective mission accomplishment. This understanding is referred to as Cyberspace Situational Awareness (Cyber SA). Today’s decision makers require meaningful Cyber SA to safeguard sensitive data, sustain fundamental operations, and protect national infrastructure [2]. The need and responsibility of Cyber SA spans multiple organizations within the DoD, across the entire government and in the private sector.The lack of relevant and recent real-world network enterprise data has hampered many cybersecurity research efforts to develop and validate algorithms or methods under realistic conditions. HACSAW has reduced this technical barrier with a development environment that provides computational and data-rich information to researchers to test, develop, model, measure and refine data-driven analytics. This environment is the proving ground for novel ideas, algorithms and approaches that are suitable for large scale execution in a dedicated HPC environment. Currently, HACSAW as an aggregation of over one (1) petabyte of DREN data to include network-based monitoring and intrusion detection results, web content filtering, vulnerability scanning, firewall, sensor health, etc. Context is applied to each cyber event through the use of custom enrichments that provide downstream analytical processes with information that may be useful in determining the nature of the event.During this talk, we will discuss HPCMP’s initial approach to addressing Cyber SA through a Call for Proposals (CFP) to the data science, cyber, and HPC communities. Selected collaborators will receive funding for a one-year effort that demonstrates potential for integration into DREN’s Cyber SA operational environment and aligns with identified Mission Essential Tasks (METs). METs will ensure decision makers have the understanding necessary to make effective decisions. Such tasks include monitoring, detection, alerting, cyber threat analysis, cyber risk and event analysis, and sharing and collaboration. Initial and future contributions in the areas of modeling and simulation [4], clustering [3] and deep learning [1] are anticipated and results will be shared at a later date.",
        "keywords": "",
        "released": 2018,
        "link": "https://doi.org/10.1145/3190619.3190641"
    },
    {
        "title": "Mugshot: Deterministic capture and replay for javascript applications",
        "abstract": "Mugshot is a system that captures every event in an executing JavaScript program, allowing developers to deterministically replay past executions of web applications. Replay is useful for a variety of reasons: failure analysis using debugging tools, performance evaluation, and even usability analysis of a GUI. Because Mugshot can replay every execution step that led to a failure, it is far more useful for performing root-cause analysis than today’s commonly deployed client-based error reporting systems–core dumps and stack traces can only give developers a snapshot of the system after a failure has occurred.Many logging systems require a specially instrumented execution environment like a virtual machine or a custom program interpreter. In contrast, Mugshot’s client-side component is implemented entirely in standard JavaScript, providing event capture on unmodified client browsers. Mugshot imposes low overhead in terms of storage (20-80KB/minute) and computation (slowdowns of about 7",
        "keywords": "",
        "released": 2010,
        "link": "https://dl.acm.org/doi/10.5555/1855711.1855722"
    },
    {
        "title": "Security for service oriented architectures",
        "abstract": "Most agree that applications programming is moving to the Internet. This type of application is inherently insecure, as it allows access to the server on the initial HTTP request. A fairly well thought out security strategy was developed for second generation Web applications by creating a security sand-box around the HTTP request (until the user was authenticated), then using standard server security to protect the processing and finally extending the ideas of distributed computing to secure accessing data. Web application programming is currently moving to a Service-Oriented Architecture (SOA) that includes extensive use of Web services. There is a mad rush in the UNIX world to perfect the Enterprise Service Bus (ESB) and in the Microsoft world to finish the Windows Communications Foundation (WCF). And the beauty of the SOA is that a Web application developed using WCF will be able to access data from a Java Web service. This new SOA will support a distributed application development environment that is truly vendor independent. But, while the new architecture promises to make vendor independent distributed programming a reality, it has introduced a large number of new security concerns. This tutorial will describe SOA, give a brief introduction to computer security and then present SOA security in detail.",
        "keywords": "",
        "released": 2008,
        "link": "https://dl.acm.org/doi/10.5555/1352079.1352083"
    },
    {
        "title": "Tools and approaches for developing data-intensive web applications: A survey",
        "abstract": "The exponential growth and capillar diffusion of the Web are nurturing a novel generation of applications, characterized by a direct business-to-customer relationship. The development of such applications is a hybrid between traditional IS development and Hypermedia authoring, and challenges the existing tools and approaches for software production. This paper investigates the current situation of Web development tools, both in the commercial and research fields, by identifying and characterizing different categories of solutions, evaluating their adequacy to the requirements of Web application development, enlightening open problems, and exposing possible future trends.",
        "keywords": "HTML; Intranet; WWW; application; development",
        "released": 1999,
        "link": "https://doi.org/10.1145/331499.331502"
    },
    {
        "title": "Q&amp;a MAESTRO: Q&amp;a post recommendation for fixing java runtime exceptions",
        "abstract": "Programmers often use Q&amp;A sites (e.g., Stack Overflow) to understand a root cause of program bugs. Runtime exceptions is one of such important class of bugs that is actively discussed on Stack Overflow. However, it may be difficult for beginner programmers to come up with appropriate keywords for search. Moreover, they need to switch their attentions between IDE and browser, and it is time-consuming. To overcome these difficulties, we proposed a method, \"Q&amp;A MAESTRO\", to find suitable Q&amp;A posts automatically for Java runtime exception by utilizing structure information of codes described in programming Q&amp;A website. In this paper, we describe a usage scenario of IDE-plugin, the architecture and user interface of the implementation, and results of user studies. A video is available at https://youtu.be/4X24jJrMUVw. A demo software is available at https://github.com/FujitsuLaboratories/Q-A-MAESTRO.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1109/ASE51524.2021.9678893"
    },
    {
        "title": "Implementation on remote monitoring system of oil well",
        "abstract": "With the quick development of information and network technology, and wide use of Internet, building the information publish center in Web becomes the common demand from a great number of enterprises and customers. The production and management of modern enterprises rely heavily on the enterprise information integrated platform. The mass, important, sensitive data are gathered and stored. Making full use of these data becomes an extremely important link of the enterprise development.Engineers and technicians in oil field exploration and development have an excellent attention to the production information and working status of oil-pumping machine from oil well. The field information is an important basis of the productivity evaluation of single well, dynamic analysis of reservoir engineering in region, and production plan. Mud logging information will be recorded and transferred to research and management department timely, accurately, which directly related to progress and benefit of gas and oil production. Therefore, how to use the oil well information service system to provide reliable, timely information for the superior departments has been a priority of the agenda. Data visualization on the web becomes a new focus.By studying and analyzing the oilfield data collection and visualization, the oil well information service system narrated in this paper established a relative perfect including the function of oil well data collection, transmission, and browsing online, etc. Flex provides rich components for the client development in data visualization, and the business logic layer developed by J2EE technology, which is also a good choice. The paper designs an architecture which use Flex as the present layer development tools, Spring taking charge of developing the business logic layer and Hibernate realizing the data persistence layer. It has been found that this web application based on Flex and J2EE technologies not only can provide an excellent visual picture but also express the abundant user experience and perfect human-machine interaction. It also has the characters of good maintainability and expansibility resulted by the integration of Hibernate and Spring. This developing structure enhances the integration capabilities, optimizes the efficiency, meets the requirements of mud logging data which is large and fast growth, and processes the sophisticated business logic.",
        "keywords": "data transmission; oil well monitoring; technical framework; web graph publication",
        "released": 2011,
        "link": "https://doi.org/10.1145/2071639.2071645"
    },
    {
        "title": "A web based environment for learning to program",
        "abstract": "The purpose of this paper is to describe in detail the current development status of the innovative Environment for Learning to Program (ELP) which provides an interactive web-based environment for teaching programming to the first year Information Technology students at Queensland University of Technology (QUT). ELP allows students to program at the early stages of their course without the need to familiarize themselves with a program development environment. Most importantly, it eliminates all the difficulties associated with installing and running a Java compiler. Using ELP, students learn and develop their problem solving skills by working with program template exercises on the web. ELP provides a learning environment which meets the diverse needs of students.",
        "keywords": "Java; XML; computer programming; online learning; tutoring system; web",
        "released": 2003,
        "link": "https://dl.acm.org/doi/10.5555/783106.783135"
    },
    {
        "title": "Integration of text-based applications into service-oriented architectures for transnational digital government",
        "abstract": "Significant efforts are currently being pursued by several countries and IT providers to deploy SOA (Service Oriented Architecture) designs of digital government systems that integrate or implement workflows of multiple software services and data sources. Unfortunately, many existing applications that can be useful in digital government are not implemented as Web Services, a fact that complicates their integration and interoperation within SOAs. To address this problem, this paper presents an approach to easily wrap text-based applications into Web Services. Compared to other application-wrapping approaches, this paper’s solution exposes a simpler interface to users, completely hiding the complexities of understanding and developing Web Services. The approach is motivated by, and effective for, the important case of interactive applications, which is harder than batch-oriented applications and has not been considered by other approaches or software development environments. The paper briefly reviews a transnational digital government (TDG) project that requires interoperation and integration of independently developed geographically distributed information processing tools. The characteristics of SOAs are briefly described, along with their suitability for TDG systems and how they can be developed and deployed. The applications underlying the services needed for TDG are introduced and their SOA-relevant characteristics are identified. A framework is described for turning these applications into Web Services that are secure, support interactivity as needed, and do not constrain application functionality. The use of this framework and the evaluation of its benefits are described in the context of the deployment of application services needed by the TDG project.",
        "keywords": "system integration; system interoperability; system management; transnational information system",
        "released": 2007,
        "link": "https://dl.acm.org/doi/10.5555/1248460.1248478"
    },
    {
        "title": "A modern computational linguistics course using dutch",
        "abstract": "This paper describes material for a course in computational linguistics which concentrates on building (parts of) realistic language technology applications for Dutch. We present an overview of the reasons for developing new material, rather than using existing text-books. Next we present an overview of the course in the form of six exercises, covering advanced use of finite state methods, grammar development, and natural language interfaces. The exercises emphasise the benefits of special-purpose development tools, the importance of testing on realistic data-sets, and the possibilities for web-applications based on natural language processing.",
        "keywords": "",
        "released": 1999,
        "link": "https://dl.acm.org/doi/10.5555/1708112.1708115"
    },
    {
        "title": "DryadLINQ: A system for general-purpose distributed data-parallel computing using a high-level language",
        "abstract": "DryadLINQ is a system and a set of language extensions that enable a new programming model for large scale distributed computing. It generalizes previous execution environments such as SQL, MapReduce, and Dryad in two ways: by adopting an expressive data model of strongly typed .NET objects; and by supporting general-purpose imperative and declarative operations on datasets within a traditional high-level programming language.A DryadLINQ program is a sequential program composed of LINQ expressions performing arbitrary side-effect-free transformations on datasets, and can be written and debugged using standard .NET development tools. The DryadLINQ system automatically and transparently translates the data-parallel portions of the program into a distributed execution plan which is passed to the Dryad execution platform. Dryad, which has been in continuous operation for several years on production clusters made up of thousands of computers, ensures efficient, reliable execution of this plan.We describe the implementation of the DryadLINQ compiler and runtime. We evaluate DryadLINQ on a varied set of programs drawn from domains such as web-graph analysis, large-scale log mining, and machine learning. We show that excellent absolute performance can be attained–a general-purpose sort of 1012 Bytes of data executes in 319 seconds on a 240-computer, 960- disk cluster–as well as demonstrating near-linear scaling of execution time on representative applications as we vary the number of computers used for a job.",
        "keywords": "",
        "released": 2008,
        "link": "https://dl.acm.org/doi/10.5555/1855741.1855742"
    },
    {
        "title": "Automated migration of EuGENia graphical editors to the web",
        "abstract": "Domain-specific languages (DSLs) are languages tailored for particular domains. Many frameworks and tools have been proposed to develop editors for DSLs, especially for desktop IDEs, like Eclipse.We are witnessing the advent of low-code development platforms, which are cloud-based environments supporting rapid application development by using graphical languages and forms. While this approach is very promising, the creation of new low-code platforms may require the migration of existing desktop-based editors to the web. However, this is a technically challenging task.To fill this gap, we present ROCCO, a tool that migrates Eclipse-based graphical modelling editors to the web, to facilitate their integration with low-code platforms. The tool reads a meta-model annotated with EuGENia annotations, and generates a web editor using the DPG web framework used by the UGROUND company. In this paper, we present the approach, including tool support and an evaluation based on migrating nine editors created by third parties, which shows the usefulness of the tool.",
        "keywords": "graphical DSLs; low-code platforms; model-driven engineering",
        "released": 2020,
        "link": "https://doi.org/10.1145/3417990.3420205"
    },
    {
        "title": "One XP experience: Introducing agile (XP) software development into a culture that is willing but not ready",
        "abstract": "The main question to be asked is \"Does Extreme Programming (XP) make sense as a development methodology in a diverse, multidisciplinary web development environment? This environment includes diverse, and perhaps, distributed teams requiring close coordination with multidisciplinary skills – information architecture, visual design, XML, Java and others. The potential is to make the development process more responsive to users’ needs and changing business requirements. This could have high impact on outcomes of the development process, decreasing cost, decreasing time to deployment, and increasing user satisfaction. The challenges are to adapt and reconcile the corporate and the agile culture processes and methodologies without seriously compromising either. We will discuss our experience from conception into implementation of XP through the first release that incorporates several iteration cycles. We will discuss the positive and negative forces and how they have or have not been resolved to date.",
        "keywords": "",
        "released": 2004,
        "link": "https://dl.acm.org/doi/10.5555/1034914.1034933"
    },
    {
        "title": "Yet, more web exercises for learning c++",
        "abstract": "This paper describes a set of author developed interactive web exercises and a development environment designed to facilitate language acquisition in a beginning course in C++. The exercises test the students’ understanding of several C++ language constructs as well as general programming concepts such as scope of variables. The environment allows students to write and test sections of code in a instructor controlled setting. Together the exercises and environment can be used to enhance computer science education for both traditional and distance learning students. The paradigm of generalization and automation of standard exercises can be extended to facilitate web education in other courses.",
        "keywords": "",
        "released": 2000,
        "link": "https://doi.org/10.1145/330908.331872"
    },
    {
        "title": "iCAP: A classroom engagement tool for introductory programming courses",
        "abstract": "In this poster, we present iCAP (In Class Activity Participation), an Audience Response System (ARS) for student engagement during introductory programming lectures. iCAP is a web-based solution, allowing student access from any laptop, tablet, or phone with access to a modern browser. Therefore, iCAP increases the flexibility and convenience of educator-student interaction. This poster introduces iCAP’s functionalities and compares student mastery of learning outcomes among students taught with and without question-based learning methodology.",
        "keywords": "audience response system; classroom engagement; web ide",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545947.3576297"
    },
    {
        "title": "Towards automated generation of PO-based WebDriver test suites from selenium IDE recordings",
        "abstract": "Modern web applications require long quality assurance sessions to be appreciated by users. Test automation reduces delivery times but requires the development of effective and maintainable test scripts so that the advantages of its use are not lost. The usage of the Page object (PO) pattern has proven to be very effective in GUI testing, however, the manual development of Page objects, a sort of web page facade exposing methods to the test scripts, requires a relevant effort, which is often only repaid during evolution. In this paper, we describe a novel approach, almost totally automated, that takes advantage of the features offered by Selenium IDE for generating more maintainable Selenium WebDriver test scripts and Page objects for web applications. The only manual step required to the tester/developer is to add comments to the Selenese produced by Selenium IDE during registrations through a plugin. The very first estimate we conducted to evaluate our tool-based approach appears to be promising.",
        "keywords": "Automated generation; Page Objects; Selenium IDE and WebDriver; Test Automation",
        "released": 2021,
        "link": "https://doi.org/10.1145/3472672.3473953"
    },
    {
        "title": "Z modernization open tools showcase",
        "abstract": "Z Modernization Open Tools Showcase is a collection of multiple demos and use-cases built into a single environment, illustrating how to configure and debug transactions in seconds. What’s more exciting, it brings support to developers first choice IDEs including VS Code. With modern tools to existing z/OS workloads, developers can start interacting with z/OS like we would any other cloud environment.",
        "keywords": "VS Code; debugger; mainframe; z/OS",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3432601.3432646"
    },
    {
        "title": "HyperWeb: A framework for hypermedia-based environments",
        "abstract": "Software productivity and quality will increase as we improve our model of software and develop tools to support that model. Development environments must take into account that software is more than source; that it is more than text; and that it forms a highly interconnected web of information. Because more time is spent understanding and maintaining software than creating it, environments should strongly support browsing and reading. Finally, environments must be easy to customize.In this paper we present HyperWeb, a framework that supports the construction of hypermedia-based software development environments having this richer view of software. It coordinates the activities of an integrated set of tools through a message server, uses an object-oriented database to store software artifacts, and supports hypermedia linking of these software artifacts. It is built around an interpreter for a general purpose scripting language, allowing for very flexible customization and environment building. We also describe our experience in using it to build an environment that supports software design, development and maintenance on Unix. Its primary features include support for document linking, source code annotation and restructuring, and modification request tracking. It is being used and evaluated internally and at several external sites.",
        "keywords": "",
        "released": 1992,
        "link": "https://doi.org/10.1145/142868.142899"
    },
    {
        "title": "UVLS: A language server protocol for UVL",
        "abstract": "The Universal Variability Language (UVL) is a community-driven textual format for feature models. Over the last few years, UVL has been integrated into several relevant product-line tools. One of UVLs major advantages is its manual readability and editability. Still, without automated support it is hard to overview larger UVL models. We implemented a language server protocol (LSP) that includes syntactical and semantic analyses of UVL files. The LSP comes with several handy features to make textual editing of UVL more convenient, such as syntax checks and anomaly detection. Furthermore, the LSP supports the configuration of UVL files in a web-based editor with decision propagation. The reasoning engine supports constraints with a high level of expressiveness, such as numerical and string features. Due to the generic interface of LSPs, UVL can be integrated into modern IDEs with only small efforts. We already integrated the LSP into Visual Studio Code and NeoVim.",
        "keywords": "feature modeling; language server protocol; variability language",
        "released": 2023,
        "link": "https://doi.org/10.1145/3579028.3609014"
    },
    {
        "title": "SmartCLIDE: Shortening the toolchain of SOA-based cloud software development by automating service creation, composition, testing, and deployment",
        "abstract": "Nowadays the majority of cloud applications are developed based on the Service-Oriented Architecture (SOA) paradigm. Large-scale applications are structured as a collection of well-integrated services that are deployed in public, private or hybrid cloud. Despite the inherent benefits that service-based cloud development provides, the process is far from trivial, in the sense that it requires the software engineer to be (at least) comfortable with the use of various technologies in the long cloud development toolchain: programming in various languages, testing tools, build / CI tools, repositories, deployment mechanisms, etc. In this paper, we propose an approach and corresponding toolkit (termed SmartCLIDE—as part of the results of an EU-funded research project) for facilitating SOA-based software development for the cloud, by extending a well-known cloud IDE from Eclipse. The approach aims at shortening the toolchain for cloud development, hiding the process complexity and lowering the required level of knowledge from software engineers. The approach and tool underwent an initial validation from professional cloud software developers. The results underline the potential of such an automation approach, as well as the usability of the research prototype, opening further research opportunities and providing benefits for practitioners.",
        "keywords": "Automated Software Engineering; Cloud Software Development; Service-Oriented Architecture",
        "released": 2022,
        "link": "https://doi.org/10.1145/3503823.3503880"
    },
    {
        "title": "Measuring program comprehension: A large-scale field study with professionals",
        "abstract": "During software development and maintenance, developers spend a considerable amount of time on program comprehension. Previous studies show that program comprehension takes up as much as half of a developer’s time. However, most of these studies are performed in a controlled setting, or with a small number of participants, and investigate the program comprehension activities only within the IDEs. However, developers’ program comprehension activities go well beyond their IDE interactions.In this paper [1], we perform a more realistic investigation of program comprehension activities. To do this, we extend our ActivitySpace framework to collect and analyze Human-Computer Interaction (HCI) data across many applications (not just the IDEs). We collect 3,148 working hour data from 78 professional developers in a field study. We follow Minelli et al.’s approach to assign developers’ activities into four categories: navigation, editing, comprehension, and other. Then we measure comprehension time by calculating the time that developers spend on program comprehension. We find that on average developers spend   58",
        "keywords": "field study; inference model; program comprehension",
        "released": 2018,
        "link": "https://doi.org/10.1145/3180155.3182538"
    },
    {
        "title": "A transformer-based approach for smart invocation of automatic code completion",
        "abstract": "Transformer-based language models are highly effective for code completion, with much research dedicated to enhancing the content of these completions. Despite their effectiveness, these models come with high operational costs and can be intrusive, especially when they suggest too often and interrupt developers who are concentrating on their work. Current research largely overlooks how these models interact with developers in practice and neglects to address when a developer should receive completion suggestions. To tackle this issue, we developed a machine learning model that can accurately predict when to invoke a code completion tool given the code context and available telemetry data.To do so, we collect a dataset of 200k developer interactions with our cross-IDE code completion plugin and train several invocation filtering models. Our results indicate that our small-scale transformer model significantly outperforms the baseline while maintaining low enough latency. We further explore the search space for integrating additional telemetry data into a pre-trained transformer directly and obtain promising results. To further demonstrate our approach’s practical potential, we deployed the model in an online environment with 34 developers and provided real-world insights based on 74k actual invocations.",
        "keywords": "Code Completion; IDE; Interaction; Transformers; Usability",
        "released": 2024,
        "link": "https://doi.org/10.1145/3664646.3664760"
    },
    {
        "title": "Experience with integrating java with new technologies: C#, XML and web services",
        "abstract": "Java programmers cannot but be aware of Microsoft’s new initiative - a complete language, network environment, and a host of supporting technologies under the title of C# .NET. We highlight the advantages of C# by presenting our experiences connecting it to Java in three ways. The first is by providing a platform and language-independent XML-based API called Views for developing programmer-controlled GUIs. Views does not need C#’s resource-intensive Visual Studio development environment, and is also targeted for Unix. The second provides evidence that C# can be linked to Java at the source code level, albeit through C++ wrappers. The third is a means for retaining the useful applet feature of Java in a server-side architecture of .NET’s web services. We conclude that many common shared technologies bring Java and C# together and innovative ways of using others will open up opportunities not hitherto imagined.",
        "keywords": "C#; GUIs; Java; platform integration",
        "released": 2002,
        "link": "https://doi.org/10.1145/583810.583837"
    },
    {
        "title": "How a service-oriented architecture may change the software development process",
        "abstract": "IntroductionSoftware development practices have evolved substantially during the past decade. As so called \"agile\" approaches have gained more acceptance and applications have become progressively more distributed in terms of their physical execution and the development of components, the service-oriented approach to IT architecture has become an important alternative to traditional software development. Another impetus for the trend to a Service-Oriented Architecture (SOA) is provided by enterprise system vendors as they are incorporating the service-oriented paradigm into their products. Substantial efforts related to open standards (such as Web service standards) and open source products (such as open source enterprise service bus, development tools) are further driving a service-oriented approach for information systems.A key question is whether SOA adopters are going to be ready for this change and whether they can provide a technical and an organizational environment in which SOA-related technologies can be leveraged to their full potential. There is some indication that currently this may not be the case. In fact, some organizations that have embarked on SOA-related projects early have experienced disappointments. As with other technology waves, the important question is not whether SOA is inherently a good or a bad idea, but rather how it can be done right in a given context. This article tries to answer this question with respect to the software development process.While much of the literature, both in academia and industry, has focused on business implications of SOA, technological realization, architectural issues, and implementation guidelines, few publications have addressed the impact of SOA on the software development process and its methodology. As with any organizational change, modifications to software development processes or practices entail switching cost. Therefore, individuals as well as organizations are inclined to stay with \"proven\" methodologies, although adjustments based on task requirements and technology characteristics should be key drivers for the methodology choice and are needed to help adopters leverage the full potential of SOA.This article examines the differences and discusses which parts of development process and methodology may require adjustments to effectively leverage a SOA. It presents the results of a field study suggesting changes to software development practices that are necessary to accommodate the unique properties of the service-oriented approach.",
        "keywords": "",
        "released": 2010,
        "link": "https://doi.org/10.1145/1787234.1787269"
    },
    {
        "title": "Early reliability assessment of UML based software models",
        "abstract": "The ability to validate software systems early in the development lifecycle is becoming crucial. While early validation of functional requirements is supported by well known approaches, the validation of non-functional requirements, such as reliability, is not. Early assessment of non-functional requirements can be facilitated by automated transformation of software models into (mathematical) notations suitable for validation. These type of validation approaches are usually as \"transparent\" to the developers as possible. Consequently, most software developers find them user friendly and easy to adopt.In this paper we introduce a methodology that starts with the analysis of the UML model of software architecture followed by the bayesian framework for reliability prediction. We utilize three different types of UML diagrams: Use Case, Sequence and Deployment diagrams. They are annotated with reliability related attributes. Unlike traditional reliability growth models, which are applicable late in the lifecycle, our approach bases system reliability prediction on component and connector failure rates. In mature development environments, these may be available as the result of reuse. Throughout the lifecycle, as the developers improve their understanding of failure rates and their operational usage, system reliability prediction becomes more precise. We demonstrate the approach through a case study based on a simple web-based transaction processing system.",
        "keywords": "UML models; bayesian reliability prediction; component based systems; reliability assessment",
        "released": 2002,
        "link": "https://doi.org/10.1145/584369.584415"
    },
    {
        "title": "Language models for code completion: A practical evaluation",
        "abstract": "Transformer-based language models for automatic code completion have shown great promise so far, yet the evaluation of these models rarely uses real data. This study provides both quantitative and qualitative assessments of three public code language models when completing real-world code. We first developed an open-source IDE extension, Code4Me, for the online evaluation of the models. We collected real auto-completion usage data for over a year from more than 1200 users, resulting in over 600K valid completions. These models were then evaluated using six standard metrics across twelve programming languages. Next, we conducted a qualitative study of 1690 real-world completion requests to identify the reasons behind the poor model performance. A comparative analysis of the models’ performance in online and offline settings was also performed, using benchmark synthetic datasets and two masking strategies.Our findings suggest that while developers utilize code completion across various languages, the best results are achieved for mainstream languages such as Python and Java. InCoder outperformed the other models across all programming languages, highlighting the significance of training data and objectives. Our study also revealed that offline evaluations do not accurately reflect real-world scenarios. Upon qualitative analysis of the models’ predictions, we found that 66.3",
        "keywords": "automatic code completion; transformers; language models; IDE; evaluation; open source; InCoder; UniXcoder; CodeGPT",
        "released": 2024,
        "link": "https://doi.org/10.1145/3597503.3639138"
    },
    {
        "title": "Enhancing DrRacket with dodona for learning scheme",
        "abstract": "Learning how to program in a typical setting is challenging because feedback can often not be given immediately. Tracking the work of a student is also challenging for teachers, as the work of a student is not readily accessible. Therefore, digital learning environments have been considered to facilitate the learning process. We aim to facilitate the learning process of beginner students learning Scheme. To this end, we have developed a plugin for the DrRacket IDE (used for Scheme), that communicates with Dodona, a web service geared towards helping students learn how to code. Our plugin uses the information provided by this platform to give students immediate feedback on their code inside the DrRacket IDE. To enable the above, we extended the Dodona platform to support Scheme. As part of our extensions, we introduced several dynamic and static analyses to the Dodona platform, which we use to verify additional properties of the code submitted by students.",
        "keywords": "Dodona coding platform; DrRacket plugin; learning Scheme",
        "released": 2022,
        "link": "https://doi.org/10.1145/3532512.3564142"
    },
    {
        "title": "’E-science and cyberinfrastructure: A middleware perspective’",
        "abstract": "The Internet was the inspiration of J.C.R.Licklider when he was at the Advanced Research Projects Agency in the 1960’s. In those pre-Moore’s Law days, Licklider imagined a future in which researchers could access and use computers and data from anywhere in the world. Today, as everyone knows, the killer applications for the Internet were email in the 1970’s and the World Wide Web in the 1990’s which was developed initially as a collaboration tool for the particle physics academic community. In the future, frontier research in many fields will increasingly require the collaboration of globally distributed groups of researchers needing access to distributed computing, data resources and support for remote access to expensive, multi-national specialized facilities such as telescopes and accelerators or specialist data archives. In the context of science and engineering, this is the ’e-Science’ agenda. Robust middleware services deployed on top of research networks will constitute a powerful ’Cyberinfrastructure’ for collaborative science and engineering.This talk will review the elements of this vision and describe the present status of efforts to build such an internet-scale distributed infrastructure based on Web Services. The goal is to provide robust middleware components that will allow scientists and engineers to routinely construct the inter-organizational ’Virtual Organizations’. Given the present state of Web Services, we argue for the need to define such Virtual Organization ’Grid’ services on well-established Web Service specifications that are widely supported by the IT industry. Only industry can provide the necessary tooling and development environments to enable widespread adoption of such Grid services. Extensions to these basic Grid services can be added as more Web Services mature and the research community has had the opportunity to experiment with new services providing potentially useful new functionalities. The new Cyberinfrastructure will be of relevance to more than just the research community: it will impact both the e-learning and digital library communities allow the creation of scientific ’mash-ups’ of services giving significant added value.",
        "keywords": "",
        "released": 2006,
        "link": "https://doi.org/10.1145/1135777.1135780"
    },
    {
        "title": "Business process management (BPM) in a day",
        "abstract": "Collaboration is the key to agility today; make the most of all of your resources. In the business process management software market, those resources are typically business users and technical users. The business user is focused on optimizing the flow of a business process. Technical users, who are typically developers, are interested in optimizing and automating tasks in the business process with applications.This hands-on workshop showed attendees how to develop business processes rapidly as a business user such as a business analyst and how to use tools to implement services needed by the same business process as a technical user. A key aspect of modern business is the emergence of standards, which allow corporations to create platform independent and vendor neutral business solutions. The workshop began with an overview of some standards like the Business Process Modeling Notation (BPMN) used to design processes. The Web Services Description Language (WSDL) was presented as the one to create interoperable services. The Business Process Execution Language (BPEL) was shown as the means to create standard business processes. Similarly, service oriented architecture (SOA) was described as the backbone to these standards.As explained, these standards come built in when a user works with the Business Process Manager tools. In other words, when someone builds a business process with the tools in the product, the output generated already conforms to these industry standards. The participants examined the three layers of a process: business integration, services and implementation. The separation of a business process in the business integration layer from its implementation is the key to understanding the portability of business processes. It also explains how services which comprise a business process can interact even though they are implemented in a variety of languages and run on a variety of servers in a variety of locations.While the focus of the workshop surrounds technology, the financial forces driving the move to business process management software were presented as well. Businesses must operate at optimal efficiency, must automate processes wherever possible, and be wary of the financial implications if software is not vendor and platform neutral. Interoperability and scalability may sound like technical terms, but as this workshop showed, business needs are what drive technologies like business process management. Putting everything together, the workshop participants were told of Johansson’s definition of a business process: A set of linked activities that take an input and transform it to create an output. Ideally, the transformation that occurs in the process should add value to the input and create an output that is more useful and effective to the recipient either upstream or downstream.The first exercise showed CASCON participants how to rapidly create a business process using Process Designer. This visual tool made outlining a sequence of services fast and easy by setting up conditions when business process may go one way or another depending on runtime events. A process application was defined in the Process Center. A process application is like a project container for business processes; participants had to think through some design issues. Business processes can get big and complex quickly. Thus, design decisions are important as poor ones will lead to usability and performance problems. Participants learned to assemble activities before the implementation and add decision points where a business process might change at run time. They learned to wire the services together and added variables to pass data around the business process. They learned how to develop a service top down: defining it in Process Designer and then, as an IT person might, implement the service in another tool, Integration Designer. The service was an Advanced Integration Service, a service that has its design in Process Designer and its implementation in another component, Integration Designer.Furthermore, participants also spent time with the Coach, an assistant that helps users design effective user interfaces. The test tool known as the Inspector was used to test the CASCON participants’ partially completed business process. Once tested, they learned how to version a business process by taking a snapshot. A snapshot captures the state of a business process at a point in time.In the next part of the workshop, participants were told how to reuse services they already had; this is known as a bottom up approach. Key concepts like using association were discussed. Association means connecting your existing application with the business process. Additionally, library mirroring was discussed. With library mirroring, one can push already written programs into a business process shared by different development environments. Once the library is updated, the changes to that library are made available to both Process Designer and Integration Designer. Workshop participants were shown how to make interfaces in their existing applications in Integration Developer visible using library mirroring to the Process Designer user. Finally, the participants put these ideas to work in the second exercise and tested it again with the Inspector, where a snapshot was taken.In the next lecture and final exercise, CASCON participants learned about bindings, imports, exports and mediations - important ideas to know when developing sophisticated business processes that work with a variety of external systems resulting in the need to handle different data formats dynamically. This exercise had the CASCON participants working with complex types, which are a common way of passing structured XML data objects. Complex types are also called business objects. In a section on mediation, they used Integration Designer’s mapper to map one kind of data element in one system to another kind of data element from another system. They also used Business Process Manager’s mediation editor to handle faults, as failures in a system can happen at any time. If a failure does occur, a message needs to be returned to the business process immediately. The Inspector was used again to test the complete business process. The user interface that CASCON participants developed included a generated email note that made use of information found in the business objects. Another snapshot of their work was taken.The workshop concluded with a presentation on some things missed, such as adapters, messaging systems, monitoring and debugging, as well as a recap of the day’s work. A list of helpful books and articles on this rapidly growing area were provided.The participants used Business Process Manager Advanced 8.0. This all-inclusive development environment used Process Designer, a design tool; Integration Designer, a tool to build sophisticated services; and the Process Center, an easy-to-use test and runtime environment.",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2399776.2399805"
    },
    {
        "title": "An aspect-oriented infrastructure for a typed, stack-based, intermediate assembly language",
        "abstract": "While traditional, one-dimensional approaches to the problem of separation of concerns have been adequate for current software development, they are often brittle and resistant to evolutionary change. Aspects and aspect-orientation offer a controllable, modular mechanism for describing the separation of concerns that are orthogonal to the object model that is the primary developmental focus of a wide range of software applications. This dissertation research project involves the creation of an aspect-oriented infrastructure to support a variety of software development tools. Use of this infrastructure is demonstrated in domain areas such as ecological modeling software and web development in order to establish aspect-orientation as a feasible and straightforward solution to the problem of separation of concerns in object-oriented software systems. In the process of establishing the viability of the aspect-oriented solution, this dissertation investigates several new directions in aspect-orientation: aspects in system software, language independent aspects, aspect integration techniques, and opportunities for aspect reuse. In comparing the two-dimensional, aspect-oriented approach to the traditional, one-dimensional approach, the assertion of this research is that a two-dimensional approach offers an inherently more flexible software system while maintaining the advantages of modularity and code reuse that have long been ascribed to object-oriented systems.",
        "keywords": "aspect weaver; aspect-oriented programming; aspects; common intermediate language (CIL); compile-time; components; ecological modeling; preprocessors; runtime; separation of concerns; weave-time",
        "released": 2002,
        "link": "https://doi.org/10.1145/985072.985076"
    },
    {
        "title": "Predicting developers’ IDE commands with machine learning",
        "abstract": "When a developer is writing code they are usually focused and in a state-of-mind which some refer to as flow. Breaking out of this flow can cause the developer to lose their train of thought and have to start their thought process from the beginning. This loss of thought can be caused by interruptions and sometimes slow IDE interactions. Predictive functionality has been harnessed in user applications to speed up load times, such as in Google Chrome’s browser which has a feature called \"Predicting Network Actions\". This will pre-load web-pages that the user is most likely to click through. This mitigates the interruption that load times can introduce. In this paper we seek to make the first step towards predicting user commands in the IDE. Using the MSR 2018 Challenge Data of over 3000 developer session and over 10 million recorded events, we analyze and cleanse the data to be parsed into event series, which can then be used to train a variety of machine learning models, including a neural network, to predict user induced commands. Our highest performing model is able to obtain a 5 cross-fold validation prediction accuracy of 64",
        "keywords": "IDE monitoring; developer commands; machine learning; neural network",
        "released": 2018,
        "link": "https://doi.org/10.1145/3196398.3196459"
    },
    {
        "title": "Utilizing CPTOnline to upgrade the computer and information technology curriculum",
        "abstract": "A common problem for the keepers of computer and information technology curriculums is the blending of e-commerce courses into the core curriculum. Certainly some of the core principles of technology-based programs hold up reasonably well regardless of the environment but the emergence of the Web as a development environment has created both new opportunities and new challenges for educators at all levels. Compounding this challenge is attempting to upgrade curriculum in a cost-effective manner.The Computer and Information Technology Department (CIT) found an answer to both of these dilemmas through the creation of CPTOnline, the on-line branch of CIT. CPTOnline has packaged the department’s Web-based offerings into two online Certificate programs. For the 2002 calendar year, CPTOnline generated over 3200 credit hours. This represents almost 20",
        "keywords": "CIT; CPTOnline; certificate; curriculum; e-commerce; web-based",
        "released": 2003,
        "link": "https://doi.org/10.1145/947121.947163"
    },
    {
        "title": "Combinatorial testing approach for cloud mobility service",
        "abstract": "Currently, software product becomes an essential component in running many stakeholders’ activities. For instance, the industries mostly use cloud services to execute their important business functionality. However, by a few input’s parameter interacting, this functionality can be pended. Such constraint poses challenging to cover various features of failure especially in ensuring cloud application. One way is to devise a strategy to cover input parameters’ characteristics based on Combinatorial testing approach. This technique includes all possible combinations of test inputs for detecting bugs on the System Under Test (SUT). The paper explains the Combinatorial covering arrays to generate relatively exhaustive testing by modeling features of sample services using Feature IDE plugin in Eclipse IDE. This way, we build the input domain model to represent coverage of the existing mobility service running on NEMo Mobility cloud platform. Using this model, covering arrays is applied to generate t-way test cases by leveraging IPOg algorithm, which is implemented in a CiTLab. As a test case management, the JUnit testing framework uses test stubs to validate the test methods of generated test cases on the specified service (SUT).",
        "keywords": "CiTLAB; Cloud Mobility Service; Combinatorial Testing; Feature Model; Software Testing",
        "released": 2020,
        "link": "https://doi.org/10.1145/3375959.3375967"
    },
    {
        "title": "Colaroid: A literate programming approach for authoring explorable multi-stage tutorials",
        "abstract": "Multi-stage programming tutorials are key learning resources for programmers, using progressive incremental steps to teach them how to build larger software systems. A good multi-stage tutorial describes the code clearly, explains the rationale and code changes for each step, and allows readers to experiment as they work through the tutorial. In practice, it is time-consuming for authors to create tutorials with these attributes. In this paper, we introduce Colaroid, an interactive authoring tool for creating high quality multi-stage tutorials. Colaroid tutorials are augmented computational notebooks, where snippets and outputs represent a snapshot of a project, with source code differences highlighted, complete source code context for each snippet, and the ability to load and tinker with any stage of the project in a linked IDE. In two laboratory studies, we found Colaroid makes it easy to create multi-stage tutorials, while offering advantages to readers compared to video and web-based tutorials.",
        "keywords": "computational notebooks; instruction; programming; tutorials",
        "released": 2023,
        "link": "https://doi.org/10.1145/3544548.3581525"
    },
    {
        "title": "Supporting software developers with a holistic recommender system",
        "abstract": "The promise of recommender systems is to provide intelligent support to developers during their programming tasks. Such support ranges from suggesting program entities to taking into account pertinent Q&amp;A pages. However, current recommender systems limit the context analysis to change history and developers’ activities in the IDE, without considering what a developer has already consulted or perused, e.g., by performing searches from the Web browser. Given the faceted nature of many programming tasks, and the incompleteness of the information provided by a single artifact, several heterogeneous resources are required to obtain the broader picture needed by a developer to accomplish a task.We present Libra, a holistic recommender system. It supports the process of searching and navigating the information needed by constructing a holistic meta-information model of the resources perused by a developer, analyzing their semantic relationships, and augmenting the web browser with a dedicated interactive navigation chart. The quantitative and qualitative evaluation of Libra provides evidence that a holistic analysis of a developer’s information context can indeed offer comprehensive and contextualized support to information navigation and retrieval during software development.",
        "keywords": "mining unstructured data; recommender systems",
        "released": 2017,
        "link": "https://doi.org/10.1109/ICSE.2017.17"
    },
    {
        "title": "Supporting project awareness on the WWW with the iScent framework",
        "abstract": "Supporting project awareness in the context of large-scale software development is difficult. One problem is identifying appropriate abstractions and techniques that support the insertion of project awareness mechanisms into a software development environment with minimal impact. An additional problem is scaling project awareness mechanisms to handle the demands of large software development projects. The Web is increasingly being used to support software engineering and, as such, becomes an additional target for project awareness mechanisms with its own unique challenges. To maintain awareness of information evolving on an Internet scale, and to address the problems and challenges mentioned above, we present a framework to support awareness and intersubjectivity among software team members through the use of automatically collected, hypermedia-enabled event trails. The concepts, techniques, and tools of event notification and open hypermedia are used to support a new project awareness framework. A distinction of this framework is the presence of mechanisms that explicitly support intersubjectivity among team members and the use of event trails as a new abstraction for providing project awareness information.",
        "keywords": "",
        "released": 2000,
        "link": "https://doi.org/10.1145/605647.605650"
    },
    {
        "title": "Formalization IDEs integrated with a verifying compiler",
        "abstract": "This demonstration will illustrate both a web- and desktop-based formalization IDE (F-IDE) that are backed by a verifying compiler for the RESOLVE specification and programming language. Each IDE we demo supports construction of mathematical developments, formal interface specifications of generic, object-based concepts, and alternative implementations annotated with internal assertions to enable verification. While the first portion of the demo will illustrate the language and verification in the context of the web-based environment, the second half will demonstrate features of a newer desktop-based IDE that provides additional modern IDE amenities beyond those offered by the web-based version. Each IDE we present integrates feedback for mathematical and programmatic type checking, proving, among others, and permit users to generate and run executable, property-preserving Java.",
        "keywords": "",
        "released": 2017,
        "link": "https://doi.org/10.1145/3098572.3098580"
    },
    {
        "title": "Prototyping biotic games and interactive experiments with JavaScript",
        "abstract": "Life-science research is often driven by advancements in biotechnology. In this demonstration, we explore technology which supports real-time interaction with living matter in the cloud. In order to enable scientists to perform more interactive experiments, we have developed a JavaScript API and corresponding online IDE which can be used to program interactive computer applications allowing the user to remotely interact with swarms of living single-celled micro-organisms in real time. The API interfaces with several remote microscopes which provide a magnified view of a microfluidic chip housing the microorganisms. We hope this work can be a start towards bringing techniques from HCI into bioengineering and biotechnology development.",
        "keywords": "bioengineering; cloud labs; human-biology interaction",
        "released": 2018,
        "link": "https://doi.org/10.1145/3170427.3186510"
    },
    {
        "title": "Detecting and characterizing developer behavior following opportunistic reuse of code snippets from the web",
        "abstract": "Modern software development is social and relies on many online resources and tools. In this paper, we study opportunistic code reuse from the Web, e.g., when developers copy code snippets from popular Q&amp;A sites and paste them into their projects. Our focus is the behavior of developers following opportunistic code reuse, which reveals the success or failure of the action. We study developer behavior via a large, representative dataset of micro-interactions in the IDE. Our analysis of developer behavior exhibited in this dataset confirms laboratory study observations that code reuse from the Web is followed by heavy editing, in some cases by a rapid undo, and rarely by the execution of tests.",
        "keywords": "code snippet; developer behavior; field study; interaction data; opportunistic reuse",
        "released": 2018,
        "link": "https://doi.org/10.1145/3196398.3196467"
    },
    {
        "title": "Automated code refactoring upon database-schema changes in web applications",
        "abstract": "Modern web applications manipulate a large amount of user data and undergo frequent data-schema changes. These changes bring up a unique refactoring task: updating application code to be consistent with data schema. Previous study and our own investigation show that this type of refactoring is error-prone and time-consuming for developers. This paper presents EvolutionSaver, a static code analysis and transformation tool that automates schema-related code refactoring and consistency checking. EvolutionSaver is implemented as an IDE plugin that works for both Rails and Django applications. The source code of EvolutionSaver is available on Github [1] and the plugin can be downloaded from Visual Studio Marketplace [2], with its tutorial available at https://www.youtube.com/watch?v=qBiMkLFIjbE and DOI 10.5281/zenodo.5276127.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1109/ASE51524.2021.9678934"
    },
    {
        "title": "Design and development of website dr.changkitchen diet catering using SDLC waterfall model",
        "abstract": "Diet catering is intended for those who have a goal to live healthier and lose weight. This is done by paying attention to the amount of nutrition or nutrition. The writing of this report aims to develop a web-based diet catering business so that the transaction process between the two parties is easier and faster. The web development process consists of several stages: Analysis, Design, Implementation and Testing Deployment, Maintenance. This diet catering web development uses Brackets as the IDE and by implementing the Waterfall software development model. This website is a way to promote our diet catering products and also to simplify and streamline the transaction path between sellers and buyers because all activities and goals of users will be included in the data. Users who can access this website will be divided into 3 users as non-members, members, and admin. The Non-members can view products and testimonials on our homepage and if nonmembers want to make a purchase, they can order by using social media such as Instagram, Whatsapp, and Line. The Members can make orders and transactions through website. Admin will see the existing transaction process and perform maintenance on the web.",
        "keywords": "design; diet catering; hci; waterfall; website",
        "released": 2021,
        "link": "https://doi.org/10.1145/3479645.3479652"
    },
    {
        "title": "Evaluating solo vs pair programming in an online setting for introductory programming students",
        "abstract": "Many studies have shown the efficacy of pair programming for students learning to program. However, most of these studies have taken place in an in-person environment, where the driver and navigator are physically sharing a keyboard and screen and can communicate verbally and non-verbally. With the increase in online learning, especially during the COVID-19 pandemic. It is important to know whether these results generalize to an online environment.In this work, we develop a methodology to replicate existing pair programming research in a remote context. Students can fulfill the same driver and navigator roles and share access to a single IDE. However, communication is limited to video chat, and participants can never physically interact. This will allow us to replicate various studies, evaluating the efficacy, perceptions, impacts, and perceptions of solo vs. pair programming.An initial study of 116 students enrolled in an introduction to programming course validated our experimental setup and showed that pair programming positively impacted the completion and correctness of programming exercises in an online environment. With 67.3",
        "keywords": "cs0; pair-programming; remote pair-programming; remote work",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545947.3576279"
    },
    {
        "title": "Portlet development with spring portlet MVC and WebSphere portal V7",
        "abstract": "Motivation and JustificationIBM WebSphere Portal is an industry leading Portal solution that is ranked as worldwide market share leader in the Portal products and user interaction tools enterprise software segment. Built upon enterprise-class WebSphere software, with added administrative and scalability features, It contains the widest range of portal technologies that help you develop and maintain first-class B2C, B2B and B2E portals and offers a complete set of portal services necessary to aggregate applications and content, such as:• Advanced usability features, as such drag &amp; drop customizations and semantic tags that enable smart mark-ups and dynamic menus• Advanced tooling needed to build flexible, SOA-based solutions with unmatched scalability required by any size organization.• A \"one click\" site management application featuring rollback and versioning capabilities to simplify moving portals from staging to production• A Page Builder that simplifies page creation, making it easy for business users to create pages and add content to pages• A site wizard that allows users to create and deploy independent virtual portals• A Template Page capability that speeds page creation by allowing portal pages to act as templates when creating other new portal pages• A Web application integrator that enables you to easily embed existing Web applications into your portals• Blog and Wiki capabilities supported via out-of-box content templates, making it easy to add popular social capabilities• Enhanced tagging and rating within the Page Builder theme, allowing users to easily organize and evaluate content without leaving the page they are viewing• Flexible access to existing enterprise data and applications, as well as to external news feeds or Web data• Unified user experience in which information and functions made available to each user can be customized based on the user or a role that the user has• Support for the Java Portlet 2.0 Standard and to the first Java Portlet Specification, the Java Portlet 1.0 Standard.• Support for Web Services for Remote Portlets (WSRP) 2.0• Site layout support that enables you to incorporate existing static HTML, built with familiar HTML and PHP development tools, opening up the platform to additional content sourcesOn the other hand, there is no doubt that Spring is the most complete lightweight Java/JEE container that is used widely in Java development software workshops. With a powerful dependency injection engine at its core and established software engineering practices such as interface-oriented design and Aspect oriented programming, Spring combines the enterprise application power with the simplicity of plain-old Java objects to bring about increased productivity and ease of testing.The Spring Portlet \"Model View Controller\" framework is a truly unique one compared to other frameworks because it is exclusively designed for developing portlets, leaving behind the limitation(s) that comes with providing portlet development support in an existing web framework. A web framework is based on servlet technology, which doesn’t have a concept of lifecycle phases; therefore it ends up hiding the different lifecycle phases of a portlet. But, with Spring Portler \"Model View Controller\" framework you get a full featured Portlet Framework which preserves the lifecycle phases of PortletWith Data access being the requirement for most enterprise applications, Spring provides not only JDBC abstraction framework but also integration with \"Object Relational Mapping\" (ORM) Solutions such as Java Data Objects (JDO), Hibernate and Java Persistence API (JPA) on a variety of Platforms including WebSphere Application Server. With Transactions coupled tightly with Data access, Spring provides an abstract layer on top of different transactions management APIs both declaratively and programmatically. As an application developer, you can use Spring’s transactions management facilities without having to know much out the underlying transaction management APIs.Combining two of the best solutions (WebSphere Portal and Spring), that are not only based on but also promote software engineering best practices, provides software practitioners with an exceptional opportunity to focus on the problem at hand and to have their development cycle reduced considerably.",
        "keywords": "",
        "released": 2011,
        "link": "https://dl.acm.org/doi/10.5555/2093889.2093953"
    },
    {
        "title": "Runtime metric meets developer: Building better cloud applications using feedback",
        "abstract": "A unifying theme of many ongoing trends in software engineering is a blurring of the boundaries between building and operating software products. In this paper, we explore what we consider to be the logical next step in this succession: integrating runtime monitoring data from production deployments of the software into the tools developers utilize in their daily workflows (i.e., IDEs) to enable tighter feedback loops. We refer to this notion as feedback-driven development (FDD). This more abstract FDD concept can be instantiated in various ways, ranging from IDE plugins that implement feedback-driven refactoring and code optimization to plugins that predict performance and cost implications of code changes prior to even deploying the new version of the soft- ware. We demonstrate existing proof-of-concept realizations of these ideas and illustrate our vision of the future of FDD and cloud-based software development in general. Further, we discuss the major challenges that need to be solved be- fore FDD can achieve mainstream adoption.",
        "keywords": "Cloud Computing; Continuous Delivery; Feedback-Driven Development; Software Development",
        "released": 2015,
        "link": "https://doi.org/10.1145/2814228.2814232"
    },
    {
        "title": "Example-driven software language engineering",
        "abstract": "Language workbenches—tools to define software languages together with their IDEs—are designed to simplify language engineering and implementation: they free language engineers from many meticulous tasks, but oftentimes have a very steep learning curve even for experienced software professionals. With the assumption that meta-definitions are one of the key factors that hinder language engineering, we introduce an example-driven approach to language definition. We describe in this paper our vision of a web-based tool aimed at beginner language engineers, and list possible requirements for such a tool. A language is defined by giving examples of code written in it using illustrative syntax definition. These examples are then annotated to specify different concerns of language definition—abstract syntax, typing rules, validation rules, formatting rules, and dynamic semantics.",
        "keywords": "example-driven; illustrative syntax definition; implicit modeling; language engineering; transformations",
        "released": 2020,
        "link": "https://doi.org/10.1145/3426425.3426945"
    },
    {
        "title": "Context-based search to overcome learning barriers in software development",
        "abstract": "During the software development process, developers are often faced with problem solving situations that motivate the use of the Web to search for information. However, there is a gap between the IDE and the Web, requiring the developers to spend significant time searching for relevant information and navigating through web pages in a Web browser. We propose a tool that aim to aid developers overcoming the learning barriers that exist when working with technologies that they do not master, facilitating the access to question/answer web resources through a context-based search interface, integrated in the IDE. We present an example of use, to better understand our approach.",
        "keywords": "context modeling; information retrieval; software development",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2666527.2666537"
    },
    {
        "title": "In-IDE code generation from natural language: Promise and challenges",
        "abstract": "A great part of software development involves conceptualizing or communicating the underlying procedures and logic that needs to be expressed in programs. One major difficulty of programming is turning concept into code, especially when dealing with the APIs of unfamiliar libraries. Recently, there has been a proliferation of machine learning methods for code generation and retrieval from natural language queries, but these have primarily been evaluated purely based on retrieval accuracy or overlap of generated code with developer-written code, and the actual effect of these methods on the developer workflow is surprisingly unattested. In this article, we perform the first comprehensive investigation of the promise and challenges of using such technology inside the PyCharm IDE, asking, “At the current state of technology does it improve developer productivity or accuracy, how does it affect the developer experience, and what are the remaining gaps and challenges?” To facilitate the study, we first develop a plugin for the PyCharm IDE that implements a hybrid of code generation and code retrieval functionality, and we orchestrate virtual environments to enable collection of many user events (e.g., web browsing, keystrokes, fine-grained code edits). We ask developers with various backgrounds to complete 7 varieties of 14 Python programming tasks ranging from basic file manipulation to machine learning or data visualization, with or without the help of the plugin. While qualitative surveys of developer experience are largely positive, quantitative results with regards to increased productivity, code quality, or program correctness are inconclusive. Further analysis identifies several pain points that could improve the effectiveness of future machine learning-based code generation/retrieval developer assistants and demonstrates when developers prefer code generation over code retrieval and vice versa. We release all data and software to pave the road for future empirical studies on this topic, as well as development of better code generation models.",
        "keywords": "Natural language programming assistant; code generation; code retrieval; empirical study",
        "released": 2022,
        "link": "https://doi.org/10.1145/3487569"
    },
    {
        "title": "PearProgram: A more fruitful approach to pair programming",
        "abstract": "In this paper we present PearProgram, a hybrid learning and research tool that helps introductory Computer Science (CS) students learn how to pair program, including in remote learning environments. Grounded in theory from the Learning Sciences, the tool – a collaborative, online IDE – has two primary goals: 1) to help introductory CS students achieve pair programming success; and 2) to research what factors contribute to pairs that have beneficial outcomes. We present our learnings from the use of PearProgram in three remote introductory CS courses: a CS1 course, and two large international courses, including one for high school students. Teacher and student users responded positively to PearProgram, and use of the tool was associated with beneficial learning outcomes in these online learning environments. Our research opens many future research directions for (remote) pair programming, and indicates practices that may prove useful for CS educators at all levels.",
        "keywords": "computing education; covid-19; cs1; online learning; pair programming",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3432517"
    },
    {
        "title": "Exploring gaze tracking &amp; code logging in IDEs as a passive way to ask for help in introduction to programming classes",
        "abstract": "A typical CS1 class involves students working on solving programming problems. Before the pandemic, this occurred in a computer laboratory with a teacher who could quickly assist students having difficulty with their work. Sometimes, there is a need for this intervention even without the student asking for help. An experienced teacher can sense the growing frustration of a student through their overall demeanor. A teacher can also watch how a student codes to provide quick hints to address potential problems. This kind of intervention is challenging to do in an online learning setting. A typical online meeting software provides a small and limited view of a student, often crowded with all the other students. As such, the visual cues of frustration can be easily lost in the noise. Not being able to see the student’s code easily is also a problem. The system we are developing aims to create an online IDE that leverages gaze tracking and code logging to automatically identify these struggling students. In the first phase of the research, a learning model will be trained on students’ gaze and code logs in line with their overall class performance. The second phase of the research will then use this model to predict the frustration level of student users. Collaboration and gamification strategies will be explored in the final stage of the research that would assist interventions of not just teachers but also classmates who are willing to help.",
        "keywords": "code logging; focused intervention; gaze tracking; introduction to programming",
        "released": 2023,
        "link": "https://doi.org/10.1145/3545947.3573251"
    },
    {
        "title": "Exploring tools and strategies used during regular expression composition tasks",
        "abstract": "Regular expressions are frequently found in programming projects. Studies have found that developers can accurately determine whether a string matches a regular expression. However, we still do not know the challenges associated with composing regular expressions.We conduct an exploratory case study to reveal the tools and strategies developers use during regular expression composition. In this study, 29 students are tasked with composing regular expressions that pass unit tests illustrating the intended behavior. The tasks are in Java and the Eclipse IDE was set up with JUnit tests. Participants had one hour to work and could use any Eclipse tools, web search, or web-based tools they desired. Screen-capture software recorded all interactions with browsers and the IDE. We analyzed the videos quantitatively by transcribing logs and extracting personas. Our results show that participants were 30",
        "keywords": "exploratory study; personas; problem solving strategies; regular expressions",
        "released": 2019,
        "link": "https://doi.org/10.1109/ICPC.2019.00039"
    },
    {
        "title": "Equipping IDEs with XML-path reasoning capabilities",
        "abstract": "One of the challenges in Web development is to achieve a good level of quality in terms of code size and runtime performance for popular domain-specific languages such as XQuery, XSLT, and XML Schema. We present the first IDE augmented with static detection of inconsistent XPath expressions that assists the programmer with simplifying development and debugging of any application involving XPath expressions. The tool is based on newly developed formal verification techniques based on expressive modal logics, which are now mature enough to be introduced in the process of software development. We further develop this idea in the context of XQuery for which we introduce an analysis for identifying and eliminating dead code automatically. This proof of concept aims at illustrating the benefits of equipping modern IDEs with reasoning capabilities.",
        "keywords": "Programming; XML; analysis; compile time; environment; path; query; reasoning; schema",
        "released": 2014,
        "link": "https://doi.org/10.1145/2602573"
    },
    {
        "title": "Context-based recommendation to support problem solving in software development",
        "abstract": "During the software development process, developers are often faced with problem solving situations. For instance, it is common the occurrence of exceptions, that originate stack traces in the Console View of the IDE. These situations motivate the developer to use the Web to search for information. However, there is a gap between the IDE and the Web, requiring developers to spend significant time searching for relevant information and navigating through web pages in a Web browser. We propose to process the information of exception stack traces and retrieve question-answering web resources to help developers. We developed a tool that integrates recommendation of question/answer web resources in Eclipse, according to the context of these exception stack traces. The results of a preliminary experimentation are promising, showing that our approach performs better than a simple keyword-based approach.",
        "keywords": "context modelling; problem solving; recommendation systems; software development",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2666719.2666739"
    },
    {
        "title": "Information diffusion at workplace",
        "abstract": "People nowadays need to spend a large amount of time on their work everyday and workplace has become an important social occasion for effective communication and information exchange among employees. Besides traditional online contacts (e.g., face-to-face meetings and telephone calls), to facilitate the communication and cooperation among employees, a new type of online social networks has been launched inside the firewalls of many companies, which are named as the \"enterprise social networks\" (ESNs). In this paper, we want to study the information diffusion among employees at workplace via both online ESNs and online contacts. This is formally defined as the IDE (Information Diffusion in Enterprise) problem. Several challenges need to be addressed in solving the IDE problem: (1) diffusion channel extraction from online ESN and online contacts; (2) effective aggregation of the information delivered via different diffusion channels; and (3) communication channel weighting and selection. A novel information diffusion model, Muse (Multi-source Multi-channel Multi-topic diffUsion SElection), is introduced in this paper to resolve these challenges. Extensive experiments conducted on real-world ESN and organizational chart dataset demonstrate the outstanding performance of Muse in addressing the IDE problem.",
        "keywords": "data mining; diffusion channel selection; enterprise social networks",
        "released": 2016,
        "link": "https://doi.org/10.1145/2983323.2983848"
    },
    {
        "title": "CraftML: 3D modeling is web programming",
        "abstract": "We explore web programming as a new paradigm for programmatic 3D modeling. Most existing approaches subscribe to the imperative programming paradigm. While useful, there exists a gulf of evaluation between procedural steps and the intended structure. We present CraftML, a language providing a declarative syntax where the code is the structure. CraftML offers a rich set of programming features familiar to web developers of all skill levels, such as tags, hyperlinks, document object model, cascade style sheet, JQuery, string interpolation, template engine, data injection, and scalable vector graphics. We develop an online IDE to support CraftML development, with features such as live preview, search, module import, and parameterization. Using examples and case studies, we demonstrate that CraftML offers a low floor for beginners to make simple designs, a high ceiling for experts to build complex computational models, and wide walls to support many application domains such as education, data physicalization, tactile graphics, assistive devices, and mechanical components.",
        "keywords": "3d modeling; 3d printing; creativity support; fabrication; programming",
        "released": 2018,
        "link": "https://doi.org/10.1145/3173574.3174101"
    },
    {
        "title": "Learning rust: How experienced programmers leverage resources to learn a new programming language",
        "abstract": "Experienced programmers are capable of learning new programming languages independently using various available resources, but we lack a comprehensive understanding of which resources they find most valuable in doing so. In this paper, we study how experienced programmers learn Rust, a systems programming language with extensive documentation and example code, an active online community, and descriptive compiler errors. We develop a task that requires learning Rust syntax and comprehending the Rust-specific approach to mutability and ownership. Our results show that users spend 43",
        "keywords": "computer science education; learning resources; programming languages; rust",
        "released": 2020,
        "link": "https://doi.org/10.1145/3334480.3383069"
    },
    {
        "title": "Functional programming for all! Scaling a MOOC for students and professionals alike",
        "abstract": "Massive open online courses (MOOCs) have launched a scale shift in higher education, with several individual MOOCs now boasting tens or hundreds of thousands of participants worldwide. Our MOOC on the principles of functional programming has more than 100,000 registered students to date, and boasts one of the highest rates of completion (19.2",
        "keywords": "MOOC; Software engineering education; au- tomated grading; programming education",
        "released": 2014,
        "link": "https://doi.org/10.1145/2591062.2591161"
    },
    {
        "title": "ETX ’14: Proceedings of the 2014 workshop on eclipse technology eXchange",
        "abstract": "It is our great pleasure to welcome you to the 2014 Eclipse Technology eXchange Workshop, sponsored by ACM SIGPLAN. This year’s workshop continues the tradition of bringing together researchers and practitioners to discuss potential new uses of Eclipse in research and education as well as how Eclipse can leverage novel work in, e.g., programming languages and software engineering research. ETX has been a very successful workshop at OOPSLA from 2003-2007 and given that the Eclipse Ecosystem is still very relevant for research and education we felt that it was time to revive ETX at SPLASH.Due to the longer hiatus, the response to our call for papers was a little lower than what we had hoped for, but after a rigorous round of reviews we had three submissions that were accepted. We decided to complement the program with two invited talks and provided authors and attendees with an opportunity to showcase some of their Eclipse-related work in an open demonstration session. In the first invited talk, Anish Karmarkar from Oracle presented the standardization work on CAMP (Cloud Application Management for Platforms), a standard for managing software applications on PaaS cloud platforms. Since the cloud is an ongoing hot topic and has led to the proliferation of the DevOps model, his talk could provide interesting insights into the interrelation between development, deployment, and operation of software systems in the cloud, an area where IDEs could and arguably need to play a much stronger role in the future.Tamás Szabó from itemis AG was the second invited speaker and talked about mbeddr, a set of extensible and integrated languages for embedded software development. mbeddr is a customizable IDE that is built on the Meta Programming System (MPS) from JetBrains. MPS directly works on the Abstract Syntax Tree of the IDE contents and this model is projected to the user for editing. mbeddr utilizes the capabilities of the projectional editor by providing various notations (projections) for the developers; apart from the regular source code, developers can easily embed tables, complex mathematical formulas and diagrams right into to the text.",
        "keywords": "",
        "released": 2014,
        "link": "https://dl.acm.org/doi/10.1145/2688130"
    },
    {
        "title": "Exploring the value of different data sources for predicting student performance in multiple CS courses",
        "abstract": "A number of recent studies in computer science education have explored the value of various data sources for early prediction of students’ overall course performance. These data sources include responses to clicker questions, prerequisite knowledge, instrumented student IDEs, quizzes, and assignments. However, these data sources are often examined in isolation or in a single course. Which data sources are most valuable, and does course context matter? To answer these questions, this study collected student grades on prerequisite courses, Peer Instruction clicker responses, online quizzes, and assignments, from five courses (over 1000 students) across the CS curriculum at two institutions. A trend emerges suggesting that for upper-division courses, prerequisite grades are most predictive; for introductory programming courses, where no prerequisite grades were available, clicker responses were the most predictive. In concert, prerequisites and clicker responses generally provide highly accurate predictions early in the term, with assignments and online quizzes sometimes providing incremental improvements. Implications of these results for both researchers and practitioners are discussed.",
        "keywords": "architecture; cs1; cs2; data structures; low-performing students; machine learning; prediction; student outcomes",
        "released": 2019,
        "link": "https://doi.org/10.1145/3287324.3287407"
    },
    {
        "title": "A reactive language for analyzing cloud logs",
        "abstract": "Log analysis is required in many domains, and especially in the emerging field of cloud computing. Cloud applications are often built by composing diverse services. When something goes wrong, finding the root cause of the problem can be difficult. Many services are only reachable through their Application Programming Interfaces (APIs) with no possibility for live introspection. In this context, logs become an essential tool for monitoring and debugging. Cloud services typically generate very large quantities of log messages, with formats that may not be well specified and may vary over time. In this paper, we present CloudLens, a language for the analysis of semi-structured textual data as found in logs, and specify its formal semantics. CloudLens is a reactive language and views logs as streams of objects. Our objective is to facilitate exploring the contents of logs interactively and to write reusable analyses succinctly, using familiar constructs. We implemented an interpreter for the Apache Zeppelin notebook to provide an interactive IDE. Our prototype implementation is open source and we report on a detailed case study using logs from the Apache OpenWhisk project.",
        "keywords": "Log analysis; Programming language; Reactive programming",
        "released": 2018,
        "link": "https://doi.org/10.1145/3281278.3281280"
    },
    {
        "title": "Form follows function(): An IDE to create laser-cut interfaces and microcontroller programs from single code base",
        "abstract": "During the development of physical computing devices, physical object models and programs for microcontrollers are usually created with separate tools with distinct files. As a result, it is difficult to track the changes in hardware and software without discrepancy. Moreover, the software cannot directly access hardware metrics. Designing hardware interface cannot benefit from the source code information either. This demonstration proposes a browser-based IDE named f3.js that enables development of both as a single JavaScript code base. The demonstration allows audiences to play with the f3.js IDE and showcases example applications such as laser-cut interfaces generated from the same code but with different parameters. Programmers can experience the full feature and designers can interact with preset projects with a mouse or touch to customize laser-cut interfaces. More information is available at http://f3js.org.",
        "keywords": "integrated development environment; laser-cut interface; microcontroller; personal fabrication",
        "released": 2015,
        "link": "https://doi.org/10.1145/2815585.2817797"
    },
    {
        "title": "danceON: Culturally responsive creative computing",
        "abstract": "Dance provides unique opportunities for embodied interdisciplinary learning experiences that can be personally and culturally relevant. danceON is a system that supports learners to leverage their body movement as they engage in artistic practices across data science, computing, and dance. The technology includes a Domain Specific Language (DSL) with declarative syntax and reactive behavior, a media player with pose detection and classification, and a web-based IDE. danceON provides a low-floor allowing users to bind virtual shapes to body positions in under three lines of code, while also enabling complex, dynamic animations that users can design working with conditionals and past position data. We developed danceON to support distance learning and deployed it in two consecutive cohorts of a remote, two-week summer camp for young women of color. We present our findings from an analysis of the experience and the resulting computational performances. The work identifies implications for how design can support learners’ expression across culturally relevant themes and examines challenges from the lens of usability of the computing language and technology.",
        "keywords": "computing education; culturally responsive pedagogy; dance; data literacy; design based research",
        "released": 2021,
        "link": "https://doi.org/10.1145/3411764.3445149"
    },
    {
        "title": "Building national public infrastructures on our way to a global inclusive infrastructure",
        "abstract": "Broadband technologies are rapidly becoming integral to education, commerce, employment, community participation, health and safety Yet there remain multiple barriers to effective and affordable access by people with disabilities, elder, or those with low literacy creating an increasing digital divide. There are assistive technologies that can provide access for some. However it is not available for all disabilities, not affordable by many, and lags mainstream developments and deployments. Even when the latest AT is close to the latest IT, few people have the latest version. The cost of keeping up with mainstream technologies reduces resources available for innovation in assistive technologies and new directions in broadband technologies will require an already strapped AT industry to retool and re-architect their products. We are moving to an ICT environment with a profusion of hardware models (desktop, laptop, netbook, smartphone, tablet, set top box, game systems, players), multiple operating systems (Windows, Mac, Linux, Chrome OS, iPhone, Android, Windows Mobile, Symbian, Maemo (Nokia), Bada (Samsung), WebOS, etc.), hundreds of software applications that embed another universe of widgets, plug-ins, and players, and a networked information environment that adheres to no standard and mutates far beyond the initial conception of the Web. Our current access technologies and infrastructure cannot handle this; the assistive technologies that now exist do not address all disabilities well, particularly cognitive, language, and learning disabilities, deaf-blindness and the mixed problems faced by elders; current assistive technologies often add, rather than reduce, complexity; finally, but importantly, people are not aware of what is possible, see it as complicated, and do not have any easy way to determine that there is something that can help themA coalition of academic, industry and non-governmental organizations and individuals are coming together to promote the creation of a National Public Inclusive Infrastructure (NPII) to address these problems. The purpose is to ensure that everyone who faces accessibility barriers due to disability, literacy or aging, regardless of economic status, can access and use the Internet and all its information, communities, and services for education, employment, daily living, civic participation, health and safety.An NPII would provide key software enhancements to the physical infrastructure to allow lower cost accessibility that could be invoked on any computer, anywhere. Its key components would be a cloud based delivery system that would allow anywhere, any computer access, a personal preference system to allow systems to automatically configure themselves to users, a system of wizards to make creation of a preference profile simple even when a professional is not available, a metadata server to allow users to find accessible media or captions or descriptions for inaccessible media, a trusted source for malware free solutions, a rich development environment with common building blocks, and an awareness program to make more people aware of what is possible for them. All of the NPII components are being designed to support both commercial assistive technologies and free, built-in access features (universal design). The NPII will include a delivery system, personalization profiles and a rich development system and common modules. In addition to lowering development costs and increasing the number of solutions for different disabilities, the NPII can also enable new types of assistive technologies and services, including assistance-on-demand services that allow consumers to invoke computer or human assistance whenever and wherever they need it. The goal is a richer set of access options that it is less expensive to create and distribute and that can address the needs of a wider range of disabilities than is possible today. And a model infrastructure that can be replicated internationally and bring this wide variety of access options and the lower cost delivery system for both commercial and free access features to countries world-wide.",
        "keywords": "",
        "released": 2010,
        "link": "https://doi.org/10.1145/1805986.1806014"
    },
    {
        "title": "Creating tutorial materials as lecture supplements by integrating drawing tablet and video capturing/sharing",
        "abstract": "We report the experience of adopting an innovative technique for creating tutorial videos which complement lectures and facilitate students’ learning. Our technique relies on: 1) preparing starter pages consisting of code fragments or writings/figures on a drawing tablet; 2) illustrating complex ideas on the drawing tablet; 3) recording all computer desktop activities (e.g., development of code on a programming IDE, illustration on the drawing tablet); and 4) sharing the recorded tutorial videos with students online. Our technique has been adopted in creating tutorial series for four Computer Science and Engineering courses, ranging from the first year to the third year. Analytics of these online tutorial videos is presented to show the average amount of time which each registered student spent on watching them. Course evaluation results indicate that our technique is perceived as effective for achieving the course learning outcomes. Comparison of students’ performance on complex topics (arrays and loops) also indicates a positive impact of our approach.",
        "keywords": "Computational Thinking; Instructional Technologies; Laboratory Assignments; Large Class; Tutorial Videos",
        "released": 2020,
        "link": "https://doi.org/10.1145/3375258.3375259"
    },
    {
        "title": "Smart programming playgrounds",
        "abstract": "Modern IDEs contain sophisticated components for inferring missing types, correcting bad syntax and completing partial expressions in code, but they are limited to the context that is explicitly defined in a project’s configuration. These tools are ill-suited for quick prototyping of incomplete code snippets, such as those found on the Web in Q&amp;A forums or walk-through tutorials, since such code snippets often assume the availability of external dependencies and may even contain implicit references to an execution environment that provides data or compute services.We propose an architecture for smart programming playgrounds that can facilitate rapid prototyping of incomplete code snippets through a semi-automatic context resolution that involves identifying static dependencies, provisioning external resources on the cloud and injecting resource bindings to handles in the original code fragment.Such a system could be potentially useful in a range of different scenarios, from sharing code snippets on the Web to experimenting with new ideas during traditional software development.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2819009.2819116"
    },
    {
        "title": "MUWS’22: 1st international workshop on multimodal understanding for the web and social media",
        "abstract": "The 1st International Workshop on Multimodal Understanding for the Web and Social Media (MUWS 2022) is co-located with The Web Conference (WWW) and held on the 26th of April, 20221. Multimodal learning and analysis is an emerging research area that cuts through several disciplines like Computer Vision, Natural Language Processing (NLP), Speech Processing, and Multimedia. Recently, several multimodal learning techniques have shown the benefit of combining multiple modalities in video representation learning and downstream tasks on videos. At the core, these methods are focused on modelling the modalities and their complex interactions by using large amounts of data, different loss functions and deep neural network architectures. Although these research directions are exciting and challenging, interdisciplinary fields such as semiotics are rarely considered. Literature in semiotics provides a detailed theory and analysis on meaning creation through signs and symbols via multiple modalities. In general, it provides a compelling view of multimodality and perception that can further expand computational research and applications on the web and social media. The goal of the interdisciplinary MUWS Workshop is to bring together researchers and practitioners from the fields of Information Retrieval, Natural Language Processing, Computer Vision, Human Computation, and Semiotics to discuss and evaluate methods and solutions for effective and efficient analytics of multimodal information present in the Web or social media. We are interested in approaches, tasks, and metrics for effectively analysing multimedia information such as image-text pairs and videos to design methodologies that jointly consider information from multiple modalities. The interdisciplinary nature of processing such multimodal data involves combining ideas and methods from the fields mentioned above. We envision the workshop as a forum for researchers and practitioners from academia and industry for original contributions and practical application on multimodal information processing, mining, retrieval, search, and management. The workshop features advanced methods for combining visual and textual content for problems such as fake news detection, predicting reliability and popularity of news articles, generating image narrative with emotion, and injecting knowledge graph information to improve visual question answering performance. We would like to take this opportunity to sincerely thank the authors and presenters for their inspiring contributions to the workshop. Our sincere thanks are due to the program committee members for reviewing the submissions and ensuring the high quality of our workshop program. We also thank Ichiro Ide for his keynote talk, Chiao-I Tseng and Christian Otto for their invited talks in the workshop. We are also very grateful to the organisers of The Web Conference 2022, and particularly the Workshops Chairs, Nathalie Hernandez and Preslav Nakov, for their support with the workshop organisation.",
        "keywords": "",
        "released": 2022,
        "link": "https://doi.org/10.1145/3487553.3524873"
    },
    {
        "title": "Optimising the fit of stack overflow code snippets into existing code",
        "abstract": "Software developers often reuse code from online sources such as Stack Overflow within their projects. However, the process of searching for code snippets and integrating them within existing source code can be tedious. In order to improve efficiency and reduce time spent on code reuse, we present an automated code reuse tool for the Eclipse IDE (Integrated Developer Environment), NLP2TestableCode. NLP2TestableCode can not only search for Java code snippets using natural language tasks, but also evaluate code snippets based on a user’s existing code, modify snippets to improve fit and correct errors, before presenting the user with the best snippet, all without leaving the editor. NLP2TestableCode also includes functionality to automatically generate customisable test cases and suggest argument and return types, in order to further evaluate code snippets. In evaluation, NLP2TestableCode was capable of finding compilable code snippets for 82.9",
        "keywords": "crowd-generated code snippets; optimisation; stack overflow",
        "released": 2020,
        "link": "https://doi.org/10.1145/3377929.3398087"
    },
    {
        "title": "HyperSource: Bridging the gap between source and code-related web sites",
        "abstract": "Programmers frequently use the Web while writing code: they search for libraries, code examples, tutorials, and documentation. This link between code and visited Web pages remains implicit today. Connecting source code and browsing histories might help programmers maintain con-text, reduce the cost of Web page re-retrieval, and enhance understanding when code is shared. This note introduces HyperSource, an IDE augmentation that associates browsing histories with source code edits. HyperSource comprises a browser extension that logs visited pages; an IDE that tracks user activity and maps pages to code edits; a source document model that tracks visited pages at a character level; and a user interface that enables interaction with these histories. We discuss relevance heuristics and privacy issues inherent in this approach. Informal log analyses and user feedback suggest that our annotation model is promising for code editing and might also apply to other document authoring tasks after refinement.",
        "keywords": "browsing history; code editors; edit wear",
        "released": 2011,
        "link": "https://doi.org/10.1145/1978942.1979263"
    },
    {
        "title": "A reflective platform for highly adaptive multi-cloud systems",
        "abstract": "Cloud platforms are increasingly used for hosting a broad diversity of services from traditional e-commerce applications to interactive web-based IDEs. However, we observe that the proliferation of offers by Cloud vendors raises several challenges. Developers will not only have to deploy applications for a specific Cloud, but will also have to consider migrating services from one cloud to another, and to manage applications spanning multiple Clouds. In this paper, we therefore report on a first experiment we conducted to build a multi-Cloud system on top of thirteen existing IaaS/PaaS. From this experiment, we advocate for two dimensions of adaptability—design and execution time—that applications for such systems require to exhibit. Finally, we propose a roadmap for future multi-Cloud systems.",
        "keywords": "",
        "released": 2011,
        "link": "https://doi.org/10.1145/2088876.2088879"
    },
    {
        "title": "Inter-app communication between android apps developed in app-inventor and android studio",
        "abstract": "Communications between mobile apps are an important aspect of mobile platforms. Android is specifically designed with inter-app communication in mind and depends on this to provide different platform specific functionalities. Android Apps can either be designed with the help of Android SDK and using IDEs such as Android Studio or by using a browser based platform called App Inventor. These two development platforms provide their own technique for inter-app communication in the same platform, however lack an established method of inter-app communication when apps are developed using the two seperate development platforms. This paper provides the missing information required for the app communications and presents the method for sending and receiving arguments between apps developed in these two platforms. The paper also outlines the significance of the result, and examines their limitations.",
        "keywords": "Android; Android studio; app inventor; mobile apps",
        "released": 2016,
        "link": "https://doi.org/10.1145/2897073.2897117"
    },
    {
        "title": "Web APIs - challenges, design points, and research opportunities: Invited talk at the 2nd international workshop on API usage and evolution (WAPI ’18)",
        "abstract": "Web Application Programming Interfaces (web APIs) provide programmatic, network-based access to remote data or functionalities. Applications, for example, use the Google Places API to learn about nearby establishments, use the Twitter, Instagram, or Facebook API to connect users with friends and family, or use the Stripe API to accept end-user payments. Increasingly, applications themselves consist of micro-services that expose their capabilities to one another using web APIs.In comparison to library APIs, which are a common subject of software engineering research, web APIs present unique challenges - both for providers and consumers - that are arguably much less explored yet [3]. For one, in web APIs, providers control both the API and the runtime providing the capabilities exposed by the API. In consequence, providers may extend, change, or even remove these capabilities or the API, with possibly severe effects for consuming applications. In contrast, applications typically depend on specific versions of software libraries, which can be used even as the library evolves. Being controlled by another party and invoked via network, web API consumers also have to consider and possibly mitigate varying quality of service (QoS) characteristics. Primarily, the availabilities and response times of web APIs change over time, possibly impacting application performance or functionality. Furthermore, the use of library APIs is eased by mechanisms like auto-complete or IDE-integrated documentation (at least in typed languages). In contrast, web APIs commonly lack machine-understandable specifications and consume and provide data in the form of strings. To correctly use a web API, developers have to familiarize with semi-structured documentation pages, often written in HTML - there are only few IDE-based error-checking approaches for web APIs yet [2]. Whereas for many programming languages central package manager services provide unified access to available libraries (think Maven for Java, npm for JavaScript, or RubyGems for Ruby), comprehensive listings of web APIs do not exist, hardening their discovery and selection.In this talk, we outline the characteristics of web APIs causing these challenges. We discuss relevant design points, both for providers and consumers, how these design points have been implemented by different web API paradigms in recent years, and recent attempts to bride these paradigms [1]. Throughout the talk, we give examples of our research to address web API-related challenges. Our goal is to inspire WAPI attendees to take on some of the many research opportunities surrounding web APIs.",
        "keywords": "software engineering; web APIs",
        "released": 2018,
        "link": "https://doi.org/10.1145/3194793.3194801"
    },
    {
        "title": "One semicolon away from success: Rebranding \"failure\" in CS1 through new terminology",
        "abstract": "In a review of student programming work (through playback of their submissions via online IDE), it was noted that students could be quite close to a successful solution and repeatedly start over, deleting all of the work done to that point in time. The words of Thomas Edison expressed the problem associated with this current branding: \"I have not failed. I’ve just found 10,000 ways that won’t work.\" While this is meant to imply that failure has led towards success, the idea that something \"won’t work\" captures the mindset that students are facing when using the word ’failure’ in regards to programming. In fact, iterations of programs move students incrementally closer to their goal. The notion of a binary concept like pass/fail being applied to programming leaves less room for creativity and exploration. Amongst new programming students, after reaching this point of ’passing’, student fear of modifying and ’playing’ with working programs has been noted. In order to address the concerns of students and help shift student mindsets away from ’failure’ towards ’incremental improvement’, a rebranding exercise must take place.",
        "keywords": "cs1; failure; mindset; novices; programming",
        "released": 2021,
        "link": "https://doi.org/10.1145/3408877.3439522"
    },
    {
        "title": "Sandstone HPC: A domain-general gateway for new HPC users",
        "abstract": "The complexity of high-performance computing (HPC) resources poses many challenges to new users. A number of science gateways have been developed to increase the productivity of novice users by hiding the underlying infrastructure, however these solutions tend not to teach HPC skills that transfer easily outside of the gateway. In this paper we introduce a domain-general gateway, Sandstone HPC, that represents the HPC environment more naturally to novice users by abstracting the command-line interface and providing contextual help. We assess the degree to which Sandstone HPC improves upon the usability of the command-line interface by analyzing the results of a usability study conducted on both environments. We will also detail how the architecture promotes long-term sustainability and a community-development model.",
        "keywords": "High-Performance Computing; User Studies; Web-Based IDE",
        "released": 2017,
        "link": "https://doi.org/10.1145/3093338.3093360"
    },
    {
        "title": "Opportunities in software engineering research for web API consumption",
        "abstract": "Nowadays, invoking third party code increasingly involves calling web services via their web APIs, as opposed to the more traditional scenario of downloading a library and invoking the library’s API. However, there are also new challenges for developers calling these web APIs. In this paper, we highlight a broad set of these challenges and argue for resulting opportunities for software engineering research to support developers in consuming web APIs. We outline two specific research threads in this context: (1) web API specification curation, which enables us to know the signatures of web APIs, and (2) static analysis that is capable of extracting URLs, HTTP methods etc. of web API calls. Furthermore, we present new work on how we combine (1) and (2) to provide IDE support for application developers consuming web APIs. As web APIs are used broadly, research in supporting the consumption of web APIs offers exciting opportunities.",
        "keywords": "",
        "released": 2017,
        "link": "https://dl.acm.org/doi/10.5555/3106028.3106033"
    },
    {
        "title": "Speculative analysis: Exploring future development states of software",
        "abstract": "Most software tools and environments help developers analyze the present and past development states of their software systems. Few approaches have investigated the potential consequences of future actions the developers may perform. The commoditization of hardware, multi-core architectures, and cloud computing provide new potential for delivering apparently-instantaneous feedback to developers, informing them of the effects of changes that they may be considering to the software.For example, modern IDEs often provide \"quick fix\" suggestions for resolving compilation errors. Developers must scan this list and select the option they think will resolve the problem. Instead, we propose that the IDE should speculatively perform each of the suggestions in the background and provide information that helps developers select the best option for the given context. We believe the feedback enabled by speculative operations can improve developer productivity and software quality.",
        "keywords": "developer awareness; ide; quick fix; recommender system; speculation; version control",
        "released": 2010,
        "link": "https://doi.org/10.1145/1882362.1882375"
    },
    {
        "title": "HyperSource: Bridging the gap between source and code-related web sites",
        "abstract": "Programmers frequently use the Web while writing code: they search for libraries, code examples, tutorials, documentation, and engage in discussions on Q&amp;A forums. This link between code and visited Web pages largely remains implicit today. Connecting source code and (selective) browsing history can help programmers maintain context, reduce the cost of Web content re-retrieval, and enhance understanding when code is shared. This paper introduces HyperSource, an IDE augmentation that associates browsing histories with source code edits. HyperSource comprises a browser extension that logs visited pages; a novel source document format that maps visited pages to individual characters; and a user interface that enables interaction with these histories.",
        "keywords": "augmented source code; browsing history",
        "released": 2010,
        "link": "https://doi.org/10.1145/1866218.1866251"
    },
    {
        "title": "Using JavaScript and WebCL for numerical computations: A comparative study of native and web technologies",
        "abstract": "From its modest beginnings as a tool to validate forms, JavaScript is now an industrial-strength language used to power online applications such as spreadsheets, IDEs, image editors and even 3D games. Since all modern web browsers support JavaScript, it provides a medium that is both easy to distribute for developers and easy to access for users. This paper provides empirical data to answer the question: Is JavaScript fast enough for numerical computations? By measuring and comparing the runtime performance of benchmarks representative of a wide variety of scientific applications, we show that sequential JavaScript is within a factor of 2 of native code. Parallel code using WebCL shows speed improvements of up to 2.28 over JavaScript for the majority of the benchmarks.",
        "keywords": "C; OpenCL; WebCL; benchmark; computational dwarfs; javascript; numerical computation; parallelism; web browser",
        "released": 2014,
        "link": "https://doi.org/10.1145/2661088.2661090"
    },
    {
        "title": "JavaCAP: A collaborative case authoring program on the WWW",
        "abstract": "JavaCAP, a software tool for student authoring and searching of case libraries, has been implemented in support of the Learning-by-Design curriculum development project at Georgia Tech’s EduTech Institute. Its case-authoring component, when used as part of the LBD curriculum, asks students to reflect on a recent Learning-by-Design experience, summarize it, and present important aspects of it and what they’ve learned from it for other students to learn from. By focusing on this part of the tool, we are able to both put our focus on supporting reflection and collect a library of student-authored cases that we will later edit and publish as exemplary cases for other students to use as models and to learn from.JavaCAP is meant to be used as a collaboration tool. Supporting collaboration in middle school requires supporting both group work around the computer (synchronous collaboration) and asynchronous editing of cases. We support asynchronous collaboration by allowing each student to write on the case and providing distinguishing formats for each so it is easy to see the changes made since last using the tool and identify whose changes they are.Our two studies suggest that JavaCAP does have potential as a collaborative reflection tool. We’ve used the metaphor of scenes in a play to help students remember different aspects of the experience they are analyzing and summarizing. Our first pilot showed that we had indeed found a way to engage students in effective reflection. However, this pilot also revealed flaws in the underlying technology. We needed to support asynchronous collaboration better than we were doing; the easiest way to do this was to reimplement using what the world wide web and its development tools had to offer. Our second pilot, using a revised tool both better supported asynchronous student authoring and made it easy for students to add images to their presentations. This study pointed out the need to better support writing itself within the framework we’ve created and suggests other collaboration features that students need.",
        "keywords": "LBD; case-based learning; case-based reasoning; learning by design; middle school; reflection; scaffolding; science education; tools to support collaborative settings",
        "released": 1997,
        "link": "https://dl.acm.org/doi/10.5555/1599773.1599803"
    },
    {
        "title": "Building dynamic application networks with web services",
        "abstract": "Looking at the state of the industry today, it is clear that we are in the early stages of Web Services development. Companies are still evaluating what the technology and considering how to apply it to their business. But over the past year, we seem to have reached an inflection point of companies building real systems based on Web Services. Partly this reflects an acceptance that the basic Web Services technologies - XML Schema [1][2], SOAP [3], WSDL [4] - have matured to the point where they can be used for mission critical applications. But it also reflects a growing understanding that Web Services enable a large class of systems that were previously very difficult to build. These systems are characterized by several critical properties:1. Rapid rates of change. The time is long past when companies could afford a year-long-effort to build out a new application. Businesses move at a faster pace today then ever before, and they are increasingly under pressure to do more work with fewer resources. This places a premium on the ability to build applications by quickly composing pre-existing services. The result is that systems are being connected in ways that were never imagined during development. This is reuse in the large - not just small services, but entire applications being linked together to solve a complex business function.2. Significant availability and scalability requirements. Many of these systems are \"bet-your-business\" types of applications. They have heavy scalability and availability requirements. Often then need to connect multiple partners and service hundreds of thousands of updates in a day, without ever suffering an interruption in service.3. Heterogeneous development tools and software platforms. Each of these applications typically involves components built using a wildly diverse set of tools, operating systems, and software platforms. Partly this is a result of building systems out of existing components - many of these components are locked into certain environments, and there are no resources to rewrite or migrate to a single homogenous platform. But it is also recognition that different problems are best solved by different toolsets. Some problems are best solved by writing code on an application server, others are best suited for scripting, and still others are solved by customizing an existing enterprise application. Heterogeneity is not going away. It is only increasing.4. Multiple domains of administrative control. An aspect of heterogeneity that is often overlooked is distributed ownership. As businesses merge, acquire, and partner with other companies, there is an increasing need to build applications that span organizational boundaries.These characteristics present a unique set of challenges to the way we think about developing, describing, connecting, and configuring applications. The challenges require us to develop new ways of looking at what it takes to build an application, and what makes up a network.In this session, we examine the nature of this next generation of application, and discuss the way in which Web Services are evolving to meet their needs. The session focuses on the development techniques that allow services to be easily and dynamically composed into rich applications, and considers the capabilities required of the underlying network fabric. The session concludes with an in-depth look at some of the critical Web Services specifications actively under development by industry leaders.",
        "keywords": "",
        "released": 2004,
        "link": "https://doi.org/10.1145/1007568.1007674"
    },
    {
        "title": "INTEL® XDK: Cross-platform ide for development of mobile apps including games and IoT: Tutorial presentation",
        "abstract": "Intel® XDK is a free IDE for people who want to create apps for mobile and IoT platforms. It offers essential tools to rapidly design, debug, tune, and build apps for Android*, iOS*, and Windows* app stores. Our users range from beginners who have never programmed to experienced Web developers who want to move into the mobile arena.",
        "keywords": "",
        "released": 2016,
        "link": "https://dl.acm.org/doi/10.5555/3007225.3007262"
    },
    {
        "title": "Recommending relevant sections from a webpage about programming errors and exceptions",
        "abstract": "Programming errors or exceptions are inherent in software development and maintenance, and given today’s Internet era, software developers often look at web for finding working solutions. They make use of a search engine for retrieving relevant pages, and then look for the appropriate solutions by manually going through the pages one by one. However, both the manual checking of a page’s content against a given exception (and its context) and then working an appropriate solution out are non-trivial tasks. They are even more complex and time-consuming with the bulk of irrelevant (i.e., off-topic) and noisy (e.g., advertisements) content in the web page. In this paper, we propose an IDE-based and context-aware page content recommendation technique that locates and recommends relevant sections from a given web page by exploiting the technical details, in particular, the context of an encountered exception in the IDE. An evaluation with 250 web pages related to 80 programming exceptions, comparison with the only available closely related technique, and a case study involving comparison with VSM and LSA techniques show that the proposed technique is highly promising in terms of precision, recall and F1-measure.",
        "keywords": "content recommendation; content relevance; traceability",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2886444.2886471"
    },
    {
        "title": "The spinoza code tutor: Faculty poster abstract",
        "abstract": "Spinoza[5] is a web-based IDE developed using NodeJS to support active learning in intro-ductory programming classes. It encompass the best features from various systems like codingbat [1], cloudcoder[2] and codeHunt[3] in one holistic system. Spinoza differs from other similar systems in providing the instructor with detailed real-time feedback during in-class coding sessions, both at the level of the individual student and the class as a whole. From the students’ view, Spinoza provides authenticated access to a collection of named programming problems and a web-based IDE which allows students to code, run, unit test, and debug those problems. From the instructor’s view, Spinoza provides interfaces for creating a variety of programming challenges and also provides multiple views of students’ progress on solving the coding problems.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2753024.2753055"
    },
    {
        "title": "Domain-specific design of patient classification in cancer-related cachexia research",
        "abstract": "We apply an IDE for user-level process design and composition to a real-life case study: a complex workflow from an ongoing global cancer-related cachexia research project. Originally buried in a manually operated spreadsheet, the process is now fully automated and integrated into the project database, ensuring the immediate availability, consistency and reproducibility of the outcomes. Our integrated solution enables the scientists to immediately execute the processes and easily customize both processes and data model to continuously changing experimental setups. The data modeling is provided by the Dynamic Web Application framework and the process modeling functionalities by the Java Application Building Center, both following the paradigm of eXtreme Model-Driven Design for model-driven software development.",
        "keywords": "domain-specific modeling; model-driven software development; process modeling; scientific workflows; workflow design",
        "released": 2018,
        "link": "https://doi.org/10.1145/3193992.3194002"
    },
    {
        "title": "Learning computer science languages in enki",
        "abstract": "This paper presents an overview and main features of Enki, a web-based learning environment for computer science languages. Enki was designed to be a sort of entry level IDE, aggregating tools for navigating and viewing course materials, for solving exercises and receiving automated feedback, as well as promoting the learning process. Enki uses services from several other systems, namely for content sequencing and recommendation, exercise assessment, and gamification.",
        "keywords": "educational resources; exercises; gamification; integration; learning; programming languages; sequencing",
        "released": 2016,
        "link": "https://doi.org/10.1145/2899415.2925504"
    },
    {
        "title": "PerformanceHat: Augmenting source code with runtime performance traces in the IDE",
        "abstract": "Performance problems observed in production environments that have their origin in program code are immensely hard to localize and prevent. Data that can help solve such problems is usually found in external dashboards and is thus not integrated into the software development process. We propose an approach that augments source code with runtime traces to tightly integrate runtime performance traces into developer workflows. Our goal is to create operational awareness of performance problems in developers’ code and contextualize this information to tasks they are currently working on. We implemented this approach as an Eclipse IDE plugin for Java applications that is available as an open source project on GitHub. A video of PerformanceHat in action is online: https://youtu.be/fTBBiylRhag",
        "keywords": "development workflow; program analysis; software performance engineering",
        "released": 2018,
        "link": "https://doi.org/10.1145/3183440.3183481"
    },
    {
        "title": "Learning loop invariants",
        "abstract": "One aspect of developing correct code, code that functions as specified, is annotating loops with suitable invariants. Loop invariants are useful for human reasoning and are necessary for tool-assisted automated reasoning. Writing loop invariants can be a difficult task for all students, especially beginning software engineering students. In helping students learn to write adequate invariants, we need to understand not only what errors they make, but also why they make them. This poster discusses the use of a Web IDE backed by the RESOLVE verification engine to aid students in developing loop invariants and to collect performance data. In addition to collecting submitted invariant answers, students are asked to provide their steps or thought processes regarding how they arrived at their answers for each submission. The answers and reasons are then analyzed using a mixed-methods approach. Resulting categories of answers indicate that students are able to use formal method concepts with which they are already familiar, such as, pre and post-conditions as a starting place to develop adequate loop invariants. Additionally, some common trouble spots in learning to write invariants are identified. The results will be useful to guide classroom instruction and automated tutoring.",
        "keywords": "correctness; loop-invariants; objects; online tool; reasoning; software-engineering; tracing",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3372715"
    },
    {
        "title": "Jupyter notebooks versus a textbook in a big data course",
        "abstract": "In building curriculum in new areas of computer science, often the tools introduced in the course are an important component. This is especially true in the area of big data, where the complexity of the problems the area tackles is high. In the 4 years since its inception, my big data course has gone through two major redesigns and has settled on a tool set including: the Hadoop platform, Spark processing engine, the Python programming language, Eclipse IDE, and Jupyter Notebooks. Many of the changes were driven by input from professional peers on big data teams, who were struggling with the complexity resulting from the low-level programming model used by MapReduce. Jupyter Notebook, a type of computational notebook, was added to the course to introduce students to the Python programming language. Data scientists and researchers have found computational notebooks an effective tool to manage their work by providing a way to track their thinking process, their code, and conclusions in one web document. To assess the effectiveness of using Jupyter Notebook in a big data course, students’ views on the use of computational notebooks and traditional textbooks were captured and statistically analyzed.",
        "keywords": "",
        "released": 2020,
        "link": "https://dl.acm.org/doi/10.5555/3417639.3417658"
    },
    {
        "title": "Adventures in commercial-grade static analysis (keynote)",
        "abstract": "Building a commercial grade static analysis presents a lot of interesting problems. Everything not forbidden is compulsory: language specifications are wonderful documents, but in reality anything the user’s compiler and runtime accepts is fair game. Analysis abstractions that scale \"except in pathological cases\" don’t scale: analyzing tens of thousands of code bases that routinely exceed millions of lines of code means that those pathological cases inevitably arise. Build a good analysis that runs overnight, and users will ask you to run it in their IDE for near-immediate feedback. A bug finding tool needs a low false positive rate, but a tool aimed at finding security vulnerabilities needs a low false negative rate. Only analyzing \"source\" code and only starting from main() is insufficient for understanding modern web and mobile applications: frameworks imply a different programming model with a lot of auto-magical program behavior, often including idiosyncratic configuration regimes and various template languages. We’ll talk about these problems and how we tackle them.",
        "keywords": "Coverity; Soundiness; Synopsys; incremental; mobile applications; parallel; software security; static analysis; transpilation; web applications",
        "released": 2019,
        "link": "https://doi.org/10.1145/3315568.3338015"
    },
    {
        "title": "Enki: A pedagogical services aggregator for learning programming languages",
        "abstract": "This paper presents Enki, a web-based IDE that integrates several pedagogical tools designed to engage students in learning programming languages. Enki achieves this goal (1) by sequencing educational resources, either expository or evaluative, (2) by using gamification services to entice students to solve activities, (3) by promoting social interaction and (4) by helping students with activities, providing feedback on submitted solutions. The paper describes Enki, its concept and architecture, details its design and implementation, and covers also its validation.",
        "keywords": "e-learning; educational resources; exercises; gamification; integration; programming languages; sequencing",
        "released": 2016,
        "link": "https://doi.org/10.1145/2899415.2899441"
    },
    {
        "title": "Characterizing search activities on stack overflow",
        "abstract": "To solve programming issues, developers commonly search on Stack Overflow to seek potential solutions. However, there is a gap between the knowledge developers are interested in and the knowledge they are able to retrieve using search engines. To help developers efficiently retrieve relevant knowledge on Stack Overflow, prior studies proposed several techniques to reformulate queries and generate summarized answers. However, few studies performed a large-scale analysis using real-world search logs. In this paper, we characterize how developers search on Stack Overflow using such logs. By doing so, we identify the challenges developers face when searching on Stack Overflow and seek opportunities for the platform and researchers to help developers efficiently retrieve knowledge. To characterize search activities on Stack Overflow, we use search log data based on requests to Stack Overflow’s web servers. We find that the most common search activity is reformulating the immediately preceding queries. Related work looked into query reformulations when using generic search engines and found 13 types of query reformulation strategies. Compared to their results, we observe that 71.78",
        "keywords": "Data Mining; Query Logs; Query Reformulation; Stack Overflow",
        "released": 2021,
        "link": "https://doi.org/10.1145/3468264.3468582"
    },
    {
        "title": "Embedding secure coding instruction into the IDE: A field study in an advanced CS course",
        "abstract": "Many of the security vulnerabilities common in today’s software can be prevented with standard secure coding practices. Computer science students who will become the developers of that software need to learn about those practices so they can prevent such vulnerabilities. Many computing programs are addressing this need through additional lectures, elective courses, or more holistic approaches to integrate security across curriculums. We are exploring a complementary approach, integrating secure coding education into the IDE to provide a learning opportunity in the context of writing code. In this paper, we report on two field studies using an IDE tool in an advanced Web programming course. Our results indicate that the tool can increase students’ awareness and knowledge of secure programming, but to be most effective, instructors may need to incentivize its use through in-class methods and careful timing of its introduction.",
        "keywords": "ide; secure programming; security education",
        "released": 2015,
        "link": "https://doi.org/10.1145/2676723.2677280"
    },
    {
        "title": "Difficulties in learning c++ and GUI programming with qt platform: View of students",
        "abstract": "We have conducted a C++ and GUI programming workshop with Qt platform and a set of 14 tutorials on the several of concepts and topics of programming fundamentals and Qt framework. This is a programming workshop with computer lab sessions without any formal lectures. The aim is to understand how difficulties for students in learning C++ and GUI programming. A set of web-based questionnaire according to the 14 fundamental programming tutorials has been conducted and come out with an analysis and discussion of results. Preliminary result has shown that the students could create GUI applications easily with the difficult and multi-paradigm programming language such as C++ using programming IDE tools that comes with GUI builder.",
        "keywords": "C++; Programming fundamentals; Qt framework; graphical user interface (GUI) programming; object-oriented programming (OOP); programming basics; programming difficulties",
        "released": 2017,
        "link": "https://doi.org/10.1145/3108421.3108429"
    },
    {
        "title": "MakeCode and CODAL: Intuitive and efficient embedded systems programming for education",
        "abstract": "Across the globe, it is now commonplace for educators to engage in the making (design and development) of embedded systems in the classroom to motivate and excite their students. This new domain brings its own set of unique requirements. Historically, embedded systems development requires knowledge of low-level programming languages, local installation of compilation toolchains, device drivers, and applications. For students and educators, these requirements can introduce insurmountable barriers. We present the motivation, requirements, implementation, and evaluation of a new programming platform that enables novice users to create software for embedded systems. The platform has two major components: 1) Microsoft MakeCode (), a web app that encapsulates an entire beginner IDE for microcontrollers; and 2) CODAL, an efficient component-oriented C++ runtime for microcontrollers. We show how MakeCode and CODAL provide an accessible, cross-platform, installation-free programming experience for the BBC micro:bit and other embedded devices.",
        "keywords": "classroom; education; embedded systems",
        "released": 2018,
        "link": "https://doi.org/10.1145/3211332.3211335"
    },
    {
        "title": "Assessing GRASP utilization through instrumentation",
        "abstract": "The idea that representing something visually can help us understand it has long been promoted in common practice and in the literature [1,2,3,4,5,6]. Indeed, \"a picture is worth a thousand words\" has become a standard cliché in our culture. In the case of software, however, one must take great care that it is the correct thousand words that are being conveyed [5]. Nonetheless, appropriate visualizations of software can be quite beneficial to programmers, especially when faced with program comprehension tasks. Such tasks exist throughout the software life cycle (e.g., formal technical reviews, debugging, verification, reverse engineering) and in the classroom (e.g., students reading examples from the text or examples from the professor).The GRASP (Graphical Representations of Algorithms, Structures, and Processes) research project at Auburn University seeks to develop tools and techniques for the effective use of graphical representations and visualizations of software. The overall goal of this research is to increase the efficiency of programmer comprehension and understanding of source code, and thereby decrease overall software cost. As an integral part of the research project, the GRASP software engineering tool has been developed as a continuously evolving prototype. The emphasis of the tool to this point has been on visualizing program structure and complexity via the automatic generation of Control Structure Diagrams (CSDs) and Complexity Profile Graphs (CPGs) from Ada source code [7]. The current release of GRASP provides generation of CSDs and CPGs together with other program comprehension aids such as syntax coloring, typographical enhancements, and source code folding [8]. When coupled with an appropriate compilation system such as GNAT, GRASP becomes an integrated graphical development environment for Ada 95, allowing users to edit, visualize, pretty-print, compile, link, execute and debug Ada software.The GRASP prototype for Ada was first made available to the public in January 1996. Since that time, thousands of copies of GRASP have been downloaded via anonymous file transfer protocol (FTP) and the World Wide Web (WWW) from educational, government, military and commercial sites, both in the United States and abroad. When it was released to the public, GRASP was also made available to users of the Auburn University College of Engineering computer network. GRASP is now used extensively throughout the computer science and engineering curriculum at Auburn University, in approximately three to five courses per quarter.",
        "keywords": "",
        "released": 1998,
        "link": "https://doi.org/10.1145/291712.295792"
    },
    {
        "title": "Active support for clone refactoring: A perspective",
        "abstract": "Clone refactoring (merging duplicate code) is a promising solution to improve the maintainability of source code. In this position paper, we discuss directions towards the advancement of clone refactoring, and show a perspective of active support based on online analysis of code modification on an editor of IDE.",
        "keywords": "code clone; ide; refactoring",
        "released": 2013,
        "link": "https://doi.org/10.1145/2541348.2541352"
    },
    {
        "title": "Discovering clones in software: From complex algorithms to everyday desktop tool",
        "abstract": "Software clone detection is an actively researched area which has spawned numerous approaches to the problem of duplicated code. These approaches, however, are of little practical use as most of them are ill-suited for incremental analysis required by the developers in their day-to-day activities. This paper tackles the problem of clone detection from the practical point of view, in the context of IDE integration, and presents an online clone detection algorithm based on extended suffix trees. The approach has been tested in a prototype plugin for IntelliJ IDEA and proved its applicability in the industrial setting.",
        "keywords": "IDE; clone detection; suffix trie",
        "released": 2015,
        "link": "https://doi.org/10.1145/2855667.2855676"
    },
    {
        "title": "Business process management (BPM) in a day",
        "abstract": "Business processes today must be developed while businesses are themselves changing to suit turbulent market conditions. Cooperation and collaboration across corporations is the key to developing effective and adaptable business processes in this situation. But how? Both business users and technical developers must work together using a tool that lets both skill sets deliver an optimal solution. One of the most successful business process development tools for both a business user and a technical developer was used in this workshop: IBM’s Business Process Manager Advanced 8.5.This hands-on workshop let CASCON participants work as business users and technical developers to address a business problem with both skill sets. As they altered roles they learned the most appropriate tools to use in Business Process Manager given their different backgrounds, so that the result was something better than what either role would have delivered individually.Standards are also important. Workshop participants learned that Business Process Manager’s tools generate code that complies with the most widely-used industry standards. Specifically, Business Process Modeling Notation (BPMN) was used to design business processes; Web Services Description Language (WSDL) was used to create services; and Business Process Execution Language (BPEL) was used to develop business processes. Tools to create web services supported most web service standards including policy sets, which are often needed for security purposes.However, this workshop was mostly about building good working business processes. Learning by doing!In the first exercise, Process Designer was used to outline a business process as a business analyst might. This meant setting up activities that could contribute to a business solution, dividing the activities into things a person might do and things a program might do. Then these activities had to be wired together to form a sequence or flow, which also meant learning about choices that might make the business process go this way or that way depending on the circumstances when the business process was running in real time. The CASCON participants had to learn initially how to create good business process designs and then later in the workshop how to test those ideas out.Important learning experiences in this first exercise included how to build effective user interfaces using a helpful tool called the Coach. They also learned how to create variables including variables with complex types or business objects. These variables were used to pass data along the business process.A special activity the CASCON participants learned about was the Advanced Integration Service that lets a business process pass work over from Process Designer to Integration Designer. This special service, only available in the Advanced version of Business Process Manager, is a very good way to let a technical user working in Integration Designer share programming solutions with a business user working in Process Designer.And then they switched from Process Designer to Integration Designer to implement an Advanced Integration Service with Java in Integration Designer. Integration Designer is really a developer’s paradise with many tools to create technical solutions with custom code in a variety of languages.While inside Integration Designer, the CASCON participants learned how to unit test with an integrated test environment. Then they returned to Process Designer and system tested their business process so far with a tool called the Inspector. They learned how to develop their business process in iterations by taking a snapshot of their work. A snapshot is like a milestone in the development of a business process.The following exercise focused on a common business challenge: how to reuse applications from the past in a current business process. Most corporations have many applications on hand that they have invested in over a considerable number of years. Business Process Manager, the CASCON participants learned, can take existing applications in Integration Designer, including ones accessing back end systems to get data from databases or Enterprise Resource Planning (ERP) systems like SAP, and make these applications - and their solutions - available to Process Designer.They learned how to associate these applications, which is a way of making them visible to other tools like Process Designer. Another important technique they learned was to use library mirroring. Mirrored libraries are a way of sharing data between Integration Designer and Process Designer.More tools they learned about in Integration Designer included the interface editor to create interfaces and they business object editor to design and build business objects or complex types. CASCON participants worked with a Java editor that generated Java stub code effectively reducing the time to create a Java-based application. Integration Designer is based on Service Oriented Architecture (SOA) and they discovered that the services they created with Integration Designer followed that service standard.One part of that SOA standard is about exports and imports - a means of exposing applications to other applications. They learned how to make an export visible to Process Designer which was a key to sharing data and technical solutions with the business user working in Process Designer.Again, CASCON participants unit tested in Integration Designer to make certain their contribution in that environment was working properly and then system tested in Process Designer with the Inspector. They also created more user interfaces with the Coach. The user interface from the Coach they discovered could be displayed in a source view or a run time view. They learned how to build gateways. Gateways allow a choice in the flow of a business process at run time. The choice is determined by logic in the gateway, which the CASCON participants learned to develop. They completed their second iteration of development with another snapshot to indicate their progress.How do you get data from back end systems where financial records, for example, might be in a format that does not match the format expected in the current business process? In the third exercise, mediation and mapping were used to dynamically solve this eternal technical problem. Returning to Integration Designer, CASCON participants learned how to use a mediation tool to map between two services. In this case, an employee record was used. One service used one kind of name for an identifier and the other service used another name - even though the data was the same. Using a graphical mapping tool they mapped the different representations so that their data could be shared dynamically at run time. And they learned how to add error handling code should something go wrong at run time between the different services sharing their data.This exercise showed the CASCON participants how to work with business objects or complex types in user interfaces. A complex type is a variable that contains other variables. They learned how to use the Coach to develop a user interface that presented data from specific elements within a business object.The CASCON participants again unit tested and system tested their work in both Integration Designer and Process Designer. They created another snapshot for the final iteration of the workshop. A final lecture recaptured what they had learned at the workshop and pointed them to even more features they might want to explore in Business Process Manager on their own.In this workshop, CASCON participants also learned how to integrate Master Data Management (MDM) with business processes. Data governance demands that organizations increase the values of consumption on trusted and accurate data. Data governance ensures having a single version of truth to make smarter business decisions. Master Data Management (MDM) lets you create and maintain the master data; Business Process Manager (BPM) provides organizations the ability to capture and optimize the business processes. This section demonstrated how these two products can work together using in Master Data Governance.",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2555523.2555566"
    },
    {
        "title": "A word from the editor",
        "abstract": "Welcome to ACM Computers in Entertainment, a premier online magazine featuring video interviews with leading professionals and interesting articles on entertainment technology and its applications. In this April/June 2008 issue of ACM CIE, we feature the Video Interviews of Gabrielle Weinman at Team One (November 8, 2007) and David Harris at MTV New Media (November 8, 2007):• Gabrielle Weinman is the Creative Director of Interactive &amp; Relationship Marketing for Team One in Los Angeles. She oversees all aspects of the creative work in both departments, integrating it with traditional advertising. Her biggest client is Lexus automobiles, and other clients have included Ritz Carlton Hotels, Flexjet, MTV, Air New Zealand, Infonet and Heal the Bay. Since technology constantly evolves and changes, her background in design, branding and traditional advertising gives her a distinct advantage. After working at Keith Bright &amp; Associates and Hill Holiday, Gabrielle started as a Senior Art Director at Team One in 1992. In 1995, she agreed to spearhead the development of an interactive group at the strong protest of her headhunter who said she would never work in advertising again. Twelve years later, Gabrielle currently manages a staff of over 25 employees and a department that has won numerous awards including Cannes Cyber Lions, Clios and One Show pencils. In the video interview, you will hear Gabrielle’s answers to the following questions:1. What is the project that you are working on at the AFI Digital Content Lab?2. What is the greatest innovation that you have brought to the project?3. What is your experience working with the AFI Digital Content Lab?4. What suggestions do you have that would make the Digital Content Lab more innovative, useful, and rewarding?5. What do you think about the future of new media?6. What are the major challenges in Interactive TV?7. What are some of the Interactive TV projects that you are working on?8. Do you find it difficult to design good user interface for Interactive TV?9. How do you see the future of Interactive TV?10. If you can do whatever you want, what would you do?• David Harris was born in Puerto Rico, raised in Texas, and received his undergraduate degree in Film, Animation, and Video from the Rhode Island School of Design. He worked as the creative director for Love Advertising, producer for ADV Films, Inc. (one of America’s leading animé companies), and lived in Paris for a year in between. In 2003, he relocated to Los Angeles to pursue his MFA from UCLA in Film, TV and Digital Media. His thesis project, HOWDOISAYTHIS.COM, was sponsored by mtvU and Cisco and won the 2007 SXSW Web Award for Best Student Site. Since launching HOWDOISAYTHIS.COM, Harris worked in the development think tank at Fox Television Studios before taking his current position at MTV New Media, where he is working on the Players project, Jackass World, and a number of interactive projects that are as exciting as they are secret. In the video interview, you will hear David’s answers to the following questions:1. You call yourself the \"MacGyver\" at MTV New Media. Could you elaborate on your role at MTV?2. How does MTV New Media compete with MySpace and YouTube in reaching the MTV audience on the Internet?3. What is your experience in working with the AFI Digital Content Lab?4. What suggestions do you have that would make the Digital Content Lab more innovative, useful, and rewarding?5. What is the innovation of the \"Players\" project that you are working on at the Digital Content Lab?6. If you can do anything you want at MTV, what will you do?In the Games section, we present:1. Using Prototypes in Early Pervasive Game Development (by Elina M.I. Ollila, Riku Suomela, and Jussi Holopainen)2. People, Places, and Play: A research framework for digital game experience in a sociospatial context (by Yvonne A. W. De Kort and Wijnand A. Ijsselsteijn)3. An Architecture to Easily Produce Adventure and Movie Games for the Mobile Scenario (by Marco Furini)4. Toward an Understanding of Flow in Video Games (by Ben Cowley, Darryl Charles, Michaela Black, and Ray Hickey)5. NEAT-o-Games: Blending Physical Activity and Fun in the Daily Routine (by Yuichi Fujiki, Konstantinos Kazakos, Colin Puri, Pradeep Buddharaju, And Ioannis Pavlidis)6. CHARACTER PLAY - The use of game characters in multi-player Role Playing Games across platforms (by Anders Tychsen, Michael Hitchens, and Thea Brolund)In the Entertainment Technology section, we present:1. The evaluation of ARCO: a lesson in curatorial competence and intuition with new technology (by Styliani Sylaiou)2. A Goal Oriented Development Tool to Automate the Incorporation of Intelligent Agents into Interactive Digital Media Applications (by Han Yu, Zhiqi Shen, and Chunyan Miao)3. Feature Guided Texture Synthesis (FGTS) for Artistic Style Transfer (by Xuexiang Xie, Feng Tiany, and Hock Soon Seah)4. E = Mc2 + 1: A Fully Digital, Collaborative, High-Definition (Hd) Production From Scene To Screen (by Artur Lugmayr, Hornsby Adrian, Piotr Golebiowski, Satu Jumisko-Pyykko, Fernando Ubis, Simon Reymann, Volker Bruns, Asta Kybartaite, Jarkko Kauranen, and Dirk Matthes)The Analysis: New Media and New Technology section, we present:1. The BBC and its Web 2.0 Partners (by Ben Sutherland)The Announcements column highlights some of the upcoming events and conferences. Please visit http://www.acm.org/pubs/cie/conferences.html for a complete listing of upcoming and past conferences co-sponsored by ACM Computers in Entertainment.",
        "keywords": "",
        "released": 2008,
        "link": "https://doi.org/10.1145/1371216.1371217"
    },
    {
        "title": "An exploratory study of backtracking strategies used by developers",
        "abstract": "Developers frequently backtrack while coding. They go back to an earlier state by removing inserted code or by restoring removed code for various reasons. However, little is known about when and how the developers backtrack, and modern IDEs do not provide much assistance for backtracking. As a first step towards gathering baseline knowledge about backtracking and designing more robust backtracking assistance tools in modern IDEs, we conducted an exploratory study with 12 professional developers and a follow-up online survey. Our study revealed several barriers they faced while backtracking. Subjects often manually commented and uncommented code, and often had difficulty finding relevant parts to backtrack. Backtracking was reported to be needed by 3/4 of the developers at least \"sometimes\".",
        "keywords": "component; exploratory programming; undo",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2663638.2663669"
    },
    {
        "title": "A preliminary study on the suitability of stack overflow for open innovation in requirements engineering",
        "abstract": "Due to lack of resources (funds, social influence, user feedback etc.), small companies, in particular, start-up companies, almost exclusively must rely on their own expertise with regards to technological innovation. Therefore, it could be beneficial for them to analyze big companies or competitors’ products in order to get a better understanding of what users think about them. The core idea of my research project is to use opinions voiced by users about strengths and weaknesses of competitors’ products to improve the understanding of actual user needs and thus help focus the requirements definition of the small, especially start-up company’s own product. In order to lower the cost of analysis, we investigate how user needs can be distilled from online open sources. Since there are different types of online open sources, as a starting point of our current stage of research, we focused on one type of online open sources - question and answer (Q&amp;A) sites such as Stack Overflow. As a showcase, we used the IDE project Eclipse. In our exploratory study, we analyzed the popularity of Eclipse, the amount of questions asked, the amount of questions asked that received an accepted answer, as well as the contents of questions asked about Eclipse. We also analyzed the emotional polarity of the posted questions. We found that the Stack Overflow timely updates, and the emotions reflected is more objective according to the result shown by sentiment analysis that 82",
        "keywords": "data mining; eclipse; open innovation; requirements engineering; stack overflow",
        "released": 2017,
        "link": "https://doi.org/10.1145/3162957.3162965"
    },
    {
        "title": "Androsgi: Bringing the power of OSGi to android",
        "abstract": "Nowadays, Android is by far the most popular operating system on a myriad of mobile devices. Although based on the Java programming language, Android does not offer the same benefits as a dynamic software module system such as OSGi. Nevertheless OSGi would have many advantages on mobile environments. Software modularity allows you to only deploy the required pieces of software at runtime. Moreover, many of the enterprise OSGi specifications facilitate the development of distributed applications connecting to the Cloud. In order to exploit these advantages on Android, we present Androsgi, an Eclipse IDE plugin that allows you to easily run OSGi on top of Android. The Androsgi plugin facilitates deploying OSGi bundles, and calling both local and remote OSGi services from within your Android application.",
        "keywords": "Android; Bndtools; Eclipse; OSGi",
        "released": 2015,
        "link": "https://doi.org/10.1145/2846650.2846652"
    },
    {
        "title": "Inference of development activities from interaction with uninstrumented applications",
        "abstract": "Studying developers’ behavior is crucial for designing effective techniques and tools to support developers’ daily work. However, there are two challenges in collecting and analyzing developers’ behavior data. First, instrumenting many software tools commonly used in real work settings (e.g., IDEs, web browsers) is difficult and requires significant resources. Second, the collected behavior data consist of low-level and fine-grained event sequences, which must be abstracted into high-level development activities for further analysis.In this paper [1], to address these two challenges, we first use our ActivitySpace framework to improve the generalizability of the data collection. Then, we propose a Condition Random Field (CRF) based approach to segment and label the developers’ low-level actions into a set of basic, yet meaningful development activities. To evaluate our proposed approach, we deploy the ActivitySpace framework in an industry partner’s company and collect the real working data from ten professional developers’ one-week work. We conduct an experiment with the collected data and a small number of initial human-labeled training data using the CRF model and the other three baselines (i.e., a heuristic-rules based method, a SVM classifier, and a random weighted classifier). The proposed CRF model achieves better performance (i.e., 0.728 accuracy and 0.672 macro-averaged F1-score) than the other three baselines.",
        "keywords": "conditional random field; developers’ interaction data; software development",
        "released": 2018,
        "link": "https://doi.org/10.1145/3180155.3182537"
    },
    {
        "title": "Parsons problems usage within a MOOC pedagogy: (Abstract only)",
        "abstract": "Parsons Problems is an effective Introductory Programming teaching tool that allows students to arrange code to form a functional program, reducing their cognitive load so they can focus on programming concepts. This demonstration shows how Parsons Problems can be used as a pedagogical strategy in a Massive Open Online Course (MOOC) for introductory programming. A MOOC is a learning platform, where compilers and IDEs have already been embedded for CS students to immerse themselves in a single learning environment. The Parsons Problems package, js-parsons, available at https://github.com/js-parsons/js-parsons has been successfully integrated into the University of Adelaide’s edX’s MOOC platform as a component that can potentially be made available for other edX platforms. The demonstration presents the educators’ interface to add new questions and receive students’ results, along with students’ perspective, including subgoals. The demonstration prototypes new feedback models when students encounter Parsons Problems errors, opening discussion up to the audience for opinions and input. This demonstration is intended for anyone wanting to know how to use Parsons Problems within MOOCs as a pedagogical approach; those seeking to incorporate MOOCs into their coursework with focused exercises; and those wanting to contribute to future Parsons Problems enhancements. Laptops are recommended, since participants will have the hands-on opportunity to evaluate the package during the demonstration.",
        "keywords": "introductory programming; mooc; parsons problems",
        "released": 2018,
        "link": "https://doi.org/10.1145/3159450.3162207"
    },
    {
        "title": "Exploring the impact of exposing CS majors to programming concepts using IDE programming vs. Non-IDE programming in the classroom",
        "abstract": "Due to the increased demand for computer scientists in the, the importance to improve the retention rate of CS majors who could potentially fill such positions has been ongoing. Literature has produced many efforts for increasing the engagement of CS majors in the field while also exploring ways to improve their ability to develop the ideal skill sets for success. In such efforts, our research explores the impact of visual and/or command-line based programming editors and their ability to shape the students’ mental model as they learn to program. This abstract discusses a \"think-aloud\" protocol assessment that was conducted on two entry level programming courses at a university in the United States during the 2018-2019 school year. The objective of this assessment was to determine whether Repl.IT, a web-based IDE, and Cygwin/Nano Editor, a command line-based tool, impacted student performance while being used for programming. Our preliminary results showed that 41",
        "keywords": "cs-majors; programming-editors; verbal-protocol-assessment",
        "released": 2020,
        "link": "https://doi.org/10.1145/3328778.3372701"
    },
    {
        "title": "Forward: Data-centric UIS using declarative templates that efficiently wrap third-party JavaScript components",
        "abstract": "While Ajax programming and the plethora of JavaScript component libraries enable high-quality Uls in web applications, integrating them with page data is laborious and error-prone as a developer has to handcode incremental modifications with trigger-based programming and manual coordination of data dependencies. The FORWARD web framework simplifies the development of Ajax applications through declarative, state-based templates. This declarative, data-centric approach is characterized by the principle of logical/physical independence, which the database community has often deployed successfully. It enables FORWARD to leverage database techniques, such as incremental view maintenance, updatable views, capability-based component wrappers and cost-based optimization to automate efficient live visualizations. We demonstrate an end-to-end system implementation, including a web-based IDE (itself built in FORWARD), academic and commercial applications built in FORWARD and a wide variety of JavaScript components supported by the declarative templates.",
        "keywords": "",
        "released": 2014,
        "link": "https://doi.org/10.14778/2733004.2733052"
    },
    {
        "title": "Mobl: The new language of the mobile web",
        "abstract": "Mobl is a new language designed to declaratively construct mobile web applications. Mobl integrates languages for user interface design, styling, data modeling, querying and application logic into a single, unified language that is flexible, expressive, enables early detection of errors, and has good IDE support.",
        "keywords": "domain-specific language; mobile web; software development",
        "released": 2011,
        "link": "https://doi.org/10.1145/2048147.2048159"
    },
    {
        "title": "Rapid interweaving of smart things with the meSchup IoT platform",
        "abstract": "Although physical prototyping platforms such as Arduino have significantly lowered the barrier for the development of standalone networked smart things, it still remains very challenging to create multi-device environments in which heterogeneous devices collaborate in smart ways to assist their users. However, with the ever growing number of networked smart things in our home, office and public environments it becomes more and more important to practically explore the opportunities that these device ecologies can potentially offer in the future. With meSchup we present an IoT prototyping platform that drastically reduces the effort and time for the creation and exploration of smart multi-device environments. We show a novel interaction script approach that interweaves arbitrary devices in real time and introduce interactive programming by demonstrations features integrated in a single web based IDE. We finally illustrate three exemplary use cases that indicate the wide range of possible applications.",
        "keywords": "internet of things; middleware; programming by demonstration; rapid prototyping; smart environments",
        "released": 2016,
        "link": "https://doi.org/10.1145/2968219.2971379"
    },
    {
        "title": "Model based control for multi-cloud applications",
        "abstract": "The advent of cloud computing has offered to developers a new appealing paradigm to deploy their applications without capital investments. Resources can now be acquired on-demand in a flexible, scalable and rapid way. However, cloud providers lack of native mechanisms to guarantee the Quality of Service required by specific application domains. High availability can be achieved by replication of critical components. Since outages could affect the entire cloud provider, replication can be effective only by using multiple providers.In this paper we tackle the above problem and present an approach to guarantee availability requirements of cloud-based applications by exploiting replication on multiple clouds to reduce unavailability, still limiting costs. More precisely, we propose: i) an approach to model, at design time, the application, its availability requirements and the characteristics of the used clouds, and ii) a self-adaptive technique responsible, at runtime, of both in-cloud scaling policies and traffic routing among different cloud providers, by means of a control-theoretical approach.We integrated the modeling approach in the Palladio Bench IDE and developed a runtime self-adaptation controller in Matlab. The controller has been evaluated against different workload conditions, costs variations and service failures in simulated scenarios. The controller has been able to provide the desired availability minimizing costs.",
        "keywords": "availability; cloud computing; control theory; multi-cloud applications; non-functional requirements; self-adaptive software",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2662737.2662747"
    },
    {
        "title": "Facilitating computing students’ transition to higher education",
        "abstract": "Students who progress to higher education from further education colleges are faced with academic, social, and logistical challenges during their transition. In general, they find university life more challenging compared to students who have been at university for two years already. The Associate Student Project (ASP) is an intervention programme within the School of Computing that provides support to students who make this transition. This support includes access to online resources, orientation events, university lectures and workshops, throughout their two years at further education college. This study aims to measure the impact of the ASP through a survey on academic behavioural confidence and a comparison of the grade point average of three student groups: independent direct entrants (n=53), associate students (n=27), and native students (students who entered university at first year, n=75). Analysis revealed that, while independent direct entrants (IDE) were less confident about their studies than native students (NS), there was a closer parity of confidence between native and associate students (AS). In addition, AS’ confidence on tasks that relate to requesting information is higher than the other groups, perhaps due to the ASP’s emphasis on providing good information to AS and encouraging dialogue. Associate students found interventions that provide insight into university life prior to their transfer useful. Additionally, the grade point average of AS was not found to be significantly different in comparison to native students. This paper reports on the success of these interventions in building student confidence and explores the impact for transitional students.",
        "keywords": "direct entrants; further education; higher education; student transitions; widening participation",
        "released": 2019,
        "link": "https://doi.org/10.1145/3351287.3351298"
    },
    {
        "title": "Building call graphs for embedded client-side code in dynamic web applications",
        "abstract": "When developing and maintaining a software system, programmers often rely on IDEs to provide editor services such as syntax highlighting, auto-completion, and \"jump to declaration\". In dynamic web applications, such tool support is currently limited to either the server-side code or to hand-written or generated client-side code. Our goal is to build a call graph for providing editor services on client-side code while it is still embedded as string literals within server-side code. First, we symbolically execute the server-side code to identify all possible client-side code variations. Subsequently, we parse the generated client-side code with all its variations into a VarDOM that compactly represents all DOM variations for further analysis. Based on the VarDOM, we build conditional call graphs for embedded HTML, CSS, and JS. Our empirical evaluation on real-world web applications show that our analysis achieves 100",
        "keywords": "Call Graphs; Embedded Code; Web Code Analysis",
        "released": 2014,
        "link": "https://doi.org/10.1145/2635868.2635928"
    },
    {
        "title": "CrossLanguageSpotter: A library for detecting relations in polyglot frameworks",
        "abstract": "Nowadays, most of the web frameworks are developed using different programming languages, both for server and client side programmes. The typical scenario includes a general purpose language (e.g. Ruby, Python, Java) used together with different specialized languages: HTML, CSS, Javascript and SQL. All the artifacts are connected via different types of relations, most of which depend on the adopted framework. These cross-language relations are normally not captured by tools which require the developer to learn and to remember those associations in order to understand and maintain the application. This paper describes a library for detecting cross-language relations in polyglot frameworks. The library has been developed to be modular and to be easily integrated in existing IDEs. The library is publicly available at http://github.com/CrossLanguageProject/crosslanguagespotter",
        "keywords": "cross-language relations; polyglot development; tool support",
        "released": 2014,
        "link": "https://doi.org/10.1145/2567948.2578036"
    },
    {
        "title": "CSI-SE ’17: Proceedings of the 4th international workshop on CrowdSourcing in software engineering",
        "abstract": "It is our pleasure to welcome the reader to the (pre-workshop) proceedings of the 4th International Workshop on CrowdSourcing in Software Engineering (CSI-SE 2017), co-located with the 39th International Conference on Software Engineering (ICSE 2017) held in Buenos Aires, Argentina, during May 20-28, 2017.A number of trends under the broad banner of crowdsourcing are beginning to fundamentally disrupt the way in which software is engineered. Programmers increasingly rely on crowdsourced knowledge and code, as they look to Question &amp; Answer (Q&amp;A) sites for answers or use code from publicly posted snippets. Programmers play, compete, and learn with the crowd, engaging in programming competitions and puzzles with crowds of programmers. Online IDEs make possible radically new forms of collaboration, allowing developers to synchronously program with crowds of distributed programmers. Programmers’ reputation is increasingly visible on Q&amp;A sites and public code repositories, opening new possibilities in how developers find jobs and companies identify talent. Crowds of non-programmers increasingly participate in development, usability testing software or even constructing specifications while playing games. Crowds play an increasing role in shaping software requirements, broadening the software which might be feasibly constructed. Approaches for crowd development seek to microtask software development, dramatically increasing participation in open source by enabling software projects to be built through casual, transient work.",
        "keywords": "",
        "released": 2017,
        "link": "https://dl.acm.org/doi/10.5555/3100549"
    },
    {
        "title": "Microtask programming: Building software with a crowd",
        "abstract": "Microtask crowdsourcing organizes complex work into workflows, decomposing large tasks into small, relatively independent microtasks. Applied to software development, this model might increase participation in open source software development by lowering the barriers to contribu-tion and dramatically decrease time to market by increasing the parallelism in development work. To explore this idea, we have developed an approach to decomposing programming work into microtasks. Work is coordinated through tracking changes to a graph of artifacts, generating appropriate microtasks and propagating change notifications to artifacts with dependencies. We have implemented our approach in CrowdCode, a cloud IDE for crowd development. To evaluate the feasibility of microtask programming, we performed a small study and found that a small crowd of 12 workers was able to successfully write 480 lines of code and 61 unit tests in 14.25 person-hours of time.",
        "keywords": "crowdsourcing; development environment; programming tools",
        "released": 2014,
        "link": "https://doi.org/10.1145/2642918.2647349"
    },
    {
        "title": "A model for linguistic resource description",
        "abstract": "This paper describes a comprehensive standard for resource description developed within ISO TC37 SC4). The standard is instantiated in a system of XML headers that accompany data and annotation documents represented using the the Linguistic Annotation Framework’s Graph Annotation Format (GrAF) (Ide and Suderman, 2007; Ide and Suderman, Submitted). It provides mechanisms for describing the organization of the resource, documenting the conventions used in the resource, associating data and annotation documents, and defining and selecting defined portions of the resource and its annotations. It has been designed to accommodate the use of XML technologies for processing, including XPath, XSLT, and, by virtue of the system’s linkage strategy, RDF/OWL, and to accommodate linkage to web-based ontologies and data category registries such as the OLiA ontologies (Chiarcos, 2012) and ISOCat (Marc Kemps-Snijders and Wright, 2008).",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2392747.2392757"
    },
    {
        "title": "An interactive system for data structure development",
        "abstract": "Data structure algorithms are of fundamental importance in teaching and software development, yet are difficult to understand. We propose a new approach for understanding, debugging and developing heap manipulating data structures. The key technical idea of our work is to combine deep parametric abstraction techniques emerging from the area of static analysis with interactive abstraction manipulation. Our approach bridges program analysis with HCI and enables new capabilities not possible before: i) online automatic visualization of the data structure in a way which captures its essential operation, thus enabling powerful local reasoning, and ii) fine grained pen and touch gestures allowing for interactive control of the abstraction – at any point the developer can pause the program, graphically interact with the data, and continue program execution. These features address some of the most pressing challenges in developing data structures. We implemented our approach in a Java-based system called FluiEdt and evaluated it with $27$ developers. The results indicate that FluiEdt is more effective in helping developers find data structure errors than existing state of the art IDEs (e.g. Eclipse) or pure visualization based approaches.",
        "keywords": "debugging; program analysis; software development",
        "released": 2015,
        "link": "https://doi.org/10.1145/2702123.2702319"
    },
    {
        "title": "A multi-filter feature selection in detecting distributed denial-of-service attack",
        "abstract": "Distributed Denial of Services (DDoS) has become the most intrusive security threat on the Internet. Flash crowd attack is the most challenging problem among the attacks which targeting the web server during the Flash Events (FEs). It mimics the behaviour of legitimate users and sends high rate malicious traffics toward the server and block the normal users from using the desired services. Thus, making it hard to detect and successfully bypasses the detection mechanism. The key semantic difference between FEs and DDoS is that the former represents legitimate access of the website while the latter does not. However, this does not help in discriminating them automatically. The behavioural differences between the two have to be developed after understanding their individual properties. In this research, a Multi-Filter Feature Selection (M2FS) method is proposed by combining the 3 filter methods which are Information Gain (IG), Gain Ratio (GR) and ReliefF. It consists of 3-stage procedures: feature ranking, feature selection and classification. Subsequently, an experimental evaluation of the proposed Multi-Filter Feature Selection (M2FS) method is performed by using the benchmark dataset, NSL-KDD and employed the J48 classification algorithm. The performance of the proposed M2FS method is evaluated by multi-criteria that take into account which are classification accuracy, True Positive Rate (TPR), False Positive Rate (FPR) and time to build the model. Meanwhile, the performance of effectiveness of the proposed M2FS method is then compared with the existing feature selection methods and also the proposed M2FS with PCA. In addition, the proposed M2FS method is developed through WEKA API with Java Programming language using the IDE of Eclipse Java. The findings show that the proposed M2FS method is effectively reduced the 41 features to 14 features and produced a high accuracy, high TPR, low FPR and shorter time build when compared to other existing feature selection methods.",
        "keywords": "detection accuracy; distributed denial-of-service attack; feature selection and classification; flash crowd",
        "released": 2020,
        "link": "https://doi.org/10.1145/3369555.3369572"
    },
    {
        "title": "A framework to protect multiple applications in java using synchronization.",
        "abstract": "Today, everything has gone distributed for so many types of server applications. We have Web servers, application servers, database servers, file servers, and mail servers that maintain worker queues and thread pools to handle large numbers of short tasks that arrive from remote sources. In this paper we have done analysis for multithreaded programs, focusing on ways to improve the efficiency of analyzing interactions between threads. A multithreaded program always contains two or more parts that can run concurrently without lagging and each part can handle different tasks at the same time making optimal use of the available resources. Each task is independent of the other. Multithreading is based on the idea of multitasking in applications where specific operations within a single application are further divided into individual threads. This application of multithreading is developed using Eclipse IDE. Eclipse consists of a base workspace and an extensible plug-in system for customizing the environment.",
        "keywords": "Eclipse; Multithreading; Synchronization; Thread Lifecycle; Thread Runnable; Thread priority",
        "released": 2016,
        "link": "https://doi.org/10.1145/2905055.2905347"
    },
    {
        "title": "Software architecture model driven reverse engineering approach to open source software development",
        "abstract": "Popular Open Source Software (OSS) development platforms like GitHub, Google Code, and Bitbucket take advantage of some best practices of traditional software development like version control and issue tracking. Current major open source software environments, including IDE tools and online code repositories, do not provide support for visual architecture modeling. Research has shown that visual modeling of complex software projects has benefits throughout the software lifecycle. Then why is it that software architecture modeling is so conspicuously missing from popular online open source code repositories? How can including visual documentation improve the overall quality of open source software projects? Our goal is to answer both of these questions and bridge the gap between traditional software engineering best practices and open source development by applying a software architecture documentation methodology using Unified Modeling Language, called 5W1H Re-Doc, on a real open source project for managing identity and access, MITREid Connect. We analyze the effect of a model-driven software engineering approach on collaboration of open source contributors, quality of specification conformance, and state-of-the-art of architecture modeling. Our informal experiment revealed that in some cases, having the visual documentation can significantly increase comprehension of an online OSS project over having only the textual information that currently exists for that project.",
        "keywords": "model-driven software engineering; open source software development; software architecture documentation",
        "released": 2014,
        "link": "https://doi.org/10.1145/2656434.2656440"
    },
    {
        "title": "CSI-SE ’16: Proceedings of the 3rd international workshop on CrowdSourcing in software engineering",
        "abstract": "It is our pleasure to welcome the reader to the (pre-workshop) proceedings of the 3rd International Workshop on CrowdSourcing in Software Engineering (CSI-SE 2016), co-located with the 38th International Conference on Software Engineering (ICSE 2016) held in Austin, TX, USA on May 16, 2016.A number of trends under the broad banner of crowdsourcing are beginning to fundamentally disrupt the way in which software is engineered. Programmers increasingly rely on crowdsourced knowledge and code, as they look at Q&amp;A websites for answers or use code from publicly posted snippets. Programmers play, compete, and learn with the crowd, engaging in programming competitions and puzzles with crowds of programmers. Online IDEs make radically new forms of collaboration possible, allowing developers to synchronously program with crowds of distributed programmers. Programmer reputation is increasingly visible on Q&amp;A sites and public code repositories, opening new possibilities in how developers find jobs and companies identify talent. Crowds of non-programmers increasingly participate in development, usability testing software or even constructing specifications while playing games. Developers can take feedback from a crowd of users to guide further evolution of their applications. Crowdfunding democratizes choices about which software is built, broadening the software which might be feasibly constructed. Approaches for crowd development seek to microtask software development, dramatically increasing participation in open source by enabling software projects to be built through casual, transient work.",
        "keywords": "",
        "released": 2016,
        "link": "https://dl.acm.org/doi/10.1145/2897659"
    },
    {
        "title": "Co-located collaborative software visualization",
        "abstract": "Most software visualization tools are designed from a single-user perspective and are bound to the desktop, IDEs, and the web. Few tools are designed with sufficient support for the social aspects of software engineering such as collaboration, communication, and awareness. Our research aims at supporting co-located collaborative software analysis using software visualization techniques with multi-touch tables. The research will be conducted via user experiments which will inform the design of multi-touch software visualization applications and further our understanding of how developers work together with co-located collaborative tools.",
        "keywords": "co-located collaboration; multi-touch; software visualization",
        "released": 2010,
        "link": "https://doi.org/10.1145/1938595.1938603"
    },
    {
        "title": "phpModeler - a web model extractor",
        "abstract": "This paper presents phpModeler, a tool for reverse engineering of legacy php web applications that generates static UML diagrams showing resources which the current web page is using, its functions and dependencies it has on other web pages. Once the models describing individual web pages have been generated, phpModeler can analyze them and generate dependency models that for each entity in every page model show all entities dependent on it. phpModeler can also be used to highlight the difference between page models – a feature that, when combined with a SVN repository shows the way how the current web page has evolved over time. phpModeler is a plugin for the Eclipse IDE.",
        "keywords": "architecture recovery; maintenance; reverse engineering; tool; web applications",
        "released": 2009,
        "link": "https://doi.org/10.1109/ASE.2009.40"
    },
    {
        "title": "Reducing the barriers to writing verified specifications",
        "abstract": "Formally verifying a program requires significant skill not only because of complex interactions between program subcomponents, but also because of deficiencies in current verification interfaces. These skill barriers make verification economically unattractive by preventing the use of less-skilled (less-expensive) workers and distributed workflows (i.e., crowdsourcing). This paper presents VeriWeb, a web-based IDE for verification that decomposes the task of writing verifiable specifications into manageable subproblems. To overcome the information loss caused by task decomposition, and to reduce the skill required to verify a program, VeriWeb incorporates several innovative user interface features: drag and drop condition construction, concrete counterexamples, and specification inlining.To evaluate VeriWeb, we performed three experiments. First, we show that VeriWeb lowers the time and monetary cost of verification by performing a comparative study of VeriWeb and a traditional tool using 14 paid subjects contracted hourly from Exhedra Solution’s vWorker online marketplace. Second, we demonstrate the dearth and insufficiency of current ad-hoc labor marketplaces for verification by recruiting workers from Amazon’s Mechanical Turk to perform verification with VeriWeb. Finally, we characterize the minimal communication overhead incurred when VeriWeb is used collaboratively by observing two pairs of developers each use the tool simultaneously to verify a single program.",
        "keywords": "crowdsourcing; human factors; program verification",
        "released": 2012,
        "link": "https://doi.org/10.1145/2384616.2384624"
    },
    {
        "title": "Supporting developers with natural language queries",
        "abstract": "The feature list of modern IDEs is steadily growing and mastering these tools becomes more and more demanding, especially for novice programmers. Despite their remarkable capabilities, IDEs often still cannot directly answer the questions that arise during program comprehension tasks. Instead developers have to map their questions to multiple concrete queries that can be answered only by combining several tools and examining the output of each of them manually to distill an appropriate answer. Existing approaches have in common that they are either limited to a set of predefined, hardcoded questions, or that they require to learn a specific query language only suitable for that limited purpose. We present a framework to query for information about a software system using guided-input natural language resembling plain English. For that, we model data extracted by classical software analysis tools with an OWL ontology and use knowledge processing technologies from the Semantic Web to query it. We use a case study to demonstrate how our framework can be used to answer queries about static source code information for program comprehension purposes.",
        "keywords": "conceptual queries; natural language; semantic web; software evolution; software maintenance; source code analysis; tool support",
        "released": 2010,
        "link": "https://doi.org/10.1145/1806799.1806827"
    },
    {
        "title": "WikiNext, a JavaScript wiki with semantic features",
        "abstract": "WikiNext, is a semantic wiki prototype written in JavaScript, from database to server and client code. It is not in competition with wikis like Semantic Media Wiki, but more a test bed for new ideas. Every wiki page is an application that keeps a Web Socket open with the server, enabling incremental saves or collaborative editions using Google wave like algorithms. Using JavaScript on the whole chain of operations avoids data transformation from/to different formats like in traditional approaches (Objects, JSON/XML, and SQL). WikiNext uses JavaScript distributed objects and includes an IDE to write JS applications within wiki pages.",
        "keywords": "HTML5; JavaScript; MongoDB; NodeJS; RDF; linked open data; semantic web; web socket; wiki",
        "released": 2012,
        "link": "https://doi.org/10.1145/2462932.2462979"
    },
    {
        "title": "CSI-SE ’15: Proceedings of the second international workshop on CrowdSourcing in software engineering",
        "abstract": "It is our pleasure to welcome the reader to the (pre-workshop) proceedings of the 2nd International Workshop on Crowd Sourcing in Software Engineering (CSI-SE 2015), co-located with the 37th International Conference on Software Engineering (ICSE 2015) held in Florence, Italy, May 19, 2015.A number of trends under the broad banner of crowdsourcing are beginning to fundamentally disrupt the way in which software is engineered. Programmers increasingly rely on crowdsourced knowledge and code, as they look to Q&amp;A sites for answers or use code from publicly posted snippets. Programmers play, compete, and learn with the crowd, engaging in programming competitions and puzzles with crowds of programmers. Online IDEs make radically new forms of collaboration possible, allowing developers to synchronously program with crowds of distributed programmers. Programmer reputation is increasingly visible on Q&amp;A sites and public code repositories, opening new possibilities in how developers find jobs and companies identify talent. Crowds of non-programmers increasingly participate in development, usability testing software or even constructing specifications while playing games. Crowdfunding democratizes choices about which software is built, broadening the software which might be feasibly constructed. Approaches for crowd development seek to microtask software development, dramatically increasing participation in open source by enabling software projects to be built through casual, transient work.",
        "keywords": "",
        "released": 2015,
        "link": "https://dl.acm.org/doi/10.5555/2820116"
    },
    {
        "title": "Special issue on: E-commerce systems development practices",
        "abstract": "The last few years have witnessed a rapid growth in development of web-based solutions to support or initiate new forms of e-commerce. Though a few normative approaches have been proposed for different stages of the development process, it is not clear yet how practitioners or consultants are actually developing these systems. As the e-commerce revolution matures, in-depth accounts of development of actual e-commerce systems have remained sketchy. Informal evidence suggests that highly localized approaches are being used to develop innovative e-commerce solutions. The stories being shared among successful practitioners are still largely anecdotal and confined to success stories or colossal failures. The debacle of dot.com businesses during 2001 has left these issues severely under-investigated. Accounts of both successful and not-so-successful actual e-commerce systems development projects would, therefore, be useful in furthering our understanding of this complex area of study. The three articles in this special issue provide interesting perspectives on understanding several ongoing practices in this arena.The article by Hevner et al identifies and discusses key concerns faced by several organizations that focus on systems development for e-commerce. Based on an in-depth case study of a medium sized e-commerce software development organization, they suggest the perspective of conflicting product versus project challenges in software development activities. Their analysis leads to identification of eight critical challenges in the three areas of organizational structure, relationship with external environment and the development environment. The authors elaborate on these challenges, suggest theoretical propositions for confirmatory research, and link the propositions to managerial actions to suggest implications for practice.The article by Chiasson presents an analysis of the process related to developing an e-commerce system for a startup venture in the on-line magazine (\"e-zine\") business using structuration theory as the theoretical lens. Following an action research approach, the study develops an understanding of the agency-structure relationship involved in shaping the technological and organizational structure. Conflicting design philosophies in the initial stage (multimedia ’front-end’ versus content management through web-database integration) gives way to a role of the system in the later stages as a strategic change agent redirecting the company towards a new business focus. The analysis leads to a critical discussion of structuration theory and its limitations in acknowledging the importance of human reflexivity in the structuration process.The article by Henfridsson and Holmström discusses how e-commerce development in \"internetworked organizations\" may enable changes to the traditional corporate value chain. Based on an interpretive case study of the development of an on-line computer game, the authors describe an effort to enable customer involvement throughout the value chain including product development, evaluation, distribution and marketing. They find that the close customer involvement adds value by increasing the company’s ability to respond to changing customer demands and preferences. Interestingly, they observe a greater dependency on the customers and their devotion for the game, which illustrates that internetworked organizations can be faced with the challenge associated with handling customers as partners in the value chain. The authors discuss implications for the role of customer involvement in virtual value chains, suggesting an extended view on the e-commerce development process.The articles by Chiasson, and Henfridsson and Holmström, thus, present in-depth studies of practices related to development of E-commerce systems in different organizational contexts. They exemplify several challenges presented in the first paper by Hevner et al. The three articles together present an in-depth account of the complexities involved in the process of E-commerce systems development, characterized by rapid technological development and often fast-paced projects driven by extreme competitiveness and changing market demands. The context of the three cases presented (e-commerce software development organization, startup venture in the on-line magazine business and on-line computer game developer) serves to highlight different challenges and concerns characterizing E-commerce development practice today. Further research can contribute to extend our understanding in other contexts. Findings presented in these papers can serve as early benchmarks of the significant challenges in E-commerce systems development today. A possible extension can include the development of prescriptive methodologies and models that may be customized for different contexts. Many of the challenges identified in these papers also have a rich history in systems development research. Further research should, therefore, strike a balance between proposing innovative ways to understand these challenges and adapting established ap-proaches and accepted wisdom for systems development to the particular context of E-commerce systems development.",
        "keywords": "",
        "released": 2002,
        "link": "https://doi.org/10.1145/590806.590809"
    },
    {
        "title": "Declaratively programming the mobile web with mobl",
        "abstract": "A new generation of mobile touch devices, such as the iPhone, iPad and Android devices, are equipped with powerful, modern browsers. However, regular websites are not optimized for the specific features and constraints of these devices, such as limited screen estate, unreliable Internet access, touch-based interaction patterns, and features such as GPS. While recent advances in web technology enable web developers to build web applications that take advantage of the unique properties of mobile devices, developing such applications exposes a number of problems, specifically: developers are required to use many loosely coupled languages with limited tool support and application code is often verbose and imperative. We introduce mobl, a new language designed to declaratively construct mobile web applications. Mobl integrates languages for user interface design, styling, data modeling, querying and application logic into a single, unified language that is flexible, expressive, enables early detection of errors, and has good IDE support.",
        "keywords": "domain-specific language; mobile; mobile development; mobile web",
        "released": 2011,
        "link": "https://doi.org/10.1145/2048066.2048121"
    },
    {
        "title": "A web-integrated verifying compiler for RESOLVE: A research perspective",
        "abstract": "RESOLVE is an integrated language that combines imperative programming and mathematical specifications for full functional verification of component-based programs. From a researcher’s perspective, this paper summarizes the elements of RESOLVE’s web IDE that includes a verifying compiler. We use a variety of in-language examples to demonstrate the following: Extensible mathematical units that contain definitions and results, higher-order specifications of generic components that use those mathematical units, alternative implementations of specifications, and automated generation of verification conditions and proofs for implementation correctness. While verification and research are the focus of this paper, it’s worth mentioning that the compiler translates RESOLVE code to Java (or C) for execution, and has been utilized in a variety of computer science classes at multiple institutions over the last five years.",
        "keywords": "automation; components; formal methods; specification; verifying compiler",
        "released": 2014,
        "link": "https://doi.org/10.1145/2590748.2590760"
    },
    {
        "title": "MSR challenge 2011: Eclipse, netbeans, firefox, and chrome",
        "abstract": "The MSR Challenge aims at offering researchers and practitioners in the area of Mining Software Repositories a shared set of software repositories, enabling them to compare their tools and approaches. This year, the main theme of the challenge was on the comparison of projects. We selected four open source projects, and challenged participants to use their brains, tools, computational power, and magic to compare them and uncover interesting similarities and differences. The projects were Eclipse and Netbeans, two popular IDEs written in Java (Group 1) and Firefox and Chrome, two web browsers written in C/C++ (Group 2). We encouraged participants to analyze more than one project, ideally in the same group but allowed them to analyze a single project.",
        "keywords": "data repositories; report",
        "released": 2011,
        "link": "https://doi.org/10.1145/1985441.1985478"
    },
    {
        "title": "RuntimeDroid: Restarting-free runtime change handling for android apps",
        "abstract": "Portable devices, like smartphones and tablets, are often subject to runtime configuration changes, such as screen orientation changes, screen resizing, keyboard attachments, and language switching. When handled improperly, such simple changes can cause serious runtime issues, from data loss to app crashes.This work presents, to our best knowledge, the first formative study on runtime change handling with 3,567 Android apps. The study not only reveals the current landscape of runtime change handling, but also points out a common cause of various runtime change issues – activity restarting. On one hand, the restarting facilitates the resource reloading for the new configuration. On the other hand, it may slow down the app, and more critically, it requires developers to manually preserve a set of data in order to recover the user interaction state after restarting.Based on the findings of this study, this work further introduces a re starting-free runtime change handling solution – RuntimeDroid. RuntimeDroid can completely avoid the activity restarting, at the same time, ensure proper resource updating with user input data preserved. These are achieved with two key components: an online resource loading module, called HotR and a novel UI components migration technique. The former enables proper resources loading while the activity is still live. The latter ensures that prior user changes are carefully preserved during runtime changes.For practical use, this work proposes two implementations of RuntimeDroid: an IDE plugin and an auto-patching tool. The former allows developers to easily adopt restarting-free runtime change handling during the app developing; The latter can patch released app packages without source code. Finally, evaluation with a set of 72 apps shows that RuntimeDroid successfully fixed all the 197 reported runtime change issues, meanwhile reducing the runtime change handling delays by 9.5X on average.",
        "keywords": "Android; Event Handling; Runtime Configuration Change",
        "released": 2018,
        "link": "https://doi.org/10.1145/3210240.3210327"
    },
    {
        "title": "JQuery: Finding your way through tangled code",
        "abstract": "A typical IDE based exploration of an OOP system will often involve multiple searches through class hierarchies, field accesses, method calls, regular expression matches and more. Developers who must follow connections between these disconnected views may find great difficulty in combining the capabilities of each view and may as well suffer significant disorientation due to loss of context while switching. toolname is a flexible, query-based source code browser that alleviates this disorientation by allowing the user to explore the various types of structural relationships between elements of the code without the distraction of switching tools. Using toolname, a developer can define his or her own top-level browsers on-the-fly by formulating logic queries and running them against the source code. Elements in the tree can then be queried individually in the same manner, allowing further exploration of the complex web of relationships that exist between scattered elements of code.",
        "keywords": "browser; exploration; navigation; query engine; visualization",
        "released": 2004,
        "link": "https://doi.org/10.1145/1028664.1028670"
    },
    {
        "title": "The lively kernel: A wiki of active objects: Invited talk",
        "abstract": "The Lively Kernel is a complete platform for Web programming written in JavaScript using graphics available in leading browsers. A widget set built from these elements provides a user interface kit, and the widget set is also extensible. A window-based IDE allows users to edit their applications and even the system itself.",
        "keywords": "",
        "released": 2008,
        "link": "https://doi.org/10.1145/1822258.1822261"
    },
    {
        "title": "Eliminating dead-code from XQuery programs",
        "abstract": "One of the challenges in web software development is to help achieving a good level of quality in terms of code size and runtime performance, for increasingly popular domain specific languages such as XQuery. We present an IDE equipped with static analysis features for assisting the programmer. These features are capable of identifying and eliminating dead code automatically. The tool is based on newly developed formal programming language verification techniques [4, 3], which are now mature enough to be introduced in the process of software development.",
        "keywords": "",
        "released": 2010,
        "link": "https://doi.org/10.1145/1810295.1810363"
    },
    {
        "title": "Improving feature location practice with multi-faceted interactive exploration",
        "abstract": "Feature location is a human-oriented and information-intensive process. When performing feature location tasks with existing tools, developers often feel it difficult to formulate an accurate feature query (e.g., keywords) and determine the relevance of returned results. In this paper, we propose a feature location approach that supports multi-faceted interactive program exploration. Our approach automatically extracts and mines multiple syntactic and semantic facets from candidate program elements. Furthermore, it allows developers to interactively group, sort, and filter feature location results in a centralized, multi-faceted, and intelligent search User Interface (UI). We have implemented our approach as a web-based tool MFIE and conducted an experimental study. The results show that the developers using MFIE can accomplish their feature location tasks 32",
        "keywords": "",
        "released": 2013,
        "link": "https://dl.acm.org/doi/10.5555/2486788.2486888"
    },
    {
        "title": "Authoring multi-stage code examples with editable code histories",
        "abstract": "Multi-stage code examples present multiple versions of a program where each stage increases the overall complexity of the code. In order to acquire strategies of program construction using a new language or API, programmers consult multi-stage code examples in books, tutorials and online videos. Authoring multi-stage code examples is currently a tedious process, as it involves keeping several stages of code synchronized in the face of edits and error corrections. We document these difficulties with a formative study examining how programmers author multi-stage code examples. We then present an IDE extension that helps authors create multi-stage code examples by propagating changes (insertions, deletions and modifications) to multiple saved versions of their code. Our system adapts revision control algorithms to the specific task of evolving example code. An informal evaluation finds that taking snapshots of a program as it is being developed and editing these snapshots in hindsight help users in creating multi-stage code examples.",
        "keywords": "editable histories; examples; programming; tutorials",
        "released": 2013,
        "link": "https://doi.org/10.1145/2501988.2502053"
    },
    {
        "title": "An efficient dual caching strategy for web service-enabled PDAs",
        "abstract": "PDAs have evolved over the years from resource constrained devices that supported only the most basic tasks to powerful handheld computing devices. However, the most significant step in the evolution of PDAs was the introduction of wireless connectivity which enabled them to host applications that require internet connectivity like email, web browsers and maybe most importantly smart/rich clients. Being able to host smart clients allows the users of PDAs to seamlessly access the IT resources (e.g. legacy apps) of their organizations. One increasingly popular way of enabling access to IT resources is by using Web Services (WS) [14]. This trend has been aided by the rapid availability of Web Service (WS) packages/tools, most notably the efforts of the Apache group [1] and IDE vendors (e.g., Microsoft’s Visual Studio [2], IBM’s Eclipse [3]). Using IDE tools and other software packages it is fairly easy for programmers to expose application interfaces and/or consume existing interfaces leading to a gradual replacement of the current web server centric approaches (e.g. ASP, JSP, Servlets, CGI scripts) with WS centric approach.This paper focuses on the challenges of enabling PDAs to host Web Services consumers and introduces a dual caching approach to overcome problems arising from temporarily loss of connectivity and fluctuations in bandwidth.",
        "keywords": "SOA; caching; model-based caching; nomadic web services client; web services",
        "released": 2007,
        "link": "https://doi.org/10.1145/1244002.1244178"
    },
    {
        "title": "Teaching database systems with web applications team projects",
        "abstract": "This paper describes an approach to teaching undergraduate-level database systems with Web applications team projects. The Web applications employ the three-tier architecture in the Java programming language with Apache Tomcat as the Web server and PostgreSQL as the database server. Students use the Eclipse IDE configured for Web applications and the CVS concurrent versioning system for team member cooperation on software development. The database topics covered in the course are closely synchronized with the steps students take in their team projects. To minimize the intrusion of Web programming, straightforward sample programs and a sample Web application are used to help students in acquiring the knowledge and skills of Web applications development and applying them in their projects.",
        "keywords": "",
        "released": 2008,
        "link": "https://dl.acm.org/doi/10.5555/1295109.1295130"
    },
    {
        "title": "Automatically detecting developer activities and problems in software development work",
        "abstract": "Detecting the current activity of developers and problems they are facing is a prerequisite for a context-aware assistance and for capturing developers experiences during their work. We present an approach to detect the current activity of software developers and if they are facing a problem. By observing developer actions like changing code or searching the web, we detect whether developers are locating the cause of a problem, searching for a solution, or applying a solution. We model development work as recurring problem solution cycle, detect developer’s actions by instrumenting the IDE, translate developer actions to observations using ontologies, and infer developer activities by using Hidden Markov Models. In a preliminary evaluation, our approach was able to correctly detect 72",
        "keywords": "",
        "released": 2012,
        "link": "https://dl.acm.org/doi/10.5555/2337223.2337390"
    },
    {
        "title": "A resource support toolkit (r-IDE): Supporting the DECIDE framework",
        "abstract": "A central activity involved in the user-centred design process is usability evaluation. Cost-effective evaluation tools to fully support usability evaluations however, are still limited. The aim of this work is to introduce a web-based, resource-supported, interactive evaluation toolkit called R-IDE, which guides evaluation planners through the various activities involved in planning and conducting usability evaluations. The IDE stages of the DECIDE framework provide the basis for the design of this toolkit, which currently supports two evaluation methods: heuristic evaluation for websites and standard questionnaires. This paper describes the design, development, evaluation and future potential of this toolkit.",
        "keywords": "evaluation methods; evaluation toolkit; heuristic evaluation",
        "released": 2006,
        "link": "https://doi.org/10.1145/1152760.1152768"
    },
    {
        "title": "Team: Towards a software engineering semantic web",
        "abstract": "Large software development projects are complex endeavours that involve numerous participants which can work across several sites and act in various roles. Each participant produces and consumes information relevant for the success of the project. In such settings, an effective and efficient allocation of knowledge is a hard challenge, especially if there is no central authority, which enforces standards for the whole ecosystem. We consider semantic technologies as an important enabler to improve information and knowledge sharing in such scenarios, by helping to exchange and interconnect software engineering knowledge across the web. In this paper, we describe the corresponding vision of a Software Engineering Semantic Web and the role of intelligent IDEs in order to benefit from and contribute to it.",
        "keywords": "collaboration; knowledge management; knowledge sharing",
        "released": 2008,
        "link": "https://doi.org/10.1145/1370114.1370129"
    },
    {
        "title": "Argumentation scheme and shared online diagramming in case-based collaborative learning",
        "abstract": "Argumentation schemes describe patterns of reasoning in discourse. We report an investigation into whether the argumentation scheme known as ’inference to the best explanation’ (IBE) captures the argumentation found in collaborative case-based learning. We examine the dialogue of three students working in an online learning environment as they attempt to explain the verdict in a legal case of medical negligence; the IDE scheme is clearly visible in the dialogue. We also report the exploratory development of shared argument diagramming tools that allow learners to draw their explanations while they discuss them. The tools passively reinforce the IBE argumentation scheme. Evaluation of the tools provided the clearest evidence to date that learners are able to integrate their shared online argument diagramming with their computer-mediated dialogue.",
        "keywords": "",
        "released": 2009,
        "link": "https://dl.acm.org/doi/10.5555/1600053.1600135"
    },
    {
        "title": "Organizing services for a changing environment",
        "abstract": "Service-oriented computing is the \"new wave\" emerging from the growing up of web services and its adoption of elements of semantic web technology. More sophistication, in response to business requirements, does of course not make it easier to use or to control. In particular business processes demand resilience and (real-time) adaptation in the face of changing business requirements, incorporation of alternative services and finding suitable substitutes when those needed are not available. The EU-funded ALIVE project is prototyping ideas, driven by commercial and industrial uses cases, that utilize research in organizational modelling, software agents, model-driven engineering, artificial intelligence, semantic web and web services to construct tools and demonstrators to address these needs. This tutorial will focus on a use case from the ALIVE project (in one of the domains of crisis management, communications, or information services), discuss the requirements that arise from it and then explore it from the three perspectives that characterize the ALIVE approach: organizations, coordination and services, all illustrated by the innovative tools that have been developed during the project.More information about the ALIVE project can be downloaded from http://www.ist-alive.eu and a public release of the ALIVE tools, integrated into the Eclipse IDE will be available from mid October via the above website.",
        "keywords": "agents; organizations; services",
        "released": 2010,
        "link": "https://doi.org/10.1145/1967486.1967492"
    },
    {
        "title": "Role-based interfaces for collaborative software development",
        "abstract": "Real-time collaboration between multiple simultaneous contributors to a shared document is full of both opportunities and pitfalls, as evidenced by decades of research and industry work in computer-supported cooperative work. In the domain of software engineering, collaboration is still generally achieved either via shared use of a single computer (e.g. pair programming) or with version control (and manual pushing and pulling of changes). By examining and designing for the different roles collaborating programmers play when working synchronously together, we can build real-time collaborative programming systems that make their collaboration more effective. And beyond simple shared editing, we can provide asymmetric, role-specific interfaces on their shared task. Collabode is a web-based IDE for collaborative programming with simultaneous editors that, along with several novel models for closely-collaborative software development, explores the potential of real-time cooperative programming.",
        "keywords": "collaboration; crowdsourcing; pair programming; software development",
        "released": 2011,
        "link": "https://doi.org/10.1145/2046396.2046410"
    },
    {
        "title": "A survey of scientific software development",
        "abstract": "Software for scientific research purposes has received increased attention in recent years. Case studies have noted development practices, limitations, and problems in the development of scientific software. However, applicability of the results of these studies to improving the wider scientific software development practices is not known. This paper presents a survey of 60 scientific software developers. The survey was conducted online from August–September 2009, and aims to identify where improvements to scientific software practices can be made. While our results generally confirm previous work, we have found some notable differences. The use of IDEs and version control tools among the surveyed scientific software developers has increased, and trace-ability of scientific software is not as important to scientific software developers as it is to scientific software users. Documentation also appears to be more widely produced than previous studies indicate. However, there remains room for improvement in tool use, documentation, testing, and verification activities for scientific software development.",
        "keywords": "scientific software; scientists; software engineering; survey",
        "released": 2010,
        "link": "https://doi.org/10.1145/1852786.1852802"
    },
    {
        "title": "Human factors considerations in the design of a multiple source expert system for military applications (abstract only)",
        "abstract": "In this paper we present a prototype expert system characterized by two major premises: there are multiple sources of knowledge within the knowledge base;human factors considerations must receive paramount attention.The domain of the prototype is AirLand combat planning. (Airland combat is a new Army warfare doctrine developed in the early 1980’s. Its emphases include active defense, interdiction of the second echelon, early counterattack, and other tactical principles.) The potential users are Army division commanders and staff who are engaged in or are training for combat in Central Europe.Our prototype’s knowledge sources are representative of those encountered in a wider class of applications, through its use of sources which may be incomplete, ambiguous and conflicting, such as: doctrinal knowledge found in policy statements, Army regulations, and professional manuals (FM 100-5). Doctrine can be viewed as a constraint on tactics, combat organization, fire and maneuver schemes, and command and control systems;knowledge from an expert from the domain environment (provided by the historian, Colonel Trevor N. Dupuy);distilled wisdom gleaned from the historical writings of great military thinkers, theorists, and commanders. The first sources to be included are the Maxims of Napoleon and material from von Clausewitz;previous experience with analysis of outcome of appropriate historical cases;results from a computer simulation (operations research) model, the Quantified Judgment Model (QJM). The QJM takes information about a combat situation and generates a prediction (based on many variables) of the victor. It also predicts advance rates, casualty rates, equipment loss and recovery rates, plus many other factors.[1] It is being used as a preprocessor for the expert system.Another important feature concerns the status of each of the knowledge components, i.e., whether the overall system is best envisioned as a collection of more or less autonomous expert systems governed by a controlling expert system, or whether the knowledge collection can be organized in some principled way to allow the multiple sources to be handled within a more homogeneous setting, the limit being a single expert system with accessibility to a (relational) database and other resources, especially simulation results. (A simulation capability is considered by some researchers [2,3] to be an important part of an expert system designed to provide task planning.) Consideration is being given to the implementation of the simulation portion on a parallel processing machine, specifically the Sequent 21000.Important human factors exist for many kinds of expert systems and, especially so, for the application study of the paper. [4] Included among these factors are: mode of the system, defining the attitude of the system with regard to the user, e.g., consultation, critique, advisory, alert, advocacy; [5]conversational style;architecture of the system and its relation to user stress;causal assessment and support of good human decision making in expert systems;avoidance of consequence buffering or transfer of responsibility from the user to the expert system.Constrained for a number of reasons to a microcomputer environment for the expert system portion of the prototype, we have chosen to utilize the Texas Instruments Personal Consultant Plus development tool to achieve such goals as: rapid development time, ease of explanation generation, availability of both forward- and backward-chaining control mechanisms, built-in functions for online help and other explanatory features, convenient knowledge base segmentation through use of frames, consistent user interface between development and user environments.",
        "keywords": "",
        "released": 1987,
        "link": "https://doi.org/10.1145/322917.322980"
    },
    {
        "title": "ADDiff: Semantic differencing for activity diagrams",
        "abstract": "Activity diagrams (ADs) have recently become widely used in the modeling of workflows, business processes, and web-services, where they serve various purposes, from documentation, requirement definitions, and test case specifications, to simulation and code generation. As models, programs, and systems evolve over time, understanding changes and their impact is an important challenge, which has attracted much research efforts in recent years.In this paper we present addiff, a semantic differencing operator for ADs. Unlike most existing approaches to model comparison, which compare the concrete or the abstract syntax of two given diagrams and output a list of syntactical changes or edit operations, addiff considers the semantics of the diagrams at hand and outputs a set of diff witnesses, each of which is an execution trace that is possible in the first AD and is not possible in the second. We motivate the use of addiff, formally define it, and show two algorithms to compute it, a concrete forward-search algorithm and a symbolic fixpoint algorithm, implemented using BDDs and integrated into the Eclipse IDE. Empirical results and examples demonstrate the feasibility and unique contribution of addiff to the state-of-the-art in version comparison and evolution analysis.",
        "keywords": "activity diagrams; diagrams; software evolution",
        "released": 2011,
        "link": "https://doi.org/10.1145/2025113.2025140"
    },
    {
        "title": "WinHIPE: An IDE for functional programming based on rewriting and visualization",
        "abstract": "The article describes an IDE for functional programming, called WinHIPE. It provides an interactive and flexible tracer, as well as a powerful visualization and animation system. The former tool is based on the rewriting model of evaluation, and the latter provides automatic generation of visualizations and animations, friendly support for customization, maintenance and exportation of animations to the Web, and facilities to cope with large scale. Its main advantage over other visualization systems is an effortless approach to animation creation and maintenance, based on generating visualizations and animations automatically, as a side effect of program execution. Finally, we briefly describe our experience using the system during several years in educational settings.",
        "keywords": "expression evaluation; functional programming; program animation; program visualization; programming environments; term rewriting; tracing",
        "released": 2007,
        "link": "https://doi.org/10.1145/1273039.1273042"
    },
    {
        "title": "What’s on your hard drive? What’s on your hard drive?",
        "abstract": "Submissions pour in daily, creating piles of late-night prescreening work for the Queue oompa loompas. We’re also receiving e-mail feedback from irate readers, questioning why we published Joe Blow’s emphatic endorsement of such and such IDE when “frankly, it totally sucks.” To accommodate these impulses we’re taking WOYHD to the Web, where we’ll post each month’s results, complete with a comments feature so you can argue about which tools are great and which tools you hate.",
        "keywords": "",
        "released": 2005,
        "link": "https://doi.org/10.1145/1053331.1053339"
    },
    {
        "title": "Perspectives on active learning and collaboration: JavaWIDE in the classroom",
        "abstract": "The Java Wiki Integrated Development Environment (JavaWIDE) is an innovative environment that promotes active learning and collaboration in programming courses. This paper surveys how JavaWIDE’s features have been used to promote active and collaborative learning in both traditional and distance education (synchronous) in four different environments: high school, summer enrichment courses, and at two- and four-year colleges. The authors describe the context of each teaching and learning environment and the parts of JavaWIDE that are particularly well suited in each context. After discussing the active learning and collaboration techniques employed, student responses to the experience are summarized. This collection of case studies illustrates how the concurrent editing, shared environment awareness and other features of JavaWIDE can be used to promote active learning and collaboration within a heterogeneous set of teaching and learning environments.",
        "keywords": "CS0; CS1; Java; active learning; case study; collaboration; concurrent editing; distance education; introductory programming; javawide; tutoring; web-based IDE",
        "released": 2012,
        "link": "https://doi.org/10.1145/2157136.2157194"
    },
    {
        "title": "Wiki as business application platform: The MES showcase",
        "abstract": "This presentation shows the business application suite mHub that implements the core components of a manufacturing execution system (MES) purely with a specially developed application wiki distribution. The novelty of the application wiki is its \"wiki as business application platform\" approach, that abstracts all necessary technologies to implement the solution within the edit page area. Other than application wikis targeted for end users, that merely serve as query interfaces to existing business applications, this application wiki enables developers to script every aspect of the application domain within the wiki itself.",
        "keywords": "ERP; MES; application wikis; collaborative software development; manufacturing automation and control; rapid application development; software engineering; web IDE",
        "released": 2011,
        "link": "https://doi.org/10.1145/2038558.2038603"
    },
    {
        "title": "Mining unit tests for discovery and migration of math APIs",
        "abstract": "Today’s programming languages are supported by powerful third-party APIs. For a given application domain, it is common to have many competing APIs that provide similar functionality. Programmer productivity therefore depends heavily on the programmer’s ability to discover suitable APIs both during an initial coding phase, as well as during software maintenance.The aim of this work is to support the discovery and migration of math APIs. Math APIs are at the heart of many application domains ranging from machine learning to scientific computations. Our approach, called MathFinder, combines executable specifications of mathematical computations with unit tests (operational specifications) of API methods. Given a math expression, MathFinder synthesizes pseudo-code comprised of API methods to compute the expression by mining unit tests of the API methods. We present a sequential version of our unit test mining algorithm and also design a more scalable data-parallel version.We perform extensive evaluation of MathFinder (1) for API discovery, where math algorithms are to be implemented from scratch and (2) for API migration, where client programs utilizing a math API are to be migrated to another API. We evaluated the precision and recall of MathFinder on a diverse collection of math expressions, culled from algorithms used in a wide range of application areas such as control systems and structural dynamics. In a user study to evaluate the productivity gains obtained by using MathFinder for API discovery, the programmers who used MathFinder finished their programming tasks twice as fast as their counterparts who used the usual techniques like web and code search, IDE code completion, and manual inspection of library documentation. For the problem of API migration, as a case study, we used MathFinder to migrate Weka, a popular machine learning library. Overall, our evaluation shows that MathFinder is easy to use, provides highly precise results across several math APIs and application domains even with a small number of unit tests per method, and scales to large collections of unit tests.",
        "keywords": "API discovery; API migration; mathematical computation; mining; unit tests",
        "released": 2014,
        "link": "https://doi.org/10.1145/2629506"
    },
    {
        "title": "Enhanced object management for high performance web proxies",
        "abstract": "The dramatic increase of WWW traffic on the Internet has led to the wide use of web proxy. The web proxies can be used to improve security, save network bandwidth and reduce network latency. However, as the network bandwidth increased, the general-purpose file system is rapidly becoming the performance bottleneck of web proxies. In this paper, we propose an enhanced object management, called UNIFIED, which is a user-level technique for improving the performance of web proxy. In UNIFIED method, several techniques are developed to improve the disk I/O performance. Instead of the traditional trace-driven simulation, we employ Polygraph 2.5.4 with Polymix-3 workload to evaluate our system realistically. To investigate how the proxy performance depends on the equipped disk, we offer two sets of test machines. One is equipped with one IDE disk and the other is equipped with five SCSI disks. Experimental results show that, in both tests, our method can improve the proxy performance dramatically by reducing the overhead associated with disk I/O.",
        "keywords": "Web Proxies; disk I/O; polygraph; user-level",
        "released": 2004,
        "link": "https://doi.org/10.1145/967900.968239"
    },
    {
        "title": "IDE support for test-driven development and automated grading in both java and c++",
        "abstract": "Students need to learn testing skills, and using test-driven development on assignments is one way to help students learn. We use a flexible automated grading system called Web-CAT to assess student assignments, including the validity and completeness of their own test cases. By building on existing educational plug-ins for Eclipse, and adding our own plug-ins for electronic submission and for unit testing support in C++, we are able to use Eclipse as a portal to all the services our students will need, allowing them to accomplish all their tasks entirely within the IDE, from their project’s inception to its submission and evaluation. Further, we are able to carry students through the transition from Java programming to C++ programming within this same environment.",
        "keywords": "Eclipse IDE; electronic assignment submission; electronic grading; extreme programming; test-driven development; test-first coding",
        "released": 2005,
        "link": "https://doi.org/10.1145/1117696.1117717"
    },
    {
        "title": "Psychological factors in information system design",
        "abstract": "Over the past few years, there has been a significant increase in online usage of computer systems as the result of sharp reductions in the cost of computer hardware, improved technology for data communications and mass storage, and the availability of sophisticated operating systems, program development tools, and interactive applications software. This increase in the quantity of interactive programs is producing a growing number of non-programming users who are using conversational computer systems. These users have information system needs which are quite different from those of programmers.The eventual acceptance of such an information system into routine usage is often dependent upon a number of psychological and related non-technical issues, rather than upon the mechanical aspects of the system. Failure to consider these essential psychological issues will often produce an information system which will be rejected by those for whom it was designed and developed. These factors which affect user attitudes include the general predisposition of the user toward the computer, the process by which the system development and introduction was undertaken, and the operational characteristics of the system. Within these broad categories, a number of more specific items may be listed, including:1) Predispositiona) Nature of the organization–some groups of users are more willing to accept computer technologyb) Perceived threat–computers can represent an ego threat by appearing to perform a job better than a human can or an economic threat by appearing to be intended to replace humans in their jobsc) Individual \"mind set\"–willingness to adapt to new computerized working environment with possible associated changes in job function2) System development and introduction processa) User involvement in design process–users must be participants at all levels and stages of information system development or selection rather than having a system imposed upon themb) User training–users must be provided with adequate introductory and reference documentation, personal instruction, and possible online assistancec) First impression of running system–a first impression tends to be a lasting impression, so an information system should be usable and reliable from the beginning although changes are being made in response to user comments and experience3) Operational characteristicsa) Reliability–system must be available whenever needed, programs and operating environment must be error-free, and data must be secureb) Terminal characteristics–appropriate choice must be made for keyboard vs. non-keyboard devices, hard copy vs. soft copy, impact vs. non-impact terminal, the noise factor, and the rate of outputc) General ease of use–users desire a minimum of dialogue with the system software, need a method for correcting errors before it affects previous work, and prefer systems which can be learned easily and quicklyd) Nature and \"personality\" of interaction–conversational programs can be rigid or forgiving, employ technical or informal terminology, provide differing features for experienced and non-experienced users, and try to correct simple errors or merely produce diagnostic messagese) Response time–both speed and variability of response time are important issues in user psychologyThese factors vary widely among individuals and organizations, thereby making it difficult to provide definitive guidelines for handling these psychological issues. Furthermore, existing capabilities in operating systems and programming languages often make it difficult to incorporate all of the most desirable features for conversational system design without considerable added effort during system development and additional overhead during program execution. There is a great need to obtain better understanding of the psychological considerations of information system design and to create programming systems and languages which can accommodate these needs.",
        "keywords": "",
        "released": 1974,
        "link": "https://doi.org/10.1145/1408800.1408914"
    },
    {
        "title": "An introduction to c# and the .net framework",
        "abstract": "A new style of programming is developing in which applications are created from building blocks available over the Internet. Integrating software components developed in various languages can be difficult. The .NET framework allows software components written in different languages to interact with each other or with old packaged software written in C/C++, hence supporting interoperability. This framework allows for the management and execution of applications and Web services. The framework provides security, memory management and other programming capabilities. In addition, the architecture is capable of existing on multiple platforms. C# is an event-driven, fully object-oriented, visual programming language that was developed specifically for .NET. Its constructs are familiar enough to enable programmers to migrate from C/C++ and Java easily.This tutorial will present C# and Visual Studio’s .NET IDE. The tutorial will start out with examples of simple console applications, pointing out differences to C++ and Java. It will demonstrate how to visually program windows applications using several pre-packaged components. As time allows, it will cover concepts for building applications that interact with databases usingADO.NET and SQL, as well as building interactive web documents that respond to client requests using ASP.NET.",
        "keywords": "",
        "released": 2005,
        "link": "https://dl.acm.org/doi/10.5555/1047846.1047888"
    },
    {
        "title": "Putting FrameNet data into the ISO linguistic annotation framework",
        "abstract": "This paper describes FrameNet (Lowe et al., 1997; Baker et al., 1998; Fillmore et al., 2002), an online lexical resource for English based on the principles of frame semantics (Fillmore, 1977a; Fillmore, 1982; Fillmore and Atkins, 1992), and considers the FrameNet database in reference to the proposed ISO model for linguistic annotation of language resources (ISO TC37 SC4 )(ISO, 2002; Ide and Romary, 2001b). We provide a data category specification for frame semantics and FrameNet annotations in an RDF-based language. More specifically, we provide a DAML+OIL markup for lexical units, defined as a relation between a lemma and a semantic frame, and frame-to-frame relations, namely Inheritance and Subframes. The paper includes simple examples of FrameNet annotated sentences in an XML/RDF format that references the project-specific data category specification.",
        "keywords": "",
        "released": 2003,
        "link": "https://doi.org/10.3115/1119296.1119300"
    },
    {
        "title": "MSR ’11: Proceedings of the 8th working conference on mining software repositories",
        "abstract": "Welcome to MSR 2011, the Eighth International Working Conference on Mining Software Repositories, held May 21-22 in Waikiki, Honolulu, Hawaii, and co-located with the 2011 ACM/IEEE International Conference on Software Engineering (ICSE 2011).This is the fourth year that MSR has been a Working Conference, building on the strong foundation of four years as a successful ICSE workshop. We are happy to report that the community of MSR researchers continues to grow, while at the same time the research being performed is maturing. This year saw a further increase in the total number of submissions: 61 full paper submissions (10 pages) and 17 short paper submissions (4 pages) for a total of 78. This total is 11 more than the 67 total submissions in 2010. Full paper submissions increased by 10 (61 vs. 51) while short paper submissions increased by 1 (17 vs. 16).Of the 61 full paper submissions, 20 were ultimately accepted, for a full paper accept rate of 33",
        "keywords": "",
        "released": 2011,
        "link": "https://dl.acm.org/doi/10.1145/1985441"
    },
    {
        "title": "Integrating industrial technologies, tools and practices to the IT curriculum: An innovative course with .NET and java platforms",
        "abstract": "Exposure to state-of-art industry technologies, tools and practices by students provide CS/IT graduates highly desirable skills and marketability. A key expectation of the industry from their new cadre is a speedy integration into the business environment resulting in productive work. This usually requires having a sound technological background, a maturity to assess the environment and adapt quickly, and highly-developed soft skills to be productive in a team environment. Incorporating such experience and skills into a CS/IT curriculum is challenging and is still in its infancy stages. We undertook such as an endeavor in integrating .NET into the IT curriculum.Microsoft’s .NET platform is becoming increasingly popular in the industry. Incorporating .NET into the undergraduate IT curriculum provides a plethora of skills and increases the employability of our graduates. We integrated .NET without a major revision to the existing curriculum by introducing an optional course in the final year (senior-level) of the IT undergraduate program.In addition to the .NET platform, the course covered the Java platform, which is similar in architecture to .NET. The course emulated an industry-based environment with real-world based assignments, focused on deliverables, used state-of-art IDEs and documentation, and pair programming to create a highly productive environment.The \"soft skills\" were integrated into the course with a project that implemented a virtual marketplace. Students in groups played different entities in the virtual marketplace and communicated with each other via Web Services. The project provided a virtual business environment and exposure to teamwork, collaboration, competition, negotiating, and creativity skills.Our first offering of the course in semester 1, 2005, attracted 128 students. The course created a highly productive environment throughout the semester. Students completed 7 assignments and the project within the 14-week semester. The initial results are encouraging and provide many insights to CS/IT departments planning to incorporate such courses.",
        "keywords": ".NET platform; CS/IT curriculum; industry practices; java platform; state-of-art technologies",
        "released": 2005,
        "link": "https://doi.org/10.1145/1095714.1095744"
    },
    {
        "title": "XML and information retrieval: A SIGIR 2000 workshop",
        "abstract": "XML - the eXtensible Markup Language has recently emerged as a new standard for data representation and exchange on the Interact. It is believed that it will become a universal format for data exchange on the Web and that in the near future we will find vast amounts of documents in XML format on the Web. As a result, it has become crucial to address the question of how large collections of XML documents can be sorted and retrieved efficiently and effectively.To date, most work on storing, indexing, querying, and searching documents in XML has stemmed from the database community’s work on semi-structured data. An alternative approach, that has received less attention to date, is to view XML documents as a collection of text documents with additional tags and relations between these tags. IR techniques have traditionally been applied to search large sets of textual data and should thus be extended to encode the structure and semantics inherent in XML documents. Integrating IR and XML search techniques will enable more sophisticated search on the structure as well as the content of these documents, while leveraging the success of IR techniques in document similarity ranking and keyword search.The SIGIR workshop on XML and information retrieval was held July 28th, in Athens Greece. The goal of the workshop was to bring together researchers and practitioners interested in XML and IR to discuss and define the most relevant topics in the relation between these two technologies, present recent results, and propose future directions for research. The topics for discussion included:• How to extend IR technologies to search XML documents• How to integrate XML structure in IR indexing structures• How to query XML documents both on content and structure• How to introduce the semantics inherent in XML into the search process• How to adopt database indexing techniques in an IR frameworkThe opening session of the workshop consisted of a survey of search engines for XML documents. This was followed by three technical sessions: query languages, retrieval algorithms, and IR systems for XML documents. The final talk of the day, \"Searching Annotated Language Resources in XML\", by Nancy Ide was given from the perspective of potential users of XML search systems and opened many topics for discussion. The workshop was concluded with a panel discussion where the panelists outlined their vision of the future of XML search.",
        "keywords": "",
        "released": 2001,
        "link": "https://doi.org/10.1145/373626.373705"
    }
]